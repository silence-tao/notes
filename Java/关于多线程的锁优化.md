# 关于多线程的锁优化

## 1.如何提供锁的性能

1.1减小锁持有时间：对于使用锁进行并发控制的应用程序而言，在锁竞争的过程中，单个线程的持有时间与系统性能有着直接的关系。减少锁的持有时间有助于降低锁冲突的可能性，进而提高系统的并发能力。

1.2减小锁粒度：所谓减少锁粒度，就是指缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力。

1.3读写分离锁来替代独占锁：在读多写少的场合，使用读写锁可以有效提升系统的并发能力。

1.4锁分离：如果将读写锁的思想做进一步的延伸，就是锁分离。读写锁根据读写操作功能上的不同，进行了有效地分离。依据应用程序的功能特点，使用类似的分离思想，也可以对独占锁进行分离。

1.5锁粗化：虚拟机在遇到一连串地对同一锁不断进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，这个操作叫做锁的粗化。性能优化就是根据运行时的真是情况对各个资源点进行权衡折中的过程。锁粗化的思想和减少锁持有时间是相反的，但在不同的场合，它们的效果并不相同。

## 2.Java虚拟机对锁的优化

2.1锁偏向：如果一个线程获得了锁，那么锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。

2.2轻量级锁：轻量级锁的操作也很轻便，它只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，来判断一个线程是否持有对象锁。

2.3自旋锁：由于当前线程暂时无法获得锁，但是什么时候能获得锁又是个未知数，所以虚拟机此时会让当前线程做几个空循环（这是自旋的含义），在经过若干次循环后，如果可以得到锁，那么就顺利进入临界区。如果还不能获得锁，才会真是地将线程在操作系统层面挂起。

2.4锁消除：Java虚拟机在JIT编译时，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁。锁消除涉及的一项技术为逃逸分析，所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域。

## 3.比较交换（CAS）

CAS（Compare and swap）算法的过程是这样的：它包含三个参数CAS(V,E,N)。V表示要更新的变量当前在内存中的值，E表示预期值，N表示新值。当且仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。