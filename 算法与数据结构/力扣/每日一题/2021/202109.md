# 2021年9月力扣每日1题

## 20210901 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 165. 比较版本号

原题链接：[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

> 给你两个版本号 version1 和 version2 ，请你比较它们。
>
> 版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
>
> 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。
>
> 返回规则如下：
>
> 如果 version1 > version2 返回 1，
> 如果 version1 < version2 返回 -1，
> 除此之外返回 0。
>
> 提示：
>
> 1 <= version1.length, version2.length <= 500
> version1 和 version2 仅包含数字和 '.'
> version1 和 version2 都是 有效版本号
> version1 和 version2 的所有修订号都可以存储在 32 位整数 中

### 1.直接法

``` java
class Solution {
    public int compareVersion(String version1, String version2) {
        // 先将两个版本号分割成字符串数组
        String[] arr1 = version1.split("\\.");
        String[] arr2 = version2.split("\\.");

        int len1 = arr1.length, len2 = arr2.length;
        // 然后按位比较每一位的大小
        for (int i = 0; i < Math.max(len1, len2); i++) {
            // 将每一位修订号转成整型
            // 如果超出数组范围则转成0
            int ver1 = i < len1 ? Integer.parseInt(arr1[i]) : 0;
            int ver2 = i < len2 ? Integer.parseInt(arr2[i]) : 0;

            // 比较两个修订号是否相等
            if (ver1 != ver2) {
                // 不相等ver1 > ver2返回1
                // 否则返回-1
                return ver1 > ver2 ? 1 : -1;
            }
        }

        // 到了这里说明所有的修订号都相等
        // 即两个版本号相等，返回0
        return 0;
    }
}
```

## 20210902 <font color=#009975>E</font> <font color=#009975>S</font>

### 剑指 Offer 22. 链表中倒数第k个节点

原题链接：[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
>
> 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

### 1.双指针

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        int idx = 1;
        ListNode first = head;
        // 想让第一个指针跳到第k个节点
        while (idx++ < k) {
            first = first.next;
        }

        // 然后再让第一个指针从头开始
        ListNode second = head;
        // 两个指针同时前进
        // 当第一个指针到达最后一个节点时
        // 第二个指针刚好到倒数第k个节点的位置
        while (first.next != null) {
            first = first.next;
            second = second.next;
        }

        return second;
    }
}
```

## 20210903 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 面试题 17.14. 最小K个数

原题链接：[面试题 17.14. 最小K个数](https://leetcode-cn.com/problems/smallest-k-lcci/)

> 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
>
> **提示：**
>
> - `0 <= len(arr) <= 100000`
> - `0 <= k <= min(100000, len(arr))`

### 1.排序

``` java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        Arrays.sort(arr);

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = arr[i];
        }

        return res;
    }
}
```

## 20210904 <font color=#009975>E</font> <font color=#009975>S</font>

### 剑指 Offer 10- I. 斐波那契数列

原题链接：[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> **提示：**
>
> - `0 <= n <= 100`

### 1.动态规划

``` java
class Solution {
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }

        int INF = 1000000007;

        // 斐波那契数列其实只需要前两个数的状态
        // 所以这里用first表示F(N - 2)
        // second表示F(N - 1)
        int first = 0, second = 1;
        for (int i = 2; i <= n; i++) {
            // t表示F(N)
            int t = (first + second) % INF;

            // 为下一轮更新F(N - 2)
            // 即现在的F(N - 1)
            first = second;
            // 为下一轮更新F(N - 1)
            // 即现在的F(N)
            second = t;
        }

        // 所以当循环结束时
        // second
        return second;
    }
}
```

## 20210905 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 470. 用 Rand7() 实现 Rand10()

原题链接：[470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

> 已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。
>
> 不要使用系统的 Math.random() 方法。
>
> **提示:**
>
> 1. `rand7` 已定义。
> 2. 传入参数: `n` 表示 `rand10` 的调用次数。

### 1.拒绝采样

[参考题解](https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/)

``` java
/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */
class Solution extends SolBase {
    public int rand10() {
        int a, b, num;
        do {
            a = rand7();
            b = rand7();

            num = a + (b - 1) * 7;
        } while (num > 40);

        return 1 + (num - 1) % 10;
    }
}
```

## 20210906 <font color=#009975>E</font> <font color=#009975>S</font>

### 704. 二分查找

原题链接：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

### 1.二分法

``` java
class Solution {
    public int search(int[] nums, int target) {
        int length = nums.length;

        // 在区间[left, right]内搜索target
        int left = 0, right = length - 1;
        while (left < right) {
        	// 将整个区间分为[left, mid]和[mid + 1, right]
            // 其中区间[left, mid]小于target
            // 区间[mid + 1, right]大于等于target
            int mid = (left + right) >> 1;
            if (nums[mid] < target) {
                // 当nums[mid] < target时
                // 缩小左边的区间
                left = mid + 1;
            } else {
                // 否则缩小右边的区间
                right = mid;
            }
        }
        
        // 判断nums[left]是否等于target
        // 等于target返回left，否则返回-1
        return nums[left] == target ? left : -1;
    }
}
```

## 20210907 <font color=#009975>E</font> <font color=#009975>S</font>

### 1221. 分割平衡字符串

原题链接：[1221. 分割平衡字符串](https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/)

> 在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。
>
> 给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。
>
> 注意：分割得到的每个字符串都必须是平衡字符串。
>
> 返回可以通过分割得到的平衡字符串的 最大数量 。
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s[i] = 'L' 或 'R'`
> - `s` 是一个 **平衡** 字符串

### 1.直接法

``` java
class Solution {
    public int balancedStringSplit(String s) {
        int length = s.length();

        // n表示当前L/R出现的次数
        // n作为L/R其中之一的出现次数，可以与另一个字符出现的次数相抵消
        // 所以当n为0时，就分割到一个平衡字符串
        int n = 0, res = 0;
        // first表示当前第一个出现的字符是L/R
        char first = 'L';
        // 遍历字符串
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            // 初始时n == 0，此时要确定此轮第一个出现的字符是L/R
            if (n == 0) {
                // 确定第一个出现的字符放入到first中
                first = c;
                // 当前字符L/R出现次数n加1
                n++;

                continue ;
            }

            // 如果当前字符等于第一个出现的字符first
            if (first == c) {
                // 那么次数n加1
                n++;
            } else {
                // 否则就抵消一次，次数n减1
                n--;
            }

            // 当n为0时，就分割到一个平衡字符串
            if (n == 0) {
                // 平衡字符串数量
                res++;
            }
        }

        return res;
    }
}
```

## 20210908 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 502. IPO

原题链接：[502. IPO](https://leetcode-cn.com/problems/ipo/)

> 假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。
>
> 给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。
>
> 最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。
>
> 总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。
>
> 答案保证在 32 位有符号整数范围内。
>
> 提示：
>
> 1 <= k <= 105
> 0 <= w <= 109
> n == profits.length
> n == capital.length
> 1 <= n <= 105
> 0 <= profits[i] <= 104
> 0 <= capital[i] <= 109

### 1.利用堆的贪心算法

[参考链接](https://leetcode-cn.com/problems/ipo/solution/ipo-by-leetcode-solution-89zm/)

``` java
class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int n = profits.length;
        int curr = 0;
        int[][] arr = new int[n][2];

        for (int i = 0; i < n; ++i) {
            arr[i][0] = capital[i];
            arr[i][1] = profits[i];
        }
        Arrays.sort(arr, (a, b) -> a[0] - b[0]);

        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> y - x);
        for (int i = 0; i < k; ++i) {
            while (curr < n && arr[curr][0] <= w) {
                pq.add(arr[curr][1]);
                curr++;
            }
            if (!pq.isEmpty()) {
                w += pq.poll();
            } else {
                break;
            }
        }

        return w;
    }
}
```

## 20210909 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 68. 文本左右对齐

原题链接：[68. 文本左右对齐](https://leetcode-cn.com/problems/text-justification/)

> 给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。
>
> 你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。
>
> 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。
>
> 文本的最后一行应为左对齐，且单词之间不插入额外的空格。
>
> 说明:
>
> 单词是指由非空格字符组成的字符序列。
> 每个单词的长度大于 0，小于等于 maxWidth。
> 输入单词数组 words 至少包含一个单词。

### 1.模拟

``` java
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> ans = new ArrayList<String>();
        int right = 0, n = words.length;
        while (true) {
            int left = right; // 当前行的第一个单词在 words 的位置
            int sumLen = 0; // 统计这一行单词长度之和
            // 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格
            while (right < n && sumLen + words[right].length() + right - left <= maxWidth) {
                sumLen += words[right++].length();
            }

            // 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格
            if (right == n) {
                StringBuffer sb = join(words, left, n, " ");
                sb.append(blank(maxWidth - sb.length()));
                ans.add(sb.toString());
                return ans;
            }

            int numWords = right - left;
            int numSpaces = maxWidth - sumLen;

            // 当前行只有一个单词：该单词左对齐，在行末填充剩余空格
            if (numWords == 1) {
                StringBuffer sb = new StringBuffer(words[left]);
                sb.append(blank(numSpaces));
                ans.add(sb.toString());
                continue;
            }

            // 当前行不只一个单词
            int avgSpaces = numSpaces / (numWords - 1);
            int extraSpaces = numSpaces % (numWords - 1);
            StringBuffer sb = new StringBuffer();
            sb.append(join(words, left, left + extraSpaces + 1, blank(avgSpaces + 1))); // 拼接额外加一个空格的单词
            sb.append(blank(avgSpaces));
            sb.append(join(words, left + extraSpaces + 1, right, blank(avgSpaces))); // 拼接其余单词
            ans.add(sb.toString());
        }
    }

    // blank 返回长度为 n 的由空格组成的字符串
    public String blank(int n) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < n; ++i) {
            sb.append(' ');
        }
        return sb.toString();
    }

    // join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串
    public StringBuffer join(String[] words, int left, int right, String sep) {
        StringBuffer sb = new StringBuffer(words[left]);
        for (int i = left + 1; i < right; ++i) {
            sb.append(sep);
            sb.append(words[i]);
        }
        return sb;
    }
}
```

## 20210910 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 1894. 找到需要补充粉笔的学生编号

原题链接：[1894. 找到需要补充粉笔的学生编号](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/)

> 一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。
>
> 给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。
>
> 请你返回需要 补充 粉笔的学生 编号 。
>
> **提示：**
>
> - `chalk.length == n`
> - `1 <= n <= 105`
> - `1 <= chalk[i] <= 105`
> - `1 <= k <= 109`

### 1.直接法

``` java
class Solution {
    public int chalkReplacer(int[] chalk, int k) {
        int length = chalk.length;

        // 先将所以学生需要的粉笔数累加起来
        // 注意累加结果可能会超出int范围
        // 所以这里sum用long型
        long sum = 0;
        for (int i = 0; i < length; i++) {
            sum += chalk[i];
        }

        // 然后对k取余
        // 因为是循环回答问题
        // 所以可以用取余的方式过滤掉多余的轮次
        k %= sum;

        // 剩下的k肯定小于sum
        int res = 0;
        // 从头遍历数组chalk，表示从第一个学生开始回答问题
        for (int i = 0; i < length; i++) {
            // 如果当前k小于chalk[i]
            if (k < chalk[i]) {
                // 表示当前学生i需要补充粉笔
                res = i;

                break ;
            }

            // 否则减去当前学生需要的粉笔数
            k -= chalk[i];
        }

        /
        return res;
    }
}
```

## 20210911 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 600. 不含连续1的非负整数

原题链接：[600. 不含连续1的非负整数](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/)

> 给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 **连续的1** 的个数。
>
> **说明:** 1 <= n <= 109

### 1.动态规划

[参考链接](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/bu-han-lian-xu-1de-fei-fu-zheng-shu-by-l-9l86/)

``` java
class Solution {
    public int findIntegers(int n) {
        int[] dp = new int[31];
        dp[0] = dp[1] = 1;
        for (int i = 2; i < 31; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        int pre = 0, res = 0;
        for (int i = 29; i >= 0; --i) {
            int val = 1 << i;
            if ((n & val) != 0) {
                n -= val;
                res += dp[i + 1];
                if (pre == 1) {
                    break;
                }
                pre = 1;
            } else {
                pre = 0;
            }

            if (i == 0) {
                ++res;
            }
        }

        return res;
    }
}
```

## 20210912 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 678. 有效的括号字符串

原题链接：[678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/)

> 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
>
> 任何左括号 ( 必须有相应的右括号 )。
> 任何右括号 ) 必须有相应的左括号 ( 。
> 左括号 ( 必须在对应的右括号之前 )。
> * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
> 一个空字符串也被视为有效字符串。
>
> **注意:**
>
> 1. 字符串大小将在 [1，100] 范围内。

### 1.贪心

[参考题解](https://leetcode-cn.com/problems/valid-parenthesis-string/solution/you-xiao-de-gua-hao-zi-fu-chuan-by-leetc-osi3/)

``` java
class Solution {
    public boolean checkValidString(String s) {
        int length = s.length();

        // min表示未匹配到的括号数的最小值
        // max表示未匹配到的括号数的最大值
        int min = 0, max = 0;
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            if (c == '(') {
                // 当前字符为'('时，最小值和最大值都加1
                min++;
                max++;
            } else if (c == ')') {
                // 当前字符为')'时，最小值和最大值都减1

                // 其中min从min - 1和0中取最大值
                // 是因为如果有'*'存在的话
                // 没有被匹配上的'('还可以与'*'匹配
                min = Math.max(min - 1, 0);
                max--;
                // max < 0表示没有能与')'匹配的字符了
                if (max < 0) {
                    // 所以这里返回false
                    return false;
                }
            } else {
                // 当前字符为'*'时
                // min从min - 1和0中取最大值
                // 表示匹配到了一个'('
                min = Math.max(min - 1, 0);
                // max加又为后面的')'增加了一次匹配
                max++;
            }
        }

        // 当min == 0时表示所有左右括号都满足匹配了
        return min == 0;
    }
}
```

## 20210913 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 447. 回旋镖的数量

原题链接：[447. 回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)

> 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。
>
> 返回平面上所有回旋镖的数量。
>
> 提示：
>
> n == points.length
> 1 <= n <= 500
> points[i].length == 2
> -104 <= xi, yi <= 104
> 所有点都 互不相同

### 1.枚举 + 哈希

[参考链接](https://leetcode-cn.com/problems/number-of-boomerangs/solution/hui-xuan-biao-de-shu-liang-by-leetcode-s-lft5/)

``` java
class Solution {
    public int numberOfBoomerangs(int[][] points) {
        int ans = 0;
        for (int[] p : points) {
            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
            for (int[] q : points) {
                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);
                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);
            }
            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {
                int m = entry.getValue();
                ans += m * (m - 1);
            }
        }
        return ans;
    }
}
```

## 20210914 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 524. 通过删除字母匹配到字典里最长单词

原题链接：[524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

> 给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。
>
> 如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。
>
> 提示：
>
> 1 <= s.length <= 1000
> 1 <= dictionary.length <= 1000
> 1 <= dictionary[i].length <= 1000
> s 和 dictionary[i] 仅由小写英文字母组成

### 1.双指针

``` java
class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        String res = "";
        // 挨个遍历字符串数组 dictionary
        for (String str : dictionary) {
            int i = 0, j = 0;
            // 然后和字符串数组s的每个字符比较
            // 看看字符串str里面的所有字符是不是在s中都有
            // 利用双指针能保证字符出现的顺序一致的
            while (i < str.length() && j < s.length()) {
                if (str.charAt(i) == s.charAt(j)) {
                    i++;
                }

                j++;
            }

            // i == str.length()表示字符串str里面的所有字符在s中都有
            if (i == str.length()) {
                // 然后和res比较长度
                // res的长度小于str或者相等且字典序小
                // 则更新结果
                if (res.length() < str.length() || (res.length() == str.length() && str.compareTo(res) < 0)) {
                    res = str;
                }
            }
        }

        return res;
    }
}
```

## 20210915 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 162. 寻找峰值

原题链接：[162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

> 峰值元素是指其值严格大于左右相邻值的元素。
>
> 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
>
> 你可以假设 nums[-1] = nums[n] = -∞ 。
>
> 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
>
> 提示：
>
> 1 <= nums.length <= 1000
> -231 <= nums[i] <= 231 - 1
> 对于所有有效的 i 都有 nums[i] != nums[i + 1]

### 1.直接法

``` java
class Solution {
    public int findPeakElement(int[] nums) {
        int len = nums.length;
        
        int res = 0;
        // 其实就是要找一个大于左右相邻值的元素
        // 遍历数组每个元素和左右相邻元素比较一下即可
        for (int i = 0; i < len; i++) {
            // 处理第一个元素和最后
            int left = i == 0 ? Integer.MIN_VALUE : nums[i - 1];
            int right = i == len - 1 ? Integer.MIN_VALUE : nums[i + 1];

            if (left < nums[i] && nums[i] > right) {
                res = i;

                break ;
            }
        }

        return res;
    }
}
```

## 20210916 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 212. 单词搜索 II

原题链接：[212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

> 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。
>
> 单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。
>
> 提示：
>
> m == board.length
> n == board[i].length
> 1 <= m, n <= 12
> board[i][j] 是一个小写英文字母
> 1 <= words.length <= 3 * 104
> 1 <= words[i].length <= 10
> words[i] 由小写英文字母组成
> words 中的所有字符串互不相同

### 1.回溯 + 字典树

[原题链接](https://leetcode-cn.com/problems/word-search-ii/solution/dan-ci-sou-suo-ii-by-leetcode-solution-7494/)

``` java
class Solution {
    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    public List<String> findWords(char[][] board, String[] words) {
        Trie trie = new Trie();
        for (String word : words) {
            trie.insert(word);
        }

        Set<String> ans = new HashSet<String>();
        for (int i = 0; i < board.length; ++i) {
            for (int j = 0; j < board[0].length; ++j) {
                dfs(board, trie, i, j, ans);
            }
        }

        return new ArrayList<String>(ans);
    }

    public void dfs(char[][] board, Trie now, int i1, int j1, Set<String> ans) {
        if (!now.children.containsKey(board[i1][j1])) {
            return;
        }
        char ch = board[i1][j1];
        now = now.children.get(ch);
        if (!"".equals(now.word)) {
            ans.add(now.word);
        }

        board[i1][j1] = '#';
        for (int[] dir : dirs) {
            int i2 = i1 + dir[0], j2 = j1 + dir[1];
            if (i2 >= 0 && i2 < board.length && j2 >= 0 && j2 < board[0].length) {
                dfs(board, now, i2, j2, ans);
            }
        }
        board[i1][j1] = ch;
    }
}

class Trie {
    String word;
    Map<Character, Trie> children;
    boolean isWord;

    public Trie() {
        this.word = "";
        this.children = new HashMap<Character, Trie>();
    }

    public void insert(String word) {
        Trie cur = this;
        for (int i = 0; i < word.length(); ++i) {
            char c = word.charAt(i);
            if (!cur.children.containsKey(c)) {
                cur.children.put(c, new Trie());
            }
            cur = cur.children.get(c);
        }
        cur.word = word;
    }
}
```

## 20210917 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 36. 有效的数独

原题链接：[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

> 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
>
> 数字 1-9 在每一行只能出现一次。
> 数字 1-9 在每一列只能出现一次。
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
> 数独部分空格内已填入了数字，空白格用 '.' 表示。
>
> 注意：
>
> 一个有效的数独（部分已被填充）不一定是可解的。
> 只需要根据以上规则，验证已经填入的数字是否有效即可。
>
> **提示：**
>
> - `board.length == 9`
> - `board[i].length == 9`
> - `board[i][j]` 是一位数字或者 `'.'`

### 1.直接法

[参考链接](https://leetcode-cn.com/problems/valid-sudoku/solution/you-xiao-de-shu-du-by-leetcode-solution-50m6/)

``` java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] rows = new int[9][9];
        int[][] columns = new int[9][9];
        int[][][] subboxes = new int[3][3][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;
                    rows[i][index]++;
                    columns[j][index]++;
                    subboxes[i / 3][j / 3][index]++;
                    if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```

## 20210918 <font color=#009975>E</font> <font color=#ed7336>R</font>

### 292. Nim 游戏

原题链接：[292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/)

> 你和你的朋友，两个人一起玩 Nim 游戏：
>
> 桌子上有一堆石头。
> 你们轮流进行自己的回合，你作为先手。
> 每一回合，轮到的人拿掉 1 - 3 块石头。
> 拿掉最后一块石头的人就是获胜者。
> 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。
>
> **提示：**
>
> - `1 <= n <= 231 - 1`

### 1.数学推理

[参考题解](https://leetcode-cn.com/problems/nim-game/solution/nim-you-xi-by-leetcode-solution-95g8/)

``` java
class Solution {
    public boolean canWinNim(int n) {
        return n % 4 != 0;
    }
}
```

## 20210919 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 650. 只有两个键的键盘

原题链接：[650. 只有两个键的键盘](https://leetcode-cn.com/problems/2-keys-keyboard/)

> 最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：
>
> Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。
> Paste（粘贴）：粘贴 上一次 复制的字符。
> 给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。
>
> **提示：**
>
> - `1 <= n <= 1000`

### 1.动态规划

[参考题解](https://leetcode-cn.com/problems/2-keys-keyboard/solution/zhi-you-liang-ge-jian-de-jian-pan-by-lee-ussa/)

``` java
class Solution {
    public int minSteps(int n) {
        int[] f = new int[n + 1];
        for (int i = 2; i <= n; ++i) {
            f[i] = Integer.MAX_VALUE;
            for (int j = 1; j * j <= i; ++j) {
                if (i % j == 0) {
                    f[i] = Math.min(f[i], f[j] + i / j);
                    f[i] = Math.min(f[i], f[i / j] + j);
                }
            }
        }
        return f[n];
    }
}
```

## 20210920 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 673. 最长递增子序列的个数

原题链接：[673. 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

> 给定一个未排序的整数数组，找到最长递增子序列的个数。
>
> **注意:** 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。

### 1.动态规划

[参考链接](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/solution/zui-chang-di-zeng-zi-xu-lie-de-ge-shu-by-w12f/)

``` java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        List<List<Integer>> d = new ArrayList<List<Integer>>();
        List<List<Integer>> cnt = new ArrayList<List<Integer>>();
        for (int v : nums) {
            int i = binarySearch1(d.size(), d, v);
            int c = 1;
            if (i > 0) {
                int k = binarySearch2(d.get(i - 1).size(), d.get(i - 1), v);
                c = cnt.get(i - 1).get(cnt.get(i - 1).size() - 1) - cnt.get(i - 1).get(k);
            }
            if (i == d.size()) {
                List<Integer> dList = new ArrayList<Integer>();
                dList.add(v);
                d.add(dList);
                List<Integer> cntList = new ArrayList<Integer>();
                cntList.add(0);
                cntList.add(c);
                cnt.add(cntList);
            } else {
                d.get(i).add(v);
                int cntSize = cnt.get(i).size();
                cnt.get(i).add(cnt.get(i).get(cntSize - 1) + c);
            }
        }

        int size1 = cnt.size(), size2 = cnt.get(size1 - 1).size();
        return cnt.get(size1 - 1).get(size2 - 1);
    }

    public int binarySearch1(int n, List<List<Integer>> d, int target) {
        int l = 0, r = n;
        while (l < r) {
            int mid = (l + r) / 2;
            List<Integer> list = d.get(mid);
            if (list.get(list.size() - 1) >= target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }

    public int binarySearch2(int n, List<Integer> list, int target) {
        int l = 0, r = n;
        while (l < r) {
            int mid = (l + r) / 2;
            if (list.get(mid) < target) {
                r = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
}
```

## 20210921 <font color=#009975>E</font> <font color=#009975>S</font>

### 58. 最后一个单词的长度

原题链接：[58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)

> 给你一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。
>
> **单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串。
>
> **提示：**
>
> - `1 <= s.length <= 104`
> - `s` 仅有英文字母和空格 `' '` 组成
> - `s` 中至少存在一个单词

### 1.双指针

``` java
class Solution {
    public int lengthOfLastWord(String s) {
        int length = s.length();

        // 定义双指针st和end
        int st = length - 1, end = length;
        // flag用来标记是否没有遇到非空格字符
        boolean flag = true;
        // 因为这里只需要统计最后一个单词的长度
        // 所以从后往前遍历，找到最后一个单词即可
        for (int i = length - 1; i >= 0; i--) {
            char c = s.charAt(i);
            // 当前为空格时
            if (c == ' ') {
                // 如果当前还没有遇到非空格字符
                if (flag) {
                    // 那么把end的位置调整为当前位置
                    end = i;

                    continue ;
                } else {
                    // 否则最后一个单词已经找到了，直接break
                    break ;
                }
            }

            // 已经遇到了第一个非空格字符，flag标记为false
            flag = false;
            // st调整为当前位置
            st = i;
        }

        // 计算最后一个单词的长度
        return end - st;
    }
}
```

## 20210922 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 725. 分隔链表

原题链接：[725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)

> 给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。
>
> 每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。
>
> 这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。
>
> 返回一个由上述 k 部分组成的数组。
>
> **提示：**
>
> - 链表中节点的数目在范围 `[0, 1000]`
> - `0 <= Node.val <= 1000`
> - `1 <= k <= 50`

### 1.分组

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode[] splitListToParts(ListNode head, int k) {
        int length = 0;
        ListNode node = head;
        // 先统计一下链表的长度
        while (node != null) {
            length++;
            node = node.next;
        }

        // 分隔后每个部分的长度
        int[] lens = new int[k];
        // 因为任意两部分的长度差距不能超过1
        // 所以将节点先均分给每个部分
        int base = length / k;
        // 余数为多出来的部分，再加个前plus个部分
        int plus = length % k;
        // 然后再计算分隔出来的每个部分的长度
        for (int i = 0; i < k; i++) {
            // 每个部分都能分到平均的个数
            lens[i] = base;
            if (i < plus) {
                // 多出来的部分给前plus个部分每个部分均分一个
                lens[i]++;
            }
        }

        node = head;
        ListNode[] res = new ListNode[k];
        // 按每个部分计算出来的长度来分隔链表
        for (int i = 0; i < k; i++) {
            int len = lens[i];
            // 取当前链表第一个为当前部分的头结点
            ListNode h = node;
            ListNode n = h;

            // 按当前部分所需长度分隔
            for (int j = 0; j < len; j++) {
                // 先把next节点拿出来
                ListNode next = node.next;
                // 头结点已经在h中了，所以从j > 0
                // 也就是当前第二个节点开始
                if (j > 0) {
                    // 将节点放入当前部分的链表中
                    n.next = node;
                    // 跳到下一个节点
                    n = n.next;
                }

                // 将当前节点和后面的节点断开
                node.next = null;

                // 跳到下一个节点
                node = next;
            }

            // 将当前部分头结点赋值到res[i]中
            res[i] = h;
        }

        return res;
    }
}
```

## 20210923 <font color=#009975>E</font> <font color=#009975>S</font>

### 326. 3的幂

原题链接：[326. 3的幂](https://leetcode-cn.com/problems/power-of-three/)

> 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
>
> 整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x

### 1.迭代法

``` java
class Solution {
    public boolean isPowerOfThree(int n) {
        while (n >= 3 && n % 3 == 0) {
            n /= 3;
        }

        if (n == 1) {
            return true;
        }

        return false;
    }
}
```

## 20210924 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 430. 扁平化多级双向链表

原题链接：[430. 扁平化多级双向链表](https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/)

> 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。
>
> 给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。
>
> **提示：**
>
> - 节点数目不超过 1000
> - `1 <= Node.val <= 10^5`

### 1.递归

``` java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node prev;
    public Node next;
    public Node child;
};
*/

class Solution {
    public Node flatten(Node head) {
        if (head == null) {
            return head;
        }

        helper(head);
        
        return head;
    }

    /**
     * 递归遍历子链表节点
     * 并返回子链表的最后一个节点
     */
    private Node helper(Node head) {
        Node node = head;
        // pre用来保存最后一个节点
        Node pre = node;
        while (node != null) {
            Node next = node.next;

            // 子链表不为空就递归遍历子链表
            if (node.child != null) {
                Node child = node.child;
                node.child = null;

                // tail为子链表的最后一个节点
                Node tail = helper(child);

                // 子链表头结点链到当前node节点后面
                node.next = child;
                child.prev = node;

                // next不为空
                if (next != null) {
                    // 就将子链表尾结点和当前的next节点相连
                    tail.next = next;
                    next.prev = tail;
                } else {
                    // 如果当前next为空
                    // 此时当前链表的尾结点为子链表的尾结点
                    // 所以这里直接返回tail节点即可
                    return tail;
                }
            }

            pre = node;
            node = next;
        }

        return pre;
    }
}
```

## 20210925 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 583. 两个字符串的删除操作

原题链接：[583. 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

> 给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。
>
> **提示：**
>
> 1. 给定单词的长度不超过500。
> 2. 给定单词中的字符只含有小写字母。

### 1.动态规划

[参考题解：最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/solution/zui-chang-gong-gong-zi-xu-lie-by-leetcod-y7u0/)

``` java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length(), n = word2.length();
        // dp[i][j] 表示word1[0:i]和word2[0:j]的最长公共子序列的长度
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            char c1 = word1.charAt(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = word2.charAt(j - 1);
                if (c1 == c2) {
                    // 当word1[i]和word2[j]相等时
                    // dp[i - 1][j - 1] + 1即可
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 否则取dp[i - 1][j]和dp[i][j - 1]中的最大值
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        int l = dp[m][n];
        
        return m - l + n - l;
    }
}
```

## 20210926 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 371. 两整数之和

原题链接：[371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)

> 给你两个整数 `a` 和 `b` ，**不使用** 运算符 `+` 和 `-` ，计算并返回两整数之和。
>
> **提示：**
>
> - `-1000 <= a, b <= 1000`

### 1.位运算

``` java
class Solution {
    public int getSum(int a, int b) {
        if (a == 0) {
            return b;
        }

        if (b == 0) {
            return a;
        }

        // low保存二进制相加时不需要进位的低位
        // up保存二进制相加时的进位
        int low, up;
        while (true) {
            // 异或运算可以获得相加后不需要进位的结果
            low = a ^ b;
            // 与运算可以获得相加后需要进位的结果
            up = a & b;

            // 如果运算之后不需要进位了
            // 就直接break退出循环
            if (up == 0) {
                break ;
            }

            // 低位low赋值给a继续相加
            a = low;
            // 进位up向左移动一位表示进位
            b = up << 1;
        }

        // 直接返回low表示相加的结果
        return low;
    }
}
```

## 20210927 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 639. 解码方法 II

原题链接：[639. 解码方法 II](https://leetcode-cn.com/problems/decode-ways-ii/)

> 一条包含字母 A-Z 的消息通过以下的方式进行了编码：
>
> 'A' -> 1
> 'B' -> 2
> ...
> 'Z' -> 26
> 要 解码 一条已编码的消息，所有的数字都必须分组，然后按原来的编码方案反向映射回字母（可能存在多种方式）。例如，"11106" 可以映射为：
>
> "AAJF" 对应分组 (1 1 10 6)
> "KJF" 对应分组 (11 10 6)
> 注意，像 (1 11 06) 这样的分组是无效的，因为 "06" 不可以映射为 'F' ，因为 "6" 与 "06" 不同。
>
> 除了 上面描述的数字字母映射方案，编码消息中可能包含 '*' 字符，可以表示从 '1' 到 '9' 的任一数字（不包括 '0'）。例如，编码字符串 "1*" 可以表示 "11"、"12"、"13"、"14"、"15"、"16"、"17"、"18" 或 "19" 中的任意一条消息。对 "1*" 进行解码，相当于解码该字符串可以表示的任何编码消息。
>
> 给你一个字符串 s ，由数字和 '*' 字符组成，返回 解码 该字符串的方法 数目 。
>
> 由于答案数目可能非常大，返回对 109 + 7 取余 的结果。
>
> **提示：**
>
> - `1 <= s.length <= 105`
> - `s[i]` 是 `0 - 9` 中的一位数字或字符 `'*'`

### 1.动态规划

[参考链接](https://leetcode-cn.com/problems/decode-ways-ii/solution/jie-ma-fang-fa-ii-by-leetcode-solution-23af/)

``` java
class Solution {
    static final int MOD = 1000000007;

    public int numDecodings(String s) {
        int n = s.length();
        // a = f[i-2], b = f[i-1], c = f[i]
        long a = 0, b = 1, c = 0;
        for (int i = 1; i <= n; ++i) {
            c = b * check1digit(s.charAt(i - 1)) % MOD;
            if (i > 1) {
                c = (c + a * check2digits(s.charAt(i - 2), s.charAt(i - 1))) % MOD;
            }
            a = b;
            b = c;
        }
        return (int) c;
    }

    public int check1digit(char ch) {
        if (ch == '0') {
            return 0;
        }
        return ch == '*' ? 9 : 1;
    }

    public int check2digits(char c0, char c1) {
        if (c0 == '*' && c1 == '*') {
            return 15;
        }
        if (c0 == '*') {
            return c1 <= '6' ? 2 : 1;
        }
        if (c1 == '*') {
            if (c0 == '1') {
                return 9;
            }
            if (c0 == '2') {
                return 6;
            }
            return 0;
        }
        return (c0 != '0' && (c0 - '0') * 10 + (c1 - '0') <= 26) ? 1 : 0;
    }
}
```

