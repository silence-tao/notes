# 2021年7月力扣每日1题

## 20210701 <font color=#009975>E</font> <font color=#009975>S</font>

### LCP 07. 传递信息

原题链接：[LCP 07. 传递信息](https://leetcode-cn.com/problems/chuan-di-xin-xi/)

> 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
>
> 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
> 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
> 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
> 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
>
> 示例 1：
>
> 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
>
> 输出：3
>
> 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。
>
> 示例 2：
>
> 输入：n = 3, relation = [[0,2],[2,1]], k = 2
>
> 输出：0
>
> 解释：信息不能从小 A 处经过 2 轮传递到编号 2

### 1.递归

``` java
class Solution {
    int res = 0;
    public int numWays(int n, int[][] relation, int k) {
        // 用map保存玩家与能传递信息玩家的对应关系，一对多
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < relation.length; i++) {
            List<Integer> list = map.get(relation[i][0]);
            if (list == null) {
                list = new ArrayList<>();
                map.put(relation[i][0], list);
            }

            list.add(relation[i][1]);
        }

        helper(0, n, map, 0, k);

        return res;
    }

    // 递归判断满足条件的方案
    private void helper(int pos, int n, Map<Integer, List<Integer>> map, int times, int k) {
        // 次数满足条件
        if (times == k) {
            // 已传递到最后一个玩家
            if (pos == n - 1) {
                // 记录次数
                res++;
            }

            return ;
        }

        List<Integer> list = map.get(pos);
        if (list == null || list.size() == 0) {
            return ;
        }

        for (Integer next : list) {
            // 按照当前能传递到的下一个玩家来递归
            helper(next, n, map, times + 1, k);
        }
    }
}
```

## 20210702 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 1833. 雪糕的最大数量

原题链接：[1833. 雪糕的最大数量](https://leetcode-cn.com/problems/maximum-ice-cream-bars/)

> 夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。
>
> 商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。
>
> 给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。
>
> 注意：Tony 可以按任意顺序购买雪糕。

### 1.排序法

``` java
class Solution {
    public int maxIceCream(int[] costs, int coins) {
        // 先对雪糕的定价按从小到大排序
        Arrays.sort(costs);

        int res = 0;
        // 再按价格从小到大开始购买，直到剩余现金量不够时为止
        for (int i = 0; i < costs.length; i++) {
            if (costs[i] <= coins) {
                // 扣除当前购买雪糕的价钱
                coins -= costs[i];
				// 计数
                res++;
            }
        }

        return res;
    }
}
```

## 20210703 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 451. 根据字符出现频率排序

原题链接：[451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)

> 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。

### 1.哈希计数

``` java
class Solution {
    public String frequencySort(String s) {
        // 定义map用来保存字符与出现频率的映射关系
        Map<Character, Integer> map = new HashMap<>();
        // 将出现次数放入map中
        for (char c : s.toCharArray()) {
            map.put(c, map.getOrDefault(c, 0) + 1);
        }

        // 将映射关系放入二维数组array中
        int[][] array = new int[map.size()][2];
        int pos = 0;
        for (Map.Entry<Character, Integer> entry : map.entrySet()) {
            array[pos][0] = entry.getValue();
            array[pos++][1] = entry.getKey();
        }

        // 根据字符出现次数排序
        Arrays.sort(array, (o1, o2) -> o2[0] - o1[0]);
        // 将字符按出现次数输出到StringBuilder对象中
        StringBuilder builder = new StringBuilder();
        for (int[] arr : array) {
            for (int i = 0; i < arr[0]; i++) {
                builder.append((char) arr[1]);
            }
        }

        return builder.toString();
    }
}
```

## 20210704 <font color=#009975>E</font> <font color=#ed7336>R</font>

### 645. 错误的集合

原题链接：[645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

> 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。
>
> 给定一个数组 nums 代表了集合 S 发生错误后的结果。
>
> 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

### 1.计数

[参考题解](https://leetcode-cn.com/problems/set-mismatch/solution/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/)

``` java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int length = nums.length;
        // 用count统计每一个数字出现的次数
        int[] count = new int[length + 1];
        for (int num : nums) {
            count[num]++;
        }
        
        int[] res = new int[2];
        // 然后从1-n出现了两次的为重复的数字
        // 出现0次的为丢失的数字
        for (int i = 1; i <= length; i++) {
            if (count[i] == 2) {
                res[0] = i;
            }

            if (count[i] == 0) {
                res[1] = i;
            }
        }

        return res;
    }
}
```

