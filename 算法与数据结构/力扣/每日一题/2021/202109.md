# 2021年9月力扣每日1题

## 20210901 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 165. 比较版本号

原题链接：[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

> 给你两个版本号 version1 和 version2 ，请你比较它们。
>
> 版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
>
> 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。
>
> 返回规则如下：
>
> 如果 version1 > version2 返回 1，
> 如果 version1 < version2 返回 -1，
> 除此之外返回 0。
>
> 提示：
>
> 1 <= version1.length, version2.length <= 500
> version1 和 version2 仅包含数字和 '.'
> version1 和 version2 都是 有效版本号
> version1 和 version2 的所有修订号都可以存储在 32 位整数 中

### 1.直接法

``` java
class Solution {
    public int compareVersion(String version1, String version2) {
        // 先将两个版本号分割成字符串数组
        String[] arr1 = version1.split("\\.");
        String[] arr2 = version2.split("\\.");

        int len1 = arr1.length, len2 = arr2.length;
        // 然后按位比较每一位的大小
        for (int i = 0; i < Math.max(len1, len2); i++) {
            // 将每一位修订号转成整型
            // 如果超出数组范围则转成0
            int ver1 = i < len1 ? Integer.parseInt(arr1[i]) : 0;
            int ver2 = i < len2 ? Integer.parseInt(arr2[i]) : 0;

            // 比较两个修订号是否相等
            if (ver1 != ver2) {
                // 不相等ver1 > ver2返回1
                // 否则返回-1
                return ver1 > ver2 ? 1 : -1;
            }
        }

        // 到了这里说明所有的修订号都相等
        // 即两个版本号相等，返回0
        return 0;
    }
}
```

## 20210902 <font color=#009975>E</font> <font color=#009975>S</font>

### 剑指 Offer 22. 链表中倒数第k个节点

原题链接：[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
>
> 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

### 1.双指针

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        int idx = 1;
        ListNode first = head;
        // 想让第一个指针跳到第k个节点
        while (idx++ < k) {
            first = first.next;
        }

        // 然后再让第一个指针从头开始
        ListNode second = head;
        // 两个指针同时前进
        // 当第一个指针到达最后一个节点时
        // 第二个指针刚好到倒数第k个节点的位置
        while (first.next != null) {
            first = first.next;
            second = second.next;
        }

        return second;
    }
}
```

## 20210903 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 面试题 17.14. 最小K个数

原题链接：[面试题 17.14. 最小K个数](https://leetcode-cn.com/problems/smallest-k-lcci/)

> 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
>
> **提示：**
>
> - `0 <= len(arr) <= 100000`
> - `0 <= k <= min(100000, len(arr))`

### 1.排序

``` java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        Arrays.sort(arr);

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = arr[i];
        }

        return res;
    }
}
```

## 20210904 <font color=#009975>E</font> <font color=#009975>S</font>

### 剑指 Offer 10- I. 斐波那契数列

原题链接：[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> **提示：**
>
> - `0 <= n <= 100`

### 1.动态规划

``` java
class Solution {
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }

        int INF = 1000000007;

        // 斐波那契数列其实只需要前两个数的状态
        // 所以这里用first表示F(N - 2)
        // second表示F(N - 1)
        int first = 0, second = 1;
        for (int i = 2; i <= n; i++) {
            // t表示F(N)
            int t = (first + second) % INF;

            // 为下一轮更新F(N - 2)
            // 即现在的F(N - 1)
            first = second;
            // 为下一轮更新F(N - 1)
            // 即现在的F(N)
            second = t;
        }

        // 所以当循环结束时
        // second
        return second;
    }
}
```

## 20210905 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 470. 用 Rand7() 实现 Rand10()

原题链接：[470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

> 已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。
>
> 不要使用系统的 Math.random() 方法。
>
> **提示:**
>
> 1. `rand7` 已定义。
> 2. 传入参数: `n` 表示 `rand10` 的调用次数。

### 1.拒绝采样

[参考题解](https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/)

``` java
/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */
class Solution extends SolBase {
    public int rand10() {
        int a, b, num;
        do {
            a = rand7();
            b = rand7();

            num = a + (b - 1) * 7;
        } while (num > 40);

        return 1 + (num - 1) % 10;
    }
}
```

## 20210906 <font color=#009975>E</font> <font color=#009975>S</font>

### 704. 二分查找

原题链接：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

### 1.二分法

``` java
class Solution {
    public int search(int[] nums, int target) {
        int length = nums.length;

        // 在区间[left, right]内搜索target
        int left = 0, right = length - 1;
        while (left < right) {
        	// 将整个区间分为[left, mid]和[mid + 1, right]
            // 其中区间[left, mid]小于target
            // 区间[mid + 1, right]大于等于target
            int mid = (left + right) >> 1;
            if (nums[mid] < target) {
                // 当nums[mid] < target时
                // 缩小左边的区间
                left = mid + 1;
            } else {
                // 否则缩小右边的区间
                right = mid;
            }
        }
        
        // 判断nums[left]是否等于target
        // 等于target返回left，否则返回-1
        return nums[left] == target ? left : -1;
    }
}
```

## 20210907 <font color=#009975>E</font> <font color=#009975>S</font>

### 1221. 分割平衡字符串

原题链接：[1221. 分割平衡字符串](https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/)

> 在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。
>
> 给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。
>
> 注意：分割得到的每个字符串都必须是平衡字符串。
>
> 返回可以通过分割得到的平衡字符串的 最大数量 。
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s[i] = 'L' 或 'R'`
> - `s` 是一个 **平衡** 字符串

### 1.直接法

``` java
class Solution {
    public int balancedStringSplit(String s) {
        int length = s.length();

        // n表示当前L/R出现的次数
        // n作为L/R其中之一的出现次数，可以与另一个字符出现的次数相抵消
        // 所以当n为0时，就分割到一个平衡字符串
        int n = 0, res = 0;
        // first表示当前第一个出现的字符是L/R
        char first = 'L';
        // 遍历字符串
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            // 初始时n == 0，此时要确定此轮第一个出现的字符是L/R
            if (n == 0) {
                // 确定第一个出现的字符放入到first中
                first = c;
                // 当前字符L/R出现次数n加1
                n++;

                continue ;
            }

            // 如果当前字符等于第一个出现的字符first
            if (first == c) {
                // 那么次数n加1
                n++;
            } else {
                // 否则就抵消一次，次数n减1
                n--;
            }

            // 当n为0时，就分割到一个平衡字符串
            if (n == 0) {
                // 平衡字符串数量
                res++;
            }
        }

        return res;
    }
}
```

## 20210908 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 502. IPO

原题链接：[502. IPO](https://leetcode-cn.com/problems/ipo/)

> 假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。
>
> 给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。
>
> 最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。
>
> 总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。
>
> 答案保证在 32 位有符号整数范围内。
>
> 提示：
>
> 1 <= k <= 105
> 0 <= w <= 109
> n == profits.length
> n == capital.length
> 1 <= n <= 105
> 0 <= profits[i] <= 104
> 0 <= capital[i] <= 109

### 1.利用堆的贪心算法

[参考链接](https://leetcode-cn.com/problems/ipo/solution/ipo-by-leetcode-solution-89zm/)

``` java
class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int n = profits.length;
        int curr = 0;
        int[][] arr = new int[n][2];

        for (int i = 0; i < n; ++i) {
            arr[i][0] = capital[i];
            arr[i][1] = profits[i];
        }
        Arrays.sort(arr, (a, b) -> a[0] - b[0]);

        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> y - x);
        for (int i = 0; i < k; ++i) {
            while (curr < n && arr[curr][0] <= w) {
                pq.add(arr[curr][1]);
                curr++;
            }
            if (!pq.isEmpty()) {
                w += pq.poll();
            } else {
                break;
            }
        }

        return w;
    }
}
```

## 20210909 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 68. 文本左右对齐

原题链接：[68. 文本左右对齐](https://leetcode-cn.com/problems/text-justification/)

> 给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。
>
> 你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。
>
> 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。
>
> 文本的最后一行应为左对齐，且单词之间不插入额外的空格。
>
> 说明:
>
> 单词是指由非空格字符组成的字符序列。
> 每个单词的长度大于 0，小于等于 maxWidth。
> 输入单词数组 words 至少包含一个单词。

### 1.模拟

``` java
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> ans = new ArrayList<String>();
        int right = 0, n = words.length;
        while (true) {
            int left = right; // 当前行的第一个单词在 words 的位置
            int sumLen = 0; // 统计这一行单词长度之和
            // 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格
            while (right < n && sumLen + words[right].length() + right - left <= maxWidth) {
                sumLen += words[right++].length();
            }

            // 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格
            if (right == n) {
                StringBuffer sb = join(words, left, n, " ");
                sb.append(blank(maxWidth - sb.length()));
                ans.add(sb.toString());
                return ans;
            }

            int numWords = right - left;
            int numSpaces = maxWidth - sumLen;

            // 当前行只有一个单词：该单词左对齐，在行末填充剩余空格
            if (numWords == 1) {
                StringBuffer sb = new StringBuffer(words[left]);
                sb.append(blank(numSpaces));
                ans.add(sb.toString());
                continue;
            }

            // 当前行不只一个单词
            int avgSpaces = numSpaces / (numWords - 1);
            int extraSpaces = numSpaces % (numWords - 1);
            StringBuffer sb = new StringBuffer();
            sb.append(join(words, left, left + extraSpaces + 1, blank(avgSpaces + 1))); // 拼接额外加一个空格的单词
            sb.append(blank(avgSpaces));
            sb.append(join(words, left + extraSpaces + 1, right, blank(avgSpaces))); // 拼接其余单词
            ans.add(sb.toString());
        }
    }

    // blank 返回长度为 n 的由空格组成的字符串
    public String blank(int n) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < n; ++i) {
            sb.append(' ');
        }
        return sb.toString();
    }

    // join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串
    public StringBuffer join(String[] words, int left, int right, String sep) {
        StringBuffer sb = new StringBuffer(words[left]);
        for (int i = left + 1; i < right; ++i) {
            sb.append(sep);
            sb.append(words[i]);
        }
        return sb;
    }
}
```

## 20210910 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 1894. 找到需要补充粉笔的学生编号

原题链接：[1894. 找到需要补充粉笔的学生编号](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/)

> 一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。
>
> 给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。
>
> 请你返回需要 补充 粉笔的学生 编号 。
>
> **提示：**
>
> - `chalk.length == n`
> - `1 <= n <= 105`
> - `1 <= chalk[i] <= 105`
> - `1 <= k <= 109`

### 1.直接法

``` java
class Solution {
    public int chalkReplacer(int[] chalk, int k) {
        int length = chalk.length;

        // 先将所以学生需要的粉笔数累加起来
        // 注意累加结果可能会超出int范围
        // 所以这里sum用long型
        long sum = 0;
        for (int i = 0; i < length; i++) {
            sum += chalk[i];
        }

        // 然后对k取余
        // 因为是循环回答问题
        // 所以可以用取余的方式过滤掉多余的轮次
        k %= sum;

        // 剩下的k肯定小于sum
        int res = 0;
        // 从头遍历数组chalk，表示从第一个学生开始回答问题
        for (int i = 0; i < length; i++) {
            // 如果当前k小于chalk[i]
            if (k < chalk[i]) {
                // 表示当前学生i需要补充粉笔
                res = i;

                break ;
            }

            // 否则减去当前学生需要的粉笔数
            k -= chalk[i];
        }

        /
        return res;
    }
}
```

