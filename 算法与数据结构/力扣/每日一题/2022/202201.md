# 2022年1月力扣每日1题

## 20220101 <font color=#009975>E</font> <font color=#009975>S</font>

### 2022. 将一维数组转变成二维数组

原题链接：[2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)

> 给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。
>
> original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。
>
> 请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。
>
> 提示：
>
> 1 <= original.length <= 5 * 104
> 1 <= original[i] <= 105
> 1 <= m, n <= 4 * 104

### 1.迭代法

``` java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        if (original.length != m * n) {
            return new int[0][0];
        }

        int[][] resArr = new int[m][n];
        // 遍历一维数组然后放入二维
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                resArr[i][j] = original[i * n + j];
            }
        }

        return resArr;
    }
}
```

## 20220102 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 390. 消除游戏

原题链接：[390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

> 列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：
>
> 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
> 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
> 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
> 给你整数 n ，返回 arr 最后剩下的数字。
>
> **提示：**
>
> - `1 <= n <= 109`

### 1.等差数列模拟

[参考题解](https://leetcode-cn.com/problems/elimination-game/solution/xiao-chu-you-xi-by-leetcode-solution-ydpb/)

``` java
class Solution {
    public int lastRemaining(int n) {
        int a1 = 1;
        int k = 0, cnt = n, step = 1;

        while (cnt > 1) {
            if (k % 2 == 0) { // 正向
                a1 = a1 + step;
            } else { // 反向
                a1 = (cnt % 2 == 0) ? a1 : a1 + step;
            }
            
            k++;
            cnt = cnt >> 1;
            step = step << 1;
        }

        return a1;
    }
}
```

## 20220101 <font color=#009975>E</font> <font color=#ed7336>R</font>

### 1185. 一周中的第几天

原题链接：[1185. 一周中的第几天](https://leetcode-cn.com/problems/day-of-the-week/)

> 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
>
> 输入为三个整数：day、month 和 year，分别表示日、月、年。
>
> 您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。
>
> **提示：**
>
> - 给出的日期一定是在 `1971` 到 `2100` 年之间的有效日期。

### 1.模拟

[参考题解](https://leetcode-cn.com/problems/day-of-the-week/solution/yi-zhou-zhong-de-di-ji-tian-by-leetcode-w43iw/)

``` java
class Solution {
    public String dayOfTheWeek(int day, int month, int year) {
        String[] weeks = new String[] {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
        int[] monthDays = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};

        // 输入年份之前的年份天数贡献
        int days = 365 * (year - 1971) + (year - 1969) / 4;
        // 输入月份的天数贡献
        for (int i = 0; i < month - 1; i++) {
            days += monthDays[i];
        }

        if (month > 2 && (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0))) {
            days++;
        }

        // 输入日份的天数贡献
        days += day;

        return weeks[(days + 3) % 7];
    }
}
```

