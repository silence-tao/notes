

# 2022年1月力扣每日1题

## 20220101 <font color=#009975>E</font> <font color=#009975>S</font>

### 2022. 将一维数组转变成二维数组

原题链接：[2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)

> 给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。
>
> original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。
>
> 请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。
>
> 提示：
>
> 1 <= original.length <= 5 * 104
> 1 <= original[i] <= 105
> 1 <= m, n <= 4 * 104

### 1.迭代法

``` java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        if (original.length != m * n) {
            return new int[0][0];
        }

        int[][] resArr = new int[m][n];
        // 遍历一维数组然后放入二维数组
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                resArr[i][j] = original[i * n + j];
            }
        }

        return resArr;
    }
}
```

## 20220102 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 390. 消除游戏

原题链接：[390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

> 列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：
>
> 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
> 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
> 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
> 给你整数 n ，返回 arr 最后剩下的数字。
>
> **提示：**
>
> - `1 <= n <= 109`

### 1.等差数列模拟

[参考题解](https://leetcode-cn.com/problems/elimination-game/solution/xiao-chu-you-xi-by-leetcode-solution-ydpb/)

``` java
class Solution {
    public int lastRemaining(int n) {
        int a1 = 1;
        int k = 0, cnt = n, step = 1;

        while (cnt > 1) {
            if (k % 2 == 0) { // 正向
                a1 = a1 + step;
            } else { // 反向
                a1 = (cnt % 2 == 0) ? a1 : a1 + step;
            }
            
            k++;
            cnt = cnt >> 1;
            step = step << 1;
        }

        return a1;
    }
}
```

## 20220103 <font color=#009975>E</font> <font color=#ed7336>R</font>

### 1185. 一周中的第几天

原题链接：[1185. 一周中的第几天](https://leetcode-cn.com/problems/day-of-the-week/)

> 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
>
> 输入为三个整数：day、month 和 year，分别表示日、月、年。
>
> 您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。
>
> **提示：**
>
> - 给出的日期一定是在 `1971` 到 `2100` 年之间的有效日期。

### 1.模拟

[参考题解](https://leetcode-cn.com/problems/day-of-the-week/solution/yi-zhou-zhong-de-di-ji-tian-by-leetcode-w43iw/)

``` java
class Solution {
    public String dayOfTheWeek(int day, int month, int year) {
        String[] weeks = new String[] {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
        int[] monthDays = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};

        // 输入年份之前的年份天数贡献
        int days = 365 * (year - 1971) + (year - 1969) / 4;
        // 输入月份的天数贡献
        for (int i = 0; i < month - 1; i++) {
            days += monthDays[i];
        }

        if (month > 2 && (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0))) {
            days++;
        }

        // 输入日份的天数贡献
        days += day;

        return weeks[(days + 3) % 7];
    }
}
```

## 20220104 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 913. 猫和老鼠

原题链接：[913. 猫和老鼠](https://leetcode-cn.com/problems/cat-and-mouse/)

> 两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。
>
> 图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。
>
> 老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。
>
> 在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。
>
> 此外，猫无法移动到洞中（节点 0）。
>
> 然后，游戏在出现以下三种情形之一时结束：
>
> 如果猫和老鼠出现在同一个节点，猫获胜。
> 如果老鼠到达洞中，老鼠获胜。
> 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。
> 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：
>
> 如果老鼠获胜，则返回 1；
> 如果猫获胜，则返回 2；
> 如果平局，则返回 0 。
>
> 提示：
>
> 3 <= graph.length <= 50
> 1 <= graph[i].length < graph.length
> 0 <= graph[i][j] < graph.length
> graph[i][j] != i
> graph[i] 互不相同
> 猫和老鼠在游戏中总是移动

### 1.动态规划

[参考题解](https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/)

``` java
class Solution {
    static final int MOUSE_WIN = 1;
    static final int CAT_WIN = 2;
    static final int DRAW = 0;
    int n;
    int[][] graph;
    int[][][] dp;

    public int catMouseGame(int[][] graph) {
        this.n = graph.length;
        this.graph = graph;
        this.dp = new int[n][n][n * 2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                Arrays.fill(dp[i][j], -1);
            }
        }
        return getResult(1, 2, 0);
    }

    public int getResult(int mouse, int cat, int turns) {
        if (turns == n * 2) {
            return DRAW;
        }
        if (dp[mouse][cat][turns] < 0) {
            if (mouse == 0) {
                dp[mouse][cat][turns] = MOUSE_WIN;
            } else if (cat == mouse) {
                dp[mouse][cat][turns] = CAT_WIN;
            } else {
                getNextResult(mouse, cat, turns);
            }
        }
        return dp[mouse][cat][turns];
    }

    public void getNextResult(int mouse, int cat, int turns) {
        int curMove = turns % 2 == 0 ? mouse : cat;
        int defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;
        int result = defaultResult;
        int[] nextNodes = graph[curMove];
        for (int next : nextNodes) {
            if (curMove == cat && next == 0) {
                continue;
            }
            int nextMouse = curMove == mouse ? next : mouse;
            int nextCat = curMove == cat ? next : cat;
            int nextResult = getResult(nextMouse, nextCat, turns + 1);
            if (nextResult != defaultResult) {
                result = nextResult;
                if (result != DRAW) {
                    break;
                }
            }
        }
        dp[mouse][cat][turns] = result;
    }
}
```

## 20220105 <font color=#009975>E</font> <font color=#009975>S</font>

### 1576. 替换所有的问号

原题链接：[1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)

> 给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。
>
> 注意：你 不能 修改非 '?' 字符。
>
> 题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。
>
> 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。
>
> **提示：**
>
> - `1 <= s.length <= 100`
> - `s` 仅包含小写英文字母和 `'?'` 字符

### 1.模拟

``` java
class Solution {
    public String modifyString(String s) {
        int length = s.length();

        char[] arr = s.toCharArray();
        for (int i = 0; i < length; i++) {
            if (arr[i] == '?') {
                for (char c = 'a'; c <= 'c'; c++) {
                    // 只要保证?左右的字符和新添加的字符不一样即可
                    if ((i > 0 && arr[i - 1] == c) || (i + 1 < length && arr[i + 1] == c)) {
                        continue ;
                    }

                    arr[i] = c;
                    break ;
                }
            }
        }

        return new String(arr);
    }
}
```

## 20220106 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 71. 简化路径

原题链接：[71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)

> 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。
>
> 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。
>
> 请注意，返回的 规范路径 必须遵循下述格式：
>
> 始终以斜杠 '/' 开头。
> 两个目录名之间必须只有一个斜杠 '/' 。
> 最后一个目录名（如果存在）不能 以 '/' 结尾。
> 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
> 返回简化后得到的 规范路径 。
>
> 提示：
>
> 1 <= path.length <= 3000
> path 由英文字母，数字，'.'，'/' 或 '_' 组成。
> path 是一个有效的 Unix 风格绝对路径。

### 1.队列

``` java
class Solution {
    public String simplifyPath(String path) {
        // 先将path用/分隔成字符串数组
        String[] names = path.split("/");
        // 用队列保存path中的有效路径名称
        LinkedList<String> queue = new LinkedList<>();
        for (String name : names) {
            // 如果当前是..表示要返回上一级目录
            if ("..".equals(name)) {
                if (!queue.isEmpty()) {
                    // 所以将队列中的最后一个元素弹出
                    queue.pollLast();
                }
            } else if (name.length() > 0 && !".".equals(name)) {
                // 如果当前名称非空且不是.
                // 那就将字符加入到队列中
                queue.offerLast(name);
            }
        }

        StringBuilder res = new StringBuilder();
        // 将队列中的名称从头到尾用/连接起来
        if (queue.isEmpty()) {
            // 如果没有有效的名称，就返回根目录/
            res.append("/");
        } else {
            while (!queue.isEmpty()) {
                res.append("/");
                res.append(queue.pollFirst());
            }
        }

        return res.toString();
    }
}
```

## 20220107 <font color=#009975>E</font> <font color=#009975>S</font>

### 1614. 括号的最大嵌套深度

原题链接：[1614. 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)

> 如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：
>
> 字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。
> 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
> 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
> 类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：
>
> depth("") = 0
> depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
> depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
> depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串
> 例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。
>
> 给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。
>
> 提示：
>
> 1 <= s.length <= 100
> s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成
> 题目数据保证括号表达式 s 是 有效的括号表达式

### 1.模拟

``` java
class Solution {
    public int maxDepth(String s) {
        char[] chars = s.toCharArray();
        // max记录最大深度，cur记录当前的深度
        int max = 0, cur = 0;
        // 遍历字符串的每一个字符
        for (char c : chars) {
            // 如果当前字符不是括号就跳过
            if (c != '(' && c != ')') {
                continue ;
            }

            // 如果是左括号
            if (c == '(') {
                // 当前深度加1
                cur++;

                // 并更新最大深度
                max = Math.max(max, cur);
            } else {
                // 否则深度减1
                cur--;
            }
        }

        return max;
    }
}
```

## 20220108 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 89. 格雷编码

原题链接：[89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)

> n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：
> 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
> 第一个整数是 0
> 一个整数在序列中出现 不超过一次
> 每对 相邻 整数的二进制表示 恰好一位不同 ，且
> 第一个 和 最后一个 整数的二进制表示 恰好一位不同
> 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。
>
> **提示：**
>
> - `1 <= n <= 16`

### 1.二进制数转格雷码

[参考题解](https://leetcode-cn.com/problems/gray-code/solution/ge-lei-bian-ma-by-leetcode-solution-cqi7/)

``` java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ret = new ArrayList<Integer>();
        for (int i = 0; i < 1 << n; i++) {
            ret.add((i >> 1) ^ i);
        }
        return ret;
    }
}
```

## 20220109 <font color=#009975>E</font> <font color=#009975>S</font>

### 1629. 按键持续时间最长的键

原题链接：[1629. 按键持续时间最长的键](https://leetcode-cn.com/problems/slowest-key/)

> LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。
>
> 给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。
>
> 测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。
>
> 注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。
>
> 请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。
>
> 提示：
>
> releaseTimes.length == n
> keysPressed.length == n
> 2 <= n <= 1000
> 1 <= releaseTimes[i] <= 109
> releaseTimes[i] < releaseTimes[i+1]
> keysPressed 仅由小写英文字母组成

### 1.迭代法

``` java
class Solution {
    public char slowestKey(int[] releaseTimes, String keysPressed) {
        int length = releaseTimes.length, max = releaseTimes[0];
        char res = keysPressed.charAt(0);

        for (int i = 1; i < length; i++) {
            char c = keysPressed.charAt(i);
            int time = releaseTimes[i] - releaseTimes[i - 1];
            if (max < time || (max == time && c > res)) {
                max = time;
                res = c;
            }
        }

        return res;
    }
}
```

## 20220110 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 306. 累加数

原题链接：[306. 累加数](https://leetcode-cn.com/problems/additive-number/)

> 累加数 是一个字符串，组成它的数字可以形成累加序列。
>
> 一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。
>
> 给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。
>
> 说明：累加序列里的数 不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。
>
> **提示：**
>
> - `1 <= num.length <= 35`
> - `num` 仅由数字（`0` - `9`）组成

### 1.累加

[参考链接](https://leetcode-cn.com/problems/additive-number/solution/lei-jia-shu-by-leetcode-solution-cadc/)

``` java
class Solution {
    public boolean isAdditiveNumber(String num) {
        int n = num.length();
        for (int secondStart = 1; secondStart < n - 1; ++secondStart) {
            if (num.charAt(0) == '0' && secondStart != 1) {
                break;
            }
            for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {
                if (num.charAt(secondStart) == '0' && secondStart != secondEnd) {
                    break;
                }
                if (valid(secondStart, secondEnd, num)) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean valid(int secondStart, int secondEnd, String num) {
        int n = num.length();
        int firstStart = 0, firstEnd = secondStart - 1;
        while (secondEnd <= n - 1) {
            String third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);
            int thirdStart = secondEnd + 1;
            int thirdEnd = secondEnd + third.length();
            if (thirdEnd >= n || !num.substring(thirdStart, thirdEnd + 1).equals(third)) {
                break;
            }
            if (thirdEnd == n - 1) {
                return true;
            }
            firstStart = secondStart;
            firstEnd = secondEnd;
            secondStart = thirdStart;
            secondEnd = thirdEnd;
        }
        return false;
    }

    public String stringAdd(String s, int firstStart, int firstEnd, int secondStart, int secondEnd) {
        StringBuffer third = new StringBuffer();
        int carry = 0, cur = 0;
        while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {
            cur = carry;
            if (firstEnd >= firstStart) {
                cur += s.charAt(firstEnd) - '0';
                --firstEnd;
            }
            if (secondEnd >= secondStart) {
                cur += s.charAt(secondEnd) - '0';
                --secondEnd;
            }
            carry = cur / 10;
            cur %= 10;
            third.append((char) (cur + '0'));
        }
        third.reverse();
        return third.toString();
    }
}
```

## 20220111 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 1036. 逃离大迷宫

原题链接：[1036. 逃离大迷宫](https://leetcode-cn.com/problems/escape-a-large-maze/)

> 在一个 106 x 106 的网格中，每个网格上方格的坐标为 (x, y) 。
>
> 现在从源方格 source = [sx, sy] 开始出发，意图赶往目标方格 target = [tx, ty] 。数组 blocked 是封锁的方格列表，其中每个 blocked[i] = [xi, yi] 表示坐标为 (xi, yi) 的方格是禁止通行的。
>
> 每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 不 在给出的封锁列表 blocked 上。同时，不允许走出网格。
>
> 只有在可以通过一系列的移动从源方格 source 到达目标方格 target 时才返回 true。否则，返回 false。
>
> 提示：
>
> 0 <= blocked.length <= 200
> blocked[i].length == 2
> 0 <= xi, yi < 106
> source.length == target.length == 2
> 0 <= sx, sy, tx, ty < 106
> source != target
> 题目数据保证 source 和 target 不在封锁列表内

### 1.有限步数的广度优先搜索

[参考题解](https://leetcode-cn.com/problems/escape-a-large-maze/solution/tao-chi-da-mi-gong-by-leetcode-solution-qxhz/)

``` java
class Solution {
    // 在包围圈中
    static final int BLOCKED = -1;
    // 不在包围圈中
    static final int VALID = 0;
    // 无论在不在包围圈中，但在 n(n-1)/2 步搜索的过程中经过了 target
    static final int FOUND = 1;
    
    static final int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    static final int BOUNDARY = 1000000;

    public boolean isEscapePossible(int[][] blocked, int[] source, int[] target) {
        if (blocked.length < 2) {
            return true;
        }

        Set<Pair> hashBlocked = new HashSet<Pair>();
        for (int[] pos : blocked) {
            hashBlocked.add(new Pair(pos[0], pos[1]));
        }

        int result = check(blocked, source, target, hashBlocked);
        if (result == FOUND) {
            return true;
        } else if (result == BLOCKED) {
            return false;
        } else {
            result = check(blocked, target, source, hashBlocked);
            return result != BLOCKED;
        }
    }

    public int check(int[][] blocked, int[] start, int[] finish, Set<Pair> hashBlocked) {
        int sx = start[0], sy = start[1];
        int fx = finish[0], fy = finish[1];
        int countdown = blocked.length * (blocked.length - 1) / 2;
        Pair startPair = new Pair(sx, sy);
        Queue<Pair> queue = new ArrayDeque<Pair>();
        queue.offer(startPair);
        Set<Pair> visited = new HashSet<Pair>();
        visited.add(startPair);
        while (!queue.isEmpty() && countdown > 0) {
            Pair pair = queue.poll();
            int x = pair.x, y = pair.y;
            for (int d = 0; d < 4; ++d) {
                int nx = x + dirs[d][0], ny = y + dirs[d][1];
                Pair newPair = new Pair(nx, ny);
                if (nx >= 0 && nx < BOUNDARY && ny >= 0 && ny < BOUNDARY && !hashBlocked.contains(newPair) && !visited.contains(newPair)) {
                    if (nx == fx && ny == fy) {
                        return FOUND;
                    }
                    --countdown;
                    queue.offer(newPair);
                    visited.add(newPair);
                }
            }
        }
        if (countdown > 0) {
            return BLOCKED;
        }
        return VALID;
    }
}

class Pair {
    int x;
    int y;

    public Pair(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public int hashCode() {
        return (int) ((long) x << 20 | y);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof Pair) {
            Pair pair2 = (Pair) obj;
            return x == pair2.x && y == pair2.y;
        }
        return false;
    }
}
```

## 20220112 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 334. 递增的三元子序列

原题链接：[334. 递增的三元子序列](https://leetcode-cn.com/problems/increasing-triplet-subsequence/)

> 给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。
>
> 如果存在这样的三元组下标 (i, j, k) 且满足 i < j < k ，使得 nums[i] < nums[j] < nums[k] ，返回 true ；否则，返回 false 。
>
> **提示：**
>
> - `1 <= nums.length <= 5 * 105`
> - `-231 <= nums[i] <= 231 - 1`

### 1.迭代法

``` java
class Solution {
    public boolean increasingTriplet(int[] nums) {
         int len;
        if (nums == null || (len = nums.length) == 0) {
            return false;
        }

        int min, mid = min = Integer.MAX_VALUE;
        for (int i = 0; i < len; i++) {
            int num;
            if ((num = nums[i]) <= min) {
                // 小于min，更新min
                min = num;
            } else if (num <= mid) {
                // 小于mid，更新mid
                mid = num;
            } else {
                return true;
            }
        }

        return false;
    }
}
```

## 20220113 <font color=#009975>E</font> <font color=#009975>S</font>

### 747. 至少是其他数字两倍的最大数

原题链接：[747. 至少是其他数字两倍的最大数](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/)

> 给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。
>
> 请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。
>
> **提示：**
>
> - `1 <= nums.length <= 50`
> - `0 <= nums[i] <= 100`
> - `nums` 中的最大元素是唯一的

### 1迭代法

``` java
class Solution {
    public int dominantIndex(int[] nums) {
        int m1 = -1, m2 = -1;
        int index = -1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] > m1) {
                m2 = m1;
                m1 = nums[i];
                index = i;
            } else if (nums[i] > m2) {
                m2 = nums[i];
            }
        }
        return m1 >= m2 * 2 ? index : -1;
    }
}
```

## 20220114 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 373. 查找和最小的 K 对数字

原题链接：[373. 查找和最小的 K 对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

> 给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。
>
> 定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。
>
> 请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。
>
>  提示:
>
> 1 <= nums1.length, nums2.length <= 105
> -109 <= nums1[i], nums2[i] <= 109
> nums1 和 nums2 均为升序排列
> 1 <= k <= 1000

### 1.优先队列

[参考链接](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/solution/cha-zhao-he-zui-xiao-de-kdui-shu-zi-by-l-z526/)

``` java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        PriorityQueue<int[]> pq = new PriorityQueue<>(k, (o1, o2)->{
            return nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]];
        });
        List<List<Integer>> ans = new ArrayList<>();
        int m = nums1.length;
        int n = nums2.length;
        for (int i = 0; i < Math.min(m, k); i++) {
            pq.offer(new int[]{i,0});
        }
        while (k-- > 0 && !pq.isEmpty()) {
            int[] idxPair = pq.poll();
            List<Integer> list = new ArrayList<>();
            list.add(nums1[idxPair[0]]);
            list.add(nums2[idxPair[1]]);
            ans.add(list);
            if (idxPair[1] + 1 < n) {
                pq.offer(new int[]{idxPair[0], idxPair[1] + 1});
            }
        }
        
        return ans;
    }
}
```

## 20220115 <font color=#009975>E</font> <font color=#009975>S</font>

### 1716. 计算力扣银行的钱

原题链接：[1716. 计算力扣银行的钱](https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/)

> Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。
>
> 最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。
>
> 给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。
>
> **提示：**
>
> - `1 <= n <= 1000`

### 1.模拟

``` java
class Solution {
    public int totalMoney(int n) {
        // 先算出n天一共有几周，余几天
        int week = n / 7, days = n % 7;

        // base表示每周一存钱的基数
        int sum = 0, base = 1;
        while (base <= week) {
            // 每周存钱的数量就是 base * 7 + 21
            sum += base * 7 + 21;
            // 然后基数再 + 1
            base++;
        }

        // 剩余天数
        if (days > 0) {
            // 在base基础上每天 + 1
            for (int j = 0; j < days; j++) {
                sum += base + j;
            }
        }

        return sum;
    }
}
```

## 20220116 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 382. 链表随机节点

原题链接：[382. 链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

> 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。
>
> 实现 Solution 类：
>
> Solution(ListNode head) 使用整数数组初始化对象。
> int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。
>
> **提示：**
>
> - 链表中的节点数在范围 `[1, 104]` 内
> - `-104 <= Node.val <= 104`
> - 至多调用 `getRandom` 方法 `104` 次

### 1.随机函数

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {

    private List<ListNode> list;

    private Random random;

    public Solution(ListNode head) {
        list = new ArrayList<>();
        while (head != null) {
            list.add(head);

            head = head.next;
        }

        random = new Random();
    }
    
    public int getRandom() {
        return list.get(random.nextInt(list.size())).val;
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(head);
 * int param_1 = obj.getRandom();
 */
```

## 20220117 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 1220. 统计元音字母序列的数目

原题链接：[1220. 统计元音字母序列的数目](https://leetcode-cn.com/problems/count-vowels-permutation/)

> 给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：
>
> 字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）
> 每个元音 'a' 后面都只能跟着 'e'
> 每个元音 'e' 后面只能跟着 'a' 或者是 'i'
> 每个元音 'i' 后面 不能 再跟着另一个 'i'
> 每个元音 'o' 后面只能跟着 'i' 或者是 'u'
> 每个元音 'u' 后面只能跟着 'a'
> 由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。
>
> **提示：**
>
> - `1 <= n <= 2 * 10^4`

### 1.动态规划

[参考链接](https://leetcode-cn.com/problems/count-vowels-permutation/solution/tong-ji-yuan-yin-zi-mu-xu-lie-de-shu-mu-jxo09/)

``` java
class Solution {
    public int countVowelPermutation(int n) {
        long mod = 1000000007;
        long[] dp = new long[5];
        long[] ndp = new long[5];
        for (int i = 0; i < 5; ++i) {
            dp[i] = 1;
        }
        for (int i = 2; i <= n; ++i) {
            /* a前面可以为e,u,i */
            ndp[0] = (dp[1] + dp[2] + dp[4]) % mod;
            /* e前面可以为a,i */
            ndp[1] = (dp[0] + dp[2]) % mod;
            /* i前面可以为e,o */
            ndp[2] = (dp[1] + dp[3]) % mod;
            /* o前面可以为i */
            ndp[3] = dp[2];
            /* u前面可以为i,o */
            ndp[4] = (dp[2] + dp[3]) % mod;
            System.arraycopy(ndp, 0, dp, 0, 5);
        }
        long ans = 0;
        for (int i = 0; i < 5; ++i) {
            ans = (ans + dp[i]) % mod;
        }
        return (int)ans;
    }
}
```

## 20220118 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 539. 最小时间差

原题链接：[539. 最小时间差](https://leetcode-cn.com/problems/minimum-time-difference/)

> 给定一个 24 小时制（小时:分钟 **"HH:MM"**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。
>
> **提示：**
>
> - `2 <= timePoints.length <= 2 * 104`
> - `timePoints[i]` 格式为 **"HH:MM"**

### 1.排序

[参考题解](https://leetcode-cn.com/problems/minimum-time-difference/solution/zui-xiao-shi-jian-chai-by-leetcode-solut-xolj/)

``` java
class Solution {
    public int findMinDifference(List<String> timePoints) {
        // 先对集合排序
        Collections.sort(timePoints);

        // 最小的时间firstTime
        int firstTime = getTime(timePoints.get(0));
        int preTime = firstTime, ans = Integer.MAX_VALUE;

        // 然后挨个计算相邻时间的差值，并取最小值
        for (int i = 1; i < timePoints.size(); i++) {
            int curTime = getTime(timePoints.get(i));
            ans = Math.min(ans, curTime - preTime);
            preTime = curTime;
        }

        // 最小的时间firstTime可以是第二天的时间
        // 所以加上1440再和最后一个时间作差
        // 取最小值
        ans = Math.min(ans, firstTime + 1440 - preTime);

        return ans;
    }

    private int getTime(String str) {
        char[] chars = str.toCharArray();
        return ((chars[0] - '0') * 10 + (chars[1] - '0')) * 60 + (chars[3] - '0') * 10 + (chars[4] - '0');
    }
}
```

## 20220119 <font color=#009975>E</font> <font color=#009975>S</font>

### 219. 存在重复元素 II

原题链接：[219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

> 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-109 <= nums[i] <= 109`
> - `0 <= k <= 105`

### 1.哈希

``` java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        int length = nums.length;

        // 利用HashMap保存整数与数组下标的关系
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < length; i++) {
            int num = nums[i];
            // 如果map中已经有了对应的元素
            // 数组下标差的绝对值小于k
            if (map.containsKey(num) && Math.abs(map.get(num) - i) <= k) {
                // 返回true
                return true;
            }

            // 将整数与下标的关系放入map中
            map.put(num, i);
        }

        return false;
    }
}
```

## 20220120 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 2029. 石子游戏 IX

原题链接：[2029. 石子游戏 IX](https://leetcode-cn.com/problems/stone-game-ix/)

> Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。
>
> Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。
>
> 如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。
> 如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
> 假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。
>
> **提示：**
>
> - `1 <= stones.length <= 105`
> - `1 <= stones[i] <= 104`

### 1.构造

[参考题解](https://leetcode-cn.com/problems/stone-game-ix/solution/shi-zi-you-xi-ix-by-leetcode-solution-kk5f/)

``` java
class Solution {
    public boolean stoneGameIX(int[] stones) {
        int cnt0 = 0, cnt1 = 0, cnt2 = 0;
        for (int val : stones) {
            int type = val % 3;
            if (type == 0) {
                ++cnt0;
            } else if (type == 1) {
                ++cnt1;
            } else {
                ++cnt2;
            }
        }
        if (cnt0 % 2 == 0) {
            return cnt1 >= 1 && cnt2 >= 1;
        }
        return cnt1 - cnt2 > 2 || cnt2 - cnt1 > 2;
    }
}
```

## 20220121 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 1345. 跳跃游戏 IV

原题链接：[1345. 跳跃游戏 IV](https://leetcode-cn.com/problems/jump-game-iv/)

> 给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。
>
> 每一步，你可以从下标 i 跳到下标：
>
> i + 1 满足：i + 1 < arr.length
> i - 1 满足：i - 1 >= 0
> j 满足：arr[i] == arr[j] 且 i != j
> 请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。
>
> 注意：任何时候你都不能跳到数组外面。
>
> **提示：**
>
> - `1 <= arr.length <= 5 * 10^4`
> - `-10^8 <= arr[i] <= 10^8`

### 1.广度优先搜索

[参考题解](https://leetcode-cn.com/problems/jump-game-iv/solution/tiao-yue-you-xi-iv-by-leetcode-solution-zsix/)

``` java
class Solution {
    public int minJumps(int[] arr) {
        Map<Integer, List<Integer>> idxSameValue = new HashMap<Integer, List<Integer>>();
        for (int i = 0; i < arr.length; i++) {
            idxSameValue.putIfAbsent(arr[i], new ArrayList<Integer>());
            idxSameValue.get(arr[i]).add(i);
        }
        Set<Integer> visitedIndex = new HashSet<Integer>();
        Queue<int[]> queue = new ArrayDeque<int[]>();
        queue.offer(new int[]{0, 0});
        visitedIndex.add(0);
        while (!queue.isEmpty()) {
            int[] idxStep = queue.poll();
            int idx = idxStep[0], step = idxStep[1];
            if (idx == arr.length - 1) {
                return step;
            }
            int v = arr[idx];
            step++;
            if (idxSameValue.containsKey(v)) {
                for (int i : idxSameValue.get(v)) {
                    if (visitedIndex.add(i)) {
                        queue.offer(new int[]{i, step});
                    }
                }
                idxSameValue.remove(v);
            }
            if (idx + 1 < arr.length && visitedIndex.add(idx + 1)) {
                queue.offer(new int[]{idx + 1, step});
            }
            if (idx - 1 >= 0 && visitedIndex.add(idx - 1)) {
                queue.offer(new int[]{idx - 1, step});
            }
        }
        return -1;
    }
}
```

## 20220122 <font color=#009975>E</font> <font color=#ed7336>R</font>

### 1332. 删除回文子序列

原题链接：[1332. 删除回文子序列](https://leetcode-cn.com/problems/remove-palindromic-subsequences/)

> 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。
>
> 返回删除给定字符串中所有字符（字符串为空）的最小删除次数。
>
> 「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。
>
> 「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s` 仅包含字母 `'a'` 和 `'b'`

### 1.直接判断

[参考题解](https://leetcode-cn.com/problems/remove-palindromic-subsequences/solution/shan-chu-hui-wen-zi-xu-lie-by-leetcode-s-tqtb/)

``` java
class Solution {
    public int removePalindromeSub(String s) {
        int length = s.length();

        for (int i = 0; i < length; i++) {
            if (s.charAt(i) != s.charAt(length - i - 1)) {
                return 2;
            }
        }

        return 1;
    }
}
```

## 20220123 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 2034. 股票价格波动

原题链接：[2034. 股票价格波动](https://leetcode-cn.com/problems/stock-price-fluctuation/)

> 给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。
>
> 不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。
>
> 请你设计一个算法，实现：
>
> 更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。
> 找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。
> 找到当前记录里股票的 最高价格 。
> 找到当前记录里股票的 最低价格 。
> 请你实现 StockPrice 类：
>
> StockPrice() 初始化对象，当前无股票价格记录。
> void update(int timestamp, int price) 在时间点 timestamp 更新股票价格为 price 。
> int current() 返回股票 最新价格 。
> int maximum() 返回股票 最高价格 。
> int minimum() 返回股票 最低价格 。
>
> 提示：
>
> 1 <= timestamp, price <= 109
> update，current，maximum 和 minimum 总 调用次数不超过 105 。
> current，maximum 和 minimum 被调用时，update 操作 至少 已经被调用过 一次 。

### 1.哈希表 + 有序集合

[参考题解](https://leetcode-cn.com/problems/stock-price-fluctuation/solution/gu-piao-jie-ge-bo-dong-by-leetcode-solut-rwrb/)

``` java
class StockPrice {

    // 最新的时间戳
    private int maxTimestamp;
    // 保存时间戳和股票价格的关系
    private HashMap<Integer, Integer> map;
    // 以有序的方式保存价格和价格出现的次数
    private TreeMap<Integer, Integer> treeMap;

    public StockPrice() {
        maxTimestamp = 0;
        map = new HashMap<Integer, Integer>();
        treeMap = new TreeMap<Integer, Integer>();
    }
    
    public void update(int timestamp, int price) {
        // 更新最新时间戳
        maxTimestamp = Math.max(maxTimestamp, timestamp);

        int srcPrice = map.getOrDefault(timestamp, 0);
        map.put(timestamp, price);

        // 如果timestamp已经存在
        if (srcPrice > 0) {
            // 更新treeMap
            treeMap.put(srcPrice, treeMap.get(srcPrice) - 1);
            if (treeMap.get(srcPrice) <= 0) {
                treeMap.remove(srcPrice);
            }
        }

        // 将当前价格放入treeMap中
        treeMap.put(price, treeMap.getOrDefault(price, 0) + 1);
    }
    
    public int current() {
        return map.get(maxTimestamp);
    }
    
    public int maximum() {
        return treeMap.lastKey();
    }
    
    public int minimum() {
        return treeMap.firstKey();
    }
}

/**
 * Your StockPrice object will be instantiated and called as such:
 * StockPrice obj = new StockPrice();
 * obj.update(timestamp,price);
 * int param_2 = obj.current();
 * int param_3 = obj.maximum();
 * int param_4 = obj.minimum();
 */
```

## 20220124 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 2045. 到达目的地的第二短时间

原题链接：[2045. 到达目的地的第二短时间](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/)

> 城市用一个 双向连通 图表示，图中有 n 个节点，从 1 到 n 编号（包含 1 和 n）。图中的边用一个二维整数数组 edges 表示，其中每个 edges[i] = [ui, vi] 表示一条节点 ui 和节点 vi 之间的双向连通边。每组节点对由 最多一条 边连通，顶点不存在连接到自身的边。穿过任意一条边的时间是 time 分钟。
>
> 每个节点都有一个交通信号灯，每 change 分钟改变一次，从绿色变成红色，再由红色变成绿色，循环往复。所有信号灯都 同时 改变。你可以在 任何时候 进入某个节点，但是 只能 在节点 信号灯是绿色时 才能离开。如果信号灯是  绿色 ，你 不能 在节点等待，必须离开。
>
> 第二小的值 是 严格大于 最小值的所有值中最小的值。
>
> 例如，[2, 3, 4] 中第二小的值是 3 ，而 [2, 2, 4] 中第二小的值是 4 。
> 给你 n、edges、time 和 change ，返回从节点 1 到节点 n 需要的 第二短时间 。
>
> 注意：
>
> 你可以 任意次 穿过任意顶点，包括 1 和 n 。
> 你可以假设在 启程时 ，所有信号灯刚刚变成 绿色 。
>
> 提示：
>
> 2 <= n <= 104
> n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)
> edges[i].length == 2
> 1 <= ui, vi <= n
> ui != vi
> 不含重复边
> 每个节点都可以从其他节点直接或者间接到达
> 1 <= time, change <= 103

### 1.广度优先搜索

[参考链接](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/solution/dao-da-mu-de-di-de-di-er-duan-shi-jian-b-05i0/)

``` java
class Solution {
    public int secondMinimum(int n, int[][] edges, int time, int change) {
        List<Integer>[] graph = new List[n + 1];
        for (int i = 0; i <= n; i++) {
            graph[i] = new ArrayList<Integer>();
        }
        for (int[] edge : edges) {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }

        // path[i][0] 表示从 1 到 i 的最短路长度，path[i][1] 表示从 1 到 i 的严格次短路长度
        int[][] path = new int[n + 1][2];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(path[i], Integer.MAX_VALUE);
        }
        path[1][0] = 0;
        Queue<int[]> queue = new ArrayDeque<int[]>();
        queue.offer(new int[]{1, 0});
        while (path[n][1] == Integer.MAX_VALUE) {
            int[] arr = queue.poll();
            int cur = arr[0], len = arr[1];
            for (int next : graph[cur]) {
                if (len + 1 < path[next][0]) {
                    path[next][0] = len + 1;
                    queue.offer(new int[]{next, len + 1});
                } else if (len + 1 > path[next][0] && len + 1 < path[next][1]) {
                    path[next][1] = len + 1;
                    queue.offer(new int[]{next, len + 1});
                }
            }
        }

        int ret = 0;
        for (int i = 0; i < path[n][1]; i++) {
            if (ret % (2 * change) >= change) {
                ret = ret + (2 * change - ret % (2 * change));
            }
            ret = ret + time;
        }
        return ret;
    }
}
```

## 20220125 <font color=#009975>E</font> <font color=#009975>S</font>

### 1688. 比赛中的配对次数

原题链接：[1688. 比赛中的配对次数](https://leetcode-cn.com/problems/count-of-matches-in-tournament/)

> 给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：
>
> 如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。
> 如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。
> 返回在比赛中进行的配对次数，直到决出获胜队伍为止。
>
> **提示：**
>
> - `1 <= n <= 200`

### 1.模拟

``` java
class Solution {
    
    public int numberOfMatches(int n) {
        int sum = 0;

        while (true) {
            sum += n / 2;
            n = n % 2 == 0 ? (n / 2) : ((n - 1) / 2 + 1);
            
            if (n == 1) {
                break ;
            }
        }

        return sum;
    }
}
```

## 20220126 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 2013. 检测正方形

原题链接：[2013. 检测正方形](https://leetcode-cn.com/problems/detect-squares/)

> 给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：
>
> 添加 一个在数据流中的新点到某个数据结构中。可以添加 重复 的点，并会视作不同的点进行处理。
> 给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 面积为正 的 轴对齐正方形 ，统计 满足该要求的方案数目。
> 轴对齐正方形 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。
>
> 实现 DetectSquares 类：
>
> DetectSquares() 使用空数据结构初始化对象
> void add(int[] point) 向数据结构添加一个新的点 point = [x, y]
> int count(int[] point) 统计按上述方式与点 point = [x, y] 共同构造 轴对齐正方形 的方案数。
>
> **提示：**
>
> - `point.length == 2`
> - `0 <= x, y <= 1000`
> - 调用 `add` 和 `count` 的 **总次数** 最多为 `5000`

### 1.遍历

[参考题解](https://leetcode-cn.com/problems/detect-squares/solution/jian-ce-zheng-fang-xing-by-leetcode-solu-vwzs/)

``` java
class DetectSquares {
    Map<Integer, Map<Integer, Integer>> cnt;

    public DetectSquares() {
        cnt = new HashMap<Integer, Map<Integer, Integer>>();
    }

    public void add(int[] point) {
        int x = point[0], y = point[1];
        cnt.putIfAbsent(y, new HashMap<Integer, Integer>());
        Map<Integer, Integer> yCnt = cnt.get(y);
        yCnt.put(x, yCnt.getOrDefault(x, 0) + 1);
    }

    public int count(int[] point) {
        int res = 0;
        int x = point[0], y = point[1];
        if (!cnt.containsKey(y)) {
            return 0;
        }
        Map<Integer, Integer> yCnt = cnt.get(y);
        Set<Map.Entry<Integer, Map<Integer, Integer>>> entries = cnt.entrySet();
        for (Map.Entry<Integer, Map<Integer, Integer>> entry : entries) {
            int col = entry.getKey();
            Map<Integer, Integer> colCnt = entry.getValue();
            if (col != y) {
                // 根据对称性，这里可以不用取绝对值
                int d = col - y;
                res += colCnt.getOrDefault(x, 0) * yCnt.getOrDefault(x + d, 0) * colCnt.getOrDefault(x + d, 0);
                res += colCnt.getOrDefault(x, 0) * yCnt.getOrDefault(x - d, 0) * colCnt.getOrDefault(x - d, 0);
            }
        }
        return res;
    }
}

/**
 * Your DetectSquares object will be instantiated and called as such:
 * DetectSquares obj = new DetectSquares();
 * obj.add(point);
 * int param_2 = obj.count(point);
 */
```

## 20220127 <font color=#009975>E</font> <font color=#ec4c47>U</font>

### 2047. 句子中的有效单词数

原题链接：[2047. 句子中的有效单词数](https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/)

> 句子仅由小写字母（'a' 到 'z'）、数字（'0' 到 '9'）、连字符（'-'）、标点符号（'!'、'.' 和 ','）以及空格（' '）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ' ' 分隔。
>
> 如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：
>
> 仅由小写字母、连字符和/或标点（不含数字）。
> 至多一个 连字符 '-' 。如果存在，连字符两侧应当都存在小写字母（"a-b" 是一个有效单词，但 "-ab" 和 "ab-" 不是有效单词）。
> 至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。
> 这里给出几个有效单词的例子："a-b."、"afad"、"ba-c"、"a!" 和 "!" 。
>
> 给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。
>
> 提示：
>
> - 1 <= sentence.length <= 1000
> - sentence 由小写英文字母、数字（0-9）、以及字符（' '、'-'、'!'、'.' 和 ','）组成
> - 句子中至少有 1 个 token

### 1.遍历

[参考题解](https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/solution/ju-zi-zhong-de-you-xiao-dan-ci-shu-by-le-hvow/)

``` java
class Solution {
    public int countValidWords(String sentence) {
        int n = sentence.length();
        int l = 0, r = 0;
        int ret = 0;
        while (true) {
            while (l < n && sentence.charAt(l) == ' ') {
                l++;
            }
            if (l >= n) {
                break;
            }
            r = l + 1;
            while (r < n && sentence.charAt(r) != ' ') {
                r++;
            }
            if (isValid(sentence.substring(l, r))) { // 判断根据空格分解出来的 token 是否有效
                ret++;
            }
            l = r + 1;
        }
        return ret;
    }

    public boolean isValid(String word) {
        int n = word.length();
        boolean hasHyphens = false;
        for (int i = 0; i < n; i++) {
            if (Character.isDigit(word.charAt(i))) {
                return false;
            } else if (word.charAt(i) == '-') {
                if (hasHyphens == true || i == 0 || i == n - 1 || !Character.isLetter(word.charAt(i - 1)) || !Character.isLetter(word.charAt(i + 1))) {
                    return false;
                }
                hasHyphens = true;
            } else if (word.charAt(i) == '!' || word.charAt(i) == '.' || word.charAt(i) == ',') {
                if (i != n - 1) {
                    return false;
                }
            }
        }
        return true;
    }
}
```

## 20220128 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 1996. 游戏中弱角色的数量

原题链接：[1996. 游戏中弱角色的数量](https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/)

> 你正在参加一个多角色游戏，每个角色都有两个主要属性：攻击 和 防御 。给你一个二维整数数组 properties ，其中 properties[i] = [attacki, defensei] 表示游戏中第 i 个角色的属性。
>
> 如果存在一个其他角色的攻击和防御等级 都严格高于 该角色的攻击和防御等级，则认为该角色为 弱角色 。更正式地，如果认为角色 i 弱于 存在的另一个角色 j ，那么 attackj > attacki 且 defensej > defensei 。
>
> 返回 弱角色 的数量。
>
> 提示：
>
> 2 <= properties.length <= 105
> properties[i].length == 2
> 1 <= attacki, defensei <= 105

### 1.排序

[参考链接](https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/solution/you-xi-zhong-ruo-jiao-se-de-shu-liang-by-3d2g/)

``` java
class Solution {
    public int numberOfWeakCharacters(int[][] properties) {
        Arrays.sort(properties, (o1, o2) -> {
            return o1[0] == o2[0] ? (o1[1] - o2[1]) : (o2[0] - o1[0]);
        });
        int maxDef = 0;
        int ans = 0;
        for (int[] p : properties) {
            if (p[1] < maxDef) {
                ans++;
            } else {
                maxDef = p[1];
            }
        }
        return ans;
    }
}
```

## 20220129 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 1765. 地图中的最高点

原题链接：[1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)

> 给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。
>
> 如果 isWater[i][j] == 0 ，格子 (i, j) 是一个 陆地 格子。
> 如果 isWater[i][j] == 1 ，格子 (i, j) 是一个 水域 格子。
> 你需要按照如下规则给每个单元格安排高度：
>
> 每个格子的高度都必须是非负的。
> 如果一个格子是是 水域 ，那么它的高度必须为 0 。
> 任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）
> 找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。
>
> 请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。
>
> 提示：
>
> m == isWater.length
> n == isWater[i].length
> 1 <= m, n <= 1000
> isWater[i][j] 要么是 0 ，要么是 1 。
> 至少有 1 个水域格子。
>

### 1.多源广度优先搜索

[参考链接](https://leetcode-cn.com/problems/map-of-highest-peak/solution/di-tu-zhong-de-zui-gao-dian-by-leetcode-jdkzr/)

``` java
class Solution {
    int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    public int[][] highestPeak(int[][] isWater) {
        int m = isWater.length, n = isWater[0].length;
        int[][] ans = new int[m][n];
        for (int i = 0; i < m; ++i) {
            Arrays.fill(ans[i], -1); // -1 表示该格子尚未被访问过
        }
        Queue<int[]> queue = new ArrayDeque<int[]>();
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (isWater[i][j] == 1) {
                    ans[i][j] = 0;
                    queue.offer(new int[]{i, j}); // 将所有水域入队
                }
            }
        }
        while (!queue.isEmpty()) {
            int[] p = queue.poll();
            for (int[] dir : dirs) {
                int x = p[0] + dir[0], y = p[1] + dir[1];
                if (0 <= x && x < m && 0 <= y && y < n && ans[x][y] == -1) {
                    ans[x][y] = ans[p[0]][p[1]] + 1;
                    queue.offer(new int[]{x, y});
                }
            }
        }
        return ans;
    }
}
```

## 20220130 <font color=#009975>E</font> <font color=#009975>S</font>

### 884. 两句话中的不常见单词

原题链接：[884. 两句话中的不常见单词](https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/)

> 句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。
>
> 如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。
>
> 给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。
>
> 提示：
>
> 1 <= s1.length, s2.length <= 200
> s1 和 s2 由小写英文字母和空格组成
> s1 和 s2 都不含前导或尾随空格
> s1 和 s2 中的所有单词间均由单个空格分隔
>

### 1.遍历

``` java
class Solution {
    public String[] uncommonFromSentences(String s1, String s2) {
        Map<String, Integer> memoery = new HashMap<String, Integer>();

        String[] strs = s1.split(" ");
        for (String str : strs) {
            memoery.put(str, memoery.getOrDefault(str, 0) + 1);
        }

        strs = s2.split(" ");
        for (String str : strs) {
            memoery.put(str, memoery.getOrDefault(str, 0) + 1);
        }

        List<String> resList = new ArrayList<>();
        for (Map.Entry<String, Integer> entry : memoery.entrySet()) {
            if (entry.getValue() == 1) {
                resList.add(entry.getKey());
            }
        }

        String[] res = new String[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }

        return res;
    }
}
```

## 20220131 <font color=#009975>E</font> <font color=#009975>S</font>

### 1342. 将数字变成 0 的操作次数

原题链接：[1342. 将数字变成 0 的操作次数](https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/)

> 给你一个非负整数 `num` ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。
>
> **提示：**
>
> - `0 <= num <= 10^6`

### 1.遍历

``` java
class Solution {
    public int numberOfSteps(int num) {
        int sum = 0;

        while (num != 0) {
            if (num % 2 == 0) {
                num /= 2;
            } else {
                num -= 1;
            }

            sum++;
        }

        return sum;
    }
}
```

