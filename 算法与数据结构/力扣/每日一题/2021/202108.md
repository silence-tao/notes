# 2021年8月力扣每日1题

## 20210801 <font color=#009975>E</font> <font color=#009975>S</font>

### 1337. 矩阵中战斗力最弱的 K 行

原题链接：[1337. 矩阵中战斗力最弱的 K 行](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/)

> 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
>
> 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
>
> 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
>
> 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

### 1.排序

``` java
class Solution {

    // 用Row类表示每一行的信息
    // 包括行号和军人数量
    public static class Row {
        
        // 第几行
        int idx;

        // 军人数量
        int soldiers;

        Row(int idx, int soldiers) {
            this.idx = idx;
            this.soldiers = soldiers;
        }
    }

    public int[] kWeakestRows(int[][] mat, int k) {
        int m = mat.length, n = mat[0].length;

        // 统计每一行的军人数量并构建Row对象放入rows集合中
        List<Row> rows = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            int soldiers = 0;
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1) {
                    soldiers++;
                }
            }

            rows.add(new Row(i, soldiers));
        }

        // 排序：soldiers相同按idx从小到大排序
        // soldiers不相同按soldiers从小到大排序
        Collections.sort(rows, (a, b) -> {
            if (a.soldiers == b.soldiers) {
                return a.idx - b.idx;
            } else {
                return a.soldiers - b.soldiers;
            }
        });

        // 收集前k个结果并返回
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = rows.get(i).idx;
        }

        return res;
    }
}
```

## 20210802 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 743. 网络延迟时间

原题链接：[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

> 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
>
> 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

### 1.Dijkstra

[参考题解](https://leetcode-cn.com/problems/network-delay-time/solution/wang-luo-yan-chi-shi-jian-by-leetcode-so-6phc/)

``` java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        // 表示最大值
        final int INF = Integer.MAX_VALUE / 2;

        // 二维数组g表示源节点到目标节点的距离
        // 无法到达置为INF
        int[][] g = new int[n][n];
        // 初始化二维数组g
        for (int i = 0; i < n; ++i) {
            Arrays.fill(g[i], INF);
        }

        // 将源节点到目标节点的距离填充到二维数组中
        for (int[] t : times) {
            int x = t[0] - 1, y = t[1] - 1;
            g[x][y] = t[2];
        }

        // 用数组dist表示节点k到图中各个节点的最短距离
        int[] dist = new int[n];
        // 初始化数组dist
        Arrays.fill(dist, INF);
        // 表示k到k节点的距离为0
        dist[k - 1] = 0;
        // 标记访问过的节点
        boolean[] used = new boolean[n];

        // 利用Dijkstra算法计算单源最短路径
        for (int i = 0; i < n; ++i) {
            // 1.找到图中k节点能够到达的节点中路径最短的一个节点
            int x = -1;
            for (int y = 0; y < n; ++y) {
                if (!used[y] && (x == -1 || dist[y] < dist[x])) {
                    x = y;
                }
            }

            // 2.将这个节点标记为已访问
            used[x] = true;

            // 3.把x能到达的节点更新一遍
            for (int y = 0; y < n; ++y) {
                dist[y] = Math.min(dist[y], dist[x] + g[x][y]);
            }
        }

        // k节点到达图中各个节点最短路径的最大值
        // 就是能使所有节点都收到信号的时间
        int ans = Arrays.stream(dist).max().getAsInt();
        
        // 如果这个值为INF表示有节点无法通过节点k到达
        return ans == INF ? -1 : ans;
    }
}
```

## 20210803 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 581. 最短无序连续子数组

原题链接：[581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

> 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
>
> 请你找出符合题意的 最短 子数组，并输出它的长度。

### 1.双指针 + 排序

[参考题解](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-e1le/)

``` java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int length = nums.length;
        // 先将数组nums复制一份放到数组clone中
		int[] clone = new int[length];
		for (int i = 0; i < length; i++) {
			clone[i] = nums[i];
		}

        // 然后对数组clone进行排序
		Arrays.sort(clone);

        // 利用双指针比较数组nums和clone不同的地方
		int i = 0, j = length - 1;
		while (i <= j && nums[i] == clone[i]) {
			i++;
		}

		while (i <= j && nums[j] == clone[j]) {
			j--;
		}
			
        // 区间[i, j]就是最短子数组
		return j - i + 1;
    }
}
```

## 20210804 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 611. 有效三角形的个数

原题链接：[611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

> 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

### 1.排序 + 二分法

[参考题解](https://leetcode-cn.com/problems/valid-triangle-number/solution/you-xiao-san-jiao-xing-de-ge-shu-by-leet-t2td/)

``` java
class Solution {
    public int triangleNumber(int[] nums) {
        int length = nums.length;

        // 要保证三元组能组成三角形，那么必须保证两边之和大于第三边
        // 这里先对数组nums升序排序
        Arrays.sort(nums);

        // 排序后的nums满足：nums[i] < nums[j] < nums[k] (i < j < k)
        // 必然有nums[i] + nums[k] > nums[j]和nums[j] + nums[k] > nums[i]
        // 那么只需要保证nums[i] + nums[j] > nums[k]即可使三元组组成三角形
        int sum = 0;
        for (int i = 0; i < length; i++) {
            for (int j = i + 1; j < length; j++) {
                // 通过二分法找到能使nums[i] + nums[j] > nums[k]成立的k的区间
                // 这个区间所有的元素都能和nums[i]与nums[j]组成三角形
                int left = j + 1, right = length - 1, k = j;
                while (left <= right) {
                    int mid = left + right >> 1;
                    if (nums[i] + nums[j] > nums[mid]) {
                        left = mid + 1;
                        k = mid;
                    } else {
                        right = mid - 1;
                    }
                }

                // (j, k]就是满足条件的区间
                sum += k - j;
            }
        }

        return sum;
    }
}
```

## 20210805 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 802. 找到最终的安全状态

原题链接：[802. 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)

> 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。
>
> 对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。
>
> 返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。
>
> 该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。
>
> 提示：
>
> n == graph.length
> 1 <= n <= 104
> 0 <= graph[i].length <= n
> graph[i] 按严格递增顺序排列。
> 图中可能包含自环。
> 图中边的数目在范围 [1, 4 * 104] 内。
>

### 1.递归

``` java
class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        int n = graph.length;

        List<Integer> res = new ArrayList<>();
        
        // 用数组visited表示节点是否被访问过
        // 其中visited[i]表示第i个节点的访问情况
        int[] visited = new int[n];
        // 1.取visited[i]值二进制的左边第一位表示是否访问过
        // 左边第一位二进制位0表示未访问，1表示已访问
        // 2.取visited[i]值二进制的左边第二位表示是否安全
        // 左边第二位二进制位0表示不安全，1表示安全
        // 所以visited[i] == 1表示已访问
        // visited[i] == 3表示已访问且安全
        for (int i = 0; i < n; i++) {
            // visited[i] == 3表示安全
            if (visited[i] == 3) {
                // 将i加入结果集合中
                res.add(i);
                
                continue ;
            }

            // 递归判断第idx个节点是否安全
            if (helper(graph, i, visited)) {
                // 安全就将visited[i]的值置为3
                visited[i] = 3;
                
				// 将i加入结果集合中
                res.add(i);
            }
        }

        return res;
    }
	
    /**
     * 递归判断第idx个节点是否安全
     * 安全返回true，否则返回false
     */
    private boolean helper(int[][] graph, int idx, int[] visited) {
        // visited[i] == 1表示已访问
        if ((visited[idx] & 1) == 1) {
            // 已访问且visited[i] == 3才表示安全
            return visited[idx] == 3;
        }

        int[] targets = graph[idx];
        // targets为空
        if (targets == null || targets.length == 0) {
            // 表示当前节点不能通向其它节点
            // 当前节点安全
            return true;
        }

        // 将当前节点标记为已访问
        visited[idx] = 1;
        for (int target : targets) {
            // 如果当前节点等于目标节点
            if (idx == target) {
                // 表示当前节点形成了自环
                // 不安全，返回false
                return false;
            }

            // 在判断当前节点连通的其它节点是否安全
            if (helper(graph, target, visited)) {
                // 当前节点通向target是安全的
                // 那么将visited[target]置为3标记target节点也安全
                visited[target] = 3;
            } else {
                // 只要有一个通向的节点不安全，那么当前节点就不安全
                return false;
            }
        }

        // 只有通向的所有节点都是安全的，当前节点才安全
        return true;
    }
}
```

## 20210806 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 847. 访问所有节点的最短路径

原题链接：[847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)

> 存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。
>
> 给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。
>
> 返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。
>
> 提示：
>
> n == graph.length
> 1 <= n <= 12
> 0 <= graph[i].length < n
> graph[i] 不包含 i
> 如果 graph[a] 包含 b ，那么 graph[b] 也包含 a
> 输入的图总是连通图

### 1.状态压缩 + 广度优先搜索

[参考题解](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/solution/fang-wen-suo-you-jie-dian-de-zui-duan-lu-mqc2/)

``` java
class Solution {
    public int shortestPathLength(int[][] graph) {
        int n = graph.length;
        Queue<int[]> queue = new LinkedList<int[]>();
        boolean[][] seen = new boolean[n][1 << n];
        for (int i = 0; i < n; ++i) {
            queue.offer(new int[]{i, 1 << i, 0});
            seen[i][1 << i] = true;
        }

        int ans = 0;
        while (!queue.isEmpty()) {
            int[] tuple = queue.poll();
            int u = tuple[0], mask = tuple[1], dist = tuple[2];
            if (mask == (1 << n) - 1) {
                ans = dist;
                break;
            }
            // 搜索相邻的节点
            for (int v : graph[u]) {
                // 将 mask 的第 v 位置为 1
                int maskV = mask | (1 << v);
                if (!seen[v][maskV]) {
                    queue.offer(new int[]{v, maskV, dist + 1});
                    seen[v][maskV] = true;
                }
            }
        }
        return ans;
    }
}
```

