# 20210601 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？

原题链接：[1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？](https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/)

> 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。
>
> 你按照如下规则进行一场游戏：
>
> 你从第 0 天开始吃糖果。
> 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。
> 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。
> 请你构建一个布尔型数组 answer ，用以给出 queries 中每一项的对应答案。此数组满足：
>
> answer.length == queries.length 。answer[i] 是 queries[i] 的答案。
> answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。

## 1.前缀和

参考题解：[1744 参考题解](https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/solution/ni-neng-zai-ni-zui-xi-huan-de-na-tian-ch-boa0/)

``` java
class Solution {
    public boolean[] canEat(int[] candiesCount, int[][] queries) {
        int m = candiesCount.length;
        long[] sum = new long[m];
        sum[0] = candiesCount[0];
        // 求前缀和
        for (int i = 1; i < m; i++) {
            sum[i] = sum[i - 1] + candiesCount[i];
        }

        int n = queries.length;
        boolean[] answer  = new boolean[n];
        for (int i = 0; i < n; i++) {
            int[] query = queries[i];
            int favoriteType = query[0], favoriteDay = query[1], dailyCap = query[2];

            // 到第 favoriteDay 天，最少吃掉 favoriteDay + 1 颗糖果
            long x1 = favoriteDay + 1;
            // 最多吃掉 (favoriteDay + 1) * dailyCap 颗糖果
            long y1 = (long)(favoriteDay + 1) * dailyCap;

            // 吃到第 favoriteType 种类型的糖果最少得吃 x2 颗糖果
            long x2 = favoriteType == 0 ? 1 : sum[favoriteType - 1] + 1;
            // 吃到第 favoriteType 种类型的糖果最多得吃 y2 颗糖果
            long y2 = sum[favoriteType];

            // [x1, y1] 与 [x2, y2] 两个区间有交集时才满足条件
            answer[i] = !(y1 < x2 || y2 < x1);
        }

        return answer;
    }
}
```

# 20210602 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 523. 连续的子数组和

原题链接：[523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

> 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：
>
> 子数组大小 至少为 2 ，且
> 子数组元素总和为 k 的倍数。
> 如果存在，返回 true ；否则，返回 false 。
>
> 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。

## 1.前缀和 + 哈希表

参考题解：[523 参考题解](https://leetcode-cn.com/problems/continuous-subarray-sum/solution/lian-xu-de-zi-shu-zu-he-by-leetcode-solu-rdzi/)

``` java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int length = nums.length;
        if (length <= 1) {
            return false;
        }

        // 用哈希表记录 (前缀和 % k) 以及对应下标 i 的映射关系
        Map<Integer, Integer> memory = new HashMap<>();
        memory.put(0, -1);
        int sum = 0;
        for (int i = 0; i < length; i++) {
            sum = (sum + nums[i]) % k;
            // 如果前缀和对 k 取余后的结果在之前出现过
            // 说明数组中存在和为 k 的倍数的连续数组
            if (memory.containsKey(sum)) {
                // 当前位置 i 和 之前 sum 出现的位置差距是否大于 2
                if (i - memory.get(sum) >= 2) {
                    // 大于 2 则满足条件，返回 true
                    return true;
                }
            } else {
                // 没出现过就保存 sum 和 i 的映射关系
                memory.put(sum, i);
            }
        }

        return false;
    }
}
```

# 20210603 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 525. 连续数组

原题链接：[525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/)

> 给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

## 1.前缀和 + 哈希表

参考题解：[525 参考题解](https://leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode-solution-mvnm/)

``` java
class Solution {
    public int findMaxLength(int[] nums) {
        int length = nums.length;
        
        // 用 -1 表示二进制的 0
        // 用 1 表示二进制的 1
        // 用哈希表记录前缀和以及对应下标 i 的映射关系
        Map<Integer, Integer> memory = new HashMap<>();
        memory.put(0, -1);

        int sum = 0, res = 0;
        for (int i = 0; i < length; i++) {
            sum += nums[i] == 0 ? -1 : 1;
			
            // 当 sum 在之前出现过时
            // 表示 memory.containsKey(sum) ~ i 之间的连续子数组中
            // 0 和 1 的数量是相同的
            if (memory.containsKey(sum)) {
                // 取连续子数组长度的最大值
                res = Math.max(res, i - memory.get(sum));
            } else {
                memory.put(sum, i);
            }
        }

        return res;
    }
}
```

# 20210604 <font color=#009975>E</font> <font color=#009975>S</font>

## 160. 相交链表

原题链接：[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
>
> 图示两个链表在节点 c1 开始相交：
>
> ![image-2021061311200006666.png](../../../../img/image-2021061311200006666.png)
>
> 题目数据 保证 整个链式结构中不存在环。
>
> 注意，函数返回结果后，链表必须 保持其原始结构 。

## 1.快慢指针

``` java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }

        ListNode node1 = headA;
        // 先跳到链表 headA 的末尾
        while (node1 != null && node1.next != null) {
            node1 = node1.next;
        }

        // 用链表 headA 的尾连着链表 headB 的头
        // 使两个链表形成一个环（如果两个链表有交点的话）
        node1.next = headB;

        // 利用快慢指针判断是否有环
        ListNode fast = headA, slow = headA;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            // 如果有环，快慢指针会相遇
            if (fast == slow) {
                break ;
            }
        }

        // 如果无环，则满足 fast.next == null || fast.next.next == null
        if (fast.next == null || fast.next.next == null) {
            node1.next = null;
			
            // 无环直接返回 null
            return null;
        }

        // 让 slow 从链表的 headA 的头结点开始
        // 和 fast 以同样的速度前进
        slow = headA;
        while (slow != fast) {
            // 当 slow == fast 时，就是两个链表相交的位置
            fast = fast.next;
            slow = slow.next;
        }

        // 断开链表，恢复原来的状态
        node1.next = null;
        return fast;
    }
```

# 20210605 <font color=#009975>E</font> <font color=#009975>S</font>

## 203. 移除链表元素

原题链接：[203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

## 1.迭代法

``` java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }

        // newHead 用来充当新节点，用来指向结果链表
        // 因为可能出现第一个节点值就等于 val 的情况
        ListNode newHead = new ListNode(), pre = newHead, node = head;
        // 直接遍历链表 head
        while (node != null) {
            // 如果当前节点的值等于 val
            if (node.val == val) {
                // 表示要删除当前节点 node
                // 所以先让 pre.next 指向 node.next
                pre.next = node.next;
                // node.next 置位 null，断开与后面节点的连接
                node.next = null;
                // 当前节点 node 跳到新的 next 节点
                node = pre.next;
                // 这一步 pre 不需要跳到下一个节点
                // 因为新的 next 节点值有可能还等于 val
            } else {
                // 不相等 pre 和 node 都跳到下一个节点
                pre.next = node;
                pre = pre.next;

                node = node.next;
            }
        }

        // newHead.next 就是新
        return newHead.next;
    }
}
```

# 20210606 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 474. 一和零

原题链接：[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

> 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
>
> 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。
>
> 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

## 1.动态规划

参考题解：[474 参考题解](https://leetcode-cn.com/problems/ones-and-zeroes/solution/yi-he-ling-by-leetcode-solution-u2z2/)

``` java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int length = strs.length;
        // dp[i][j][k] 表示在前 i 个字符串中
        // 使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量
        int[][][] dp = new int[length + 1][m + 1][n + 1];
        
        for (int i = 1; i <= length; i++) {
            String str = strs[i - 1];
            // 统计当前字符串 0 和 1 的数量
            int zeros = 0, ones = 0;
            for (int j = 0; j < str.length(); j++) {
                char c = str.charAt(j);
                if (c == '0') {
                    zeros++;
                } else {
                    ones++;
                }
            }

            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    // 如果 j < zeros 或 k < ones
                    // 则不能选第 i 个字符串，此时有 dp[i][j][k] = dp[i - 1][j][k]
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (j >= zeros && k >= ones) {
                        // 当 j >= zeros 或 k >= ones 时
                        // 如果不选第 i 个字符串，此时有 dp[i][j][k] = dp[i - 1][j][k]
                        // 如果选择第 i 个字符串
                        // 则有 dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)
                        // 选上面两项中最大值
                        dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1);
                    }
                }
            }
        }

        return dp[length][m][n];
    }
}
```

# 20210607 <font color=#ed7336>M</font> <font color=#009975>S</font>

## 494. 目标和

原题链接：[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

> 给你一个整数数组 nums 和一个整数 target 。
>
> 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：
>
> 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
> 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

## 1.递归法

``` java
class Solution {
    int count = 0;
    public int findTargetSumWays(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        findTargetSumWays(nums, target, 0, 0);
        
        return count;
    }

    /**
     * 递归函数
     * @param i 表示当前递归的位置
     * @param sum 表示当前递归的和
     */
    public void findTargetSumWays(int[] nums, int target, int i, int sum) {
         if (i == nums.length) {
             // 当前递归和 sum 等于目标
             if (target == sum) {
                // count 加一，计数一次
                count++;
             }
         } else {
             // 当前符号为 +
             findTargetSumWays(nums, target, i + 1, sum + nums[i]);
             // 当前符号为 -
             findTargetSumWays(nums, target, i + 1, sum - nums[i]);
         }
    }
}
```

# 20210608 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

## 1049. 最后一块石头的重量 II

原题链接：[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

> 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。
>
> 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
>
> 如果 x == y，那么两块石头都会被完全粉碎；
> 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
> 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

## 1.动态规划

参考题解：[1049 参考题解](https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/)

暂时还没有搞懂，先晾着

``` java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int length = stones.length;

        int sum = 0;
        for (int stone : stones) {
            sum += stone;
        }
        int t = sum / 2;
        int[][] dp = new int[length + 1][t + 1];

        for (int i = 1; i <= length; i++) {
            int stone = stones[i - 1];
            for (int j = 0; j <= t; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= stone) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - stone] + stone);
                }
            }
        }

        return Math.abs(sum - 2 * dp[length][t]);
    }
}
```

# 20210609 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

## 879. 盈利计划

原题链接：[879. 盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)

> 集团里有 n 名员工，他们可以完成各种各样的工作创造利润。
>
> 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。
>
> 工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。
>
> 有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。

## 1.动态规划

参考题解：[879 参考题解](https://leetcode-cn.com/problems/profitable-schemes/solution/gong-shui-san-xie-te-shu-duo-wei-fei-yon-7su9/)

还没有理解到题解的意思，暂时未写注释

``` java
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int mod = (int)1e9+7;
        int m = group.length;
        long[][][] dp = new long[m + 1][n + 1][minProfit + 1];
        for (int i = 0; i <= n; i++) {
            dp[0][i][0] = 1;
        }

        for (int i = 1; i <= m; i++) {
            int g = group[i - 1], p = profit[i - 1];
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k <= minProfit; k++) {
                    dp[i][j][k] = dp[i - 1][j][k];

                    if (j >= g) {
                        int u = Math.max(k - p, 0);
                        dp[i][j][k] += dp[i - 1][j - g][u];
                        if (dp[i][j][k] >= mod) {
                            dp[i][j][k] %= mod;
                        }
                    }
                }
            }
        }

        return (int)dp[m][n][minProfit];
    }
}
```

# 20210610 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 518. 零钱兑换 II

原题链接：[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

> 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

## 1.完全背包

参考题解：[518 参考题解](https://leetcode-cn.com/problems/coin-change-2/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-6hxv/)

``` java
class Solution {

    public int change(int amount, int[] coins) {
        int n = coins.length;
        // 定义 dp[i][j] 为考虑前 i 个硬币，凑成总和为 j 的方案数量
        int[][] dp = new int[n + 1][amount + 1];
        // 0 个硬币凑成 0 元的方案为 1
        dp[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            int val = coins[i - 1];
            for (int j = 0; j <= amount; j++) {
                // 不使用该硬币
                dp[i][j] = dp[i - 1][j];

                // 使用该硬币：由于每个硬币可以被选择多次（容量允许的情况下）
                // 因此方案数量应当是选择「任意个」该硬币的方案总和
                for (int k = 1; k * val <= j; k++) {
                    dp[i][j] += dp[i - 1][j - k * val];
                }
            }
        }

        return dp[n][amount];
    }
}
```

# 20210611 <font color=#ed7336>M</font> <font color=#009975>S</font>

## 279. 完全平方数

原题链接：[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

> 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
>
> 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
>
> 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

## 1.动态规划

``` java
class Solution {
    public int numSquares(int n) {
        // dp[i] 表示和为第 i 个正整数的完全平方数的最少数量
        int[] dp = new int[n + 1];
		// 因为要求最小值，所以这里给 dp 赋一个不可能的值作为最大值
        // 这里赋值 n + 1 是因为只有当完全平方数是 1 时，和为 n 的完全平方数最大为 n
        // 所以 n + 1 是不可能达到的值
        Arrays.fill(dp, n + 1);
        // 设定初始值，没有完全平方数的和为 0，所以 dp[0] = 0
        dp[0] = 0;

        // 自底向上
        // 从 1 开始计算和为 i 的完全平方数的最少数量
        for (int i = 1; i <= n; i++) {
            // 完全平方数肯定要小于 i
            for (int j = 1; j * j <= i; j++) {
                // 使用完全平方数 j * j，再在 dp[i - j * j] 基础上加 1
                // 每个完全平方数都用一遍，然后取最终组合的最小值
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }

        return dp[n];
    }
}
```

# 20210612 <font color=#ec4c47>H</font> <font color=#ed7336>R</font>

## 1449. 数位成本和为目标值的最大数字

原题链接：[1449. 数位成本和为目标值的最大数字](https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/)

> 给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：
>
> 给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。
> 总成本必须恰好等于 target 。
> 添加的数位中没有数字 0 。
> 由于答案可能会很大，请你以字符串形式返回。
>
> 如果按照上述要求无法得到任何整数，请你返回 "0" 。
>
>  
>
> 示例 1：
>
> 输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
> 输出："7772"
> 解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
>  数字     成本
>   1  ->   4
>   2  ->   3
>   3  ->   2
>   4  ->   5
>   5  ->   6
>   6  ->   7
>   7  ->   2
>   8  ->   5
>   9  ->   5

## 1.动态规划 + 贪心

参考题解：[1449 参考题解](https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/solution/gong-shui-san-xie-fen-liang-bu-kao-lu-we-uy4y/)

``` java
class Solution {
    public String largestNumber(int[] cost, int target) {
        // dp[i] 表示总成本为 i 时，需要最多的数位
        // 根据长度进行比较，长度较长数字较大
        int[] dp = new int[target + 1];
        Arrays.fill(dp, Integer.MIN_VALUE);
        dp[0] = 0;
        // 先求出总成本从 1 ~ target 所需要的最多数位
        for (int i = 1; i <= 9; i++) {
            int num = cost[i - 1];
            for (int j = num; j <= target; j++) {
                dp[j] = Math.max(dp[j], dp[j - num] + 1);
            }
        }

        // 如果无法 target 返回 "0"
        if (dp[target] < 0) {
            return "0";
        }

        String ans = "";
        // 对于长度相等的数值，从高位往低位进行比较
        // 找到第一位不同，不同位值大的数值较大
        for (int i = 9, j = target; i > 0; i--) {
            int num = cost[i - 1];
            // while 循环是可能会重复用到 num
            // dp[j] == dp[j - num] + 1 表示当前选择了 num
            while (j >= num && dp[j] == dp[j - num] + 1) {
                ans += String.valueOf(i);
                // 当前选择了 num 就要减掉
                j -= num;
            }
        }

        return ans;
    }
}
```

# 20210613 <font color=#009975>E</font> <font color=#009975>S</font>

## 278. 第一个错误的版本

原题链接：[278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

> 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
>
> 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
>
> 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

## 1.二分法

``` java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        // 二分法解决，将区间分为 [left, mid] 和 [mid + 1, right]
        int left = 1, right = n;
        while (left < right) {
            int mid = (left + right) >>> 1;
            // 如果 mid 是错误版本，则表示第一个错误版本在 [left, mid] 区间内
            if (isBadVersion(mid)) {
                // 所以收缩右边，让 right = mid
                right = mid;
            } else {
                // 否则表示第一个错误版本在 [mid + 1, right] 区间内
                // 所以收缩坐边，让 left = mid + 1
                left = mid + 1;
            }
        }
		
        // 最后 left == right，返回 left 或者 right 皆可
        return left;
    }
}
```

# 20210614 <font color=#009975>E</font> <font color=#009975>S</font>

## 374. 猜数字大小

原题链接：[374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

> 猜数字游戏的规则如下：
>
> 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
> 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
> 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：
>
> -1：我选出的数字比你猜的数字小 pick < num
> 1：我选出的数字比你猜的数字大 pick > num
> 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
> 返回我选出的数字。

## 1.二分法

``` java
public class Solution extends GuessGame {
    
    /**
     * 标准的二分法
     */
    public int guessNumber(int n) {
        int left = 1, right = n;
        while (left <= right) {
            int mid = (left + right) >>> 1;
            int guess = guess(mid);
            if (guess < 0) {
                right = mid - 1;
            } else if (guess > 0) {
                left = mid + 1;
            } else {
                return mid;
            }
        }

        return left;
    }
}
```

# 20210615 <font color=#009975>E</font> <font color=#009975>S</font>

## 852. 山脉数组的峰顶索引

原题链接：[852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

> 符合下列属性的数组 arr 称为 山脉数组 ：
> arr.length >= 3
> 存在 i（0 < i < arr.length - 1）使得：
> arr[0] < arr[1] < ... arr[i-1] < arr[i]
> arr[i] > arr[i+1] > ... > arr[arr.length - 1]
> 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。

## 1.暴力求解

``` java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int length = arr.length;
        
        int res = 0;
        // 求出 arr[i] 同时大于 arr[i - 1] 和 arr[i + 1] 即可
        for (int i = 1; i < length - 1; i++) {
            if (arr[i] > arr[i - 1] && arr[i] > arr[i + 1]) {
                res = i;
            }
        }

        return res;
    }
}
```

## 2.二分法

``` java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int length = arr.length;
        
		// 将区间分为 [left, mid] 和 [mid + 1, right]
        int left = 0, right = length - 1;
        while (left < right) {
            int mid = (left + right) >>> 1;
            // 通过比较 arr[mid] 和 arr[mid + 1]
            // 来确定 arr[mid] 是在山峰左边还是右边
            if (arr[mid] < arr[mid + 1]) {
                // arr[mid] < arr[mid + 1] 说明 arr[mid] 在山峰的左边
                // 缩小左边的范围
                left = mid + 1;
            } else {
                // 否则缩小右边的范围
                right = mid;
            }
        }

        return left;
    }
}
```

# 20210616 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 877. 石子游戏

原题链接：[877. 石子游戏](https://leetcode-cn.com/problems/stone-game/)

> 亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。
>
> 游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。
>
> 亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。
>
> 假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。

## 1.博弈论

参考题解：[877 参考题解](https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode-solution/)

``` java
class Solution {
    
    /**
     * 先手必胜
     */
    public boolean stoneGame(int[] piles) {
        return true;
    }
}
```

## 2.动态规划 <font color=#ec4c47>U</font>

参考题解：[877 参考题解](https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode-solution/)

``` java
class Solution {
    public boolean stoneGame(int[] piles) {
        int length = piles.length;
        int[][] dp = new int[length][length];
        for (int i = 0; i < length; i++) {
            dp[i][i] = piles[i];
        }
        for (int i = length - 2; i >= 0; i--) {
            for (int j = i + 1; j < length; j++) {
                dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);
            }
        }
        return dp[0][length - 1] > 0;
    }
}
```

# 20210617 <font color=#ec4c47>H</font> <font color=#ed7336>R</font>

## 65. 有效数字

原题链接：[65. 有效数字](https://leetcode-cn.com/problems/valid-number/)

> 有效数字（按顺序）可以分成以下几个部分：
>
> 一个 小数 或者 整数
> （可选）一个 'e' 或 'E' ，后面跟着一个 整数
> 小数（按顺序）可以分成以下几个部分：
>
> （可选）一个符号字符（'+' 或 '-'）
> 下述格式之一：
> 至少一位数字，后面跟着一个点 '.'
> 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
> 一个点 '.' ，后面跟着至少一位数字
> 整数（按顺序）可以分成以下几个部分：
>
> （可选）一个符号字符（'+' 或 '-'）
> 至少一位数字
> 部分有效数字列举如下：
>
> ["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]
> 部分无效数字列举如下：
>
> ["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]
> 给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。

## 1.模拟

参考题解：[65 参考题解](https://leetcode-cn.com/problems/valid-number/solution/gong-shui-san-xie-zi-fu-chuan-mo-ni-by-a-7cgc/)

``` java
class Solution {
    public boolean isNumber(String s) {
        int n = s.length();
        char[] cs = s.toCharArray();
        int idx = -1;
        for (int i = 0; i < n; i++) {
            if (cs[i] == 'e' || cs[i] == 'E') {
                if (idx == -1) idx = i;
                else return false;
            }
        }
        boolean ans = true;
        if (idx != -1) {
            ans &= check(cs, 0, idx - 1, false);
            ans &= check(cs, idx + 1, n - 1, true);
        } else {
            ans &= check(cs, 0, n - 1, false);
        }
        return ans;
    }
    
    boolean check(char[] cs, int start, int end, boolean mustInteger) {
        if (start > end) return false;
        if (cs[start] == '+' || cs[start] == '-') start++;
        boolean hasDot = false, hasNum = false;
        for (int i = start; i <= end; i++) {
            if (cs[i] == '.') {
                if (mustInteger || hasDot) return false;
                hasDot = true;
            } else if (cs[i] >= '0' && cs[i] <= '9') {
                hasNum = true;
            } else {
                return false;
            }
        }
        return hasNum;
    }
}
```

# 20210618 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

## 483. 最小好进制

原题链接：[483. 最小好进制](https://leetcode-cn.com/problems/smallest-good-base/)

> 对于给定的整数 n, 如果n的k（k>=2）进制数的所有数位全为1，则称 k（k>=2）是 n 的一个好进制。
>
> 以字符串的形式给出 n, 以字符串的形式返回 n 的最小好进制。

## 1.数学

参考题解：[483 参考题解](https://leetcode-cn.com/problems/smallest-good-base/solution/gong-shui-san-xie-xiang-jie-ru-he-fen-xi-r94g/)

``` java
class Solution {
    public String smallestGoodBase(String n) {
        long m = Long.parseLong(n);
        int max = (int)(Math.log(m) / Math.log(2) + 1);
        for (int len = max; len >= 3; len--) {
            long k = (long)Math.pow(m, 1.0 / (len - 1));
            long res = 0;
            for (int i = 0; i < len; i++) res = res * k + 1;
            if (res == m) return String.valueOf(k);
        }
        return String.valueOf(m - 1);
    }
}
```

# 20210619 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 1239. 串联字符串的最大长度

原题链接：[1239. 串联字符串的最大长度](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/)

> 给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。
>
> 请返回所有可行解 s 中最长长度。

## 1.回溯 + 位运算

参考题解：[1239 参考题解](https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solution/chuan-lian-zi-fu-chuan-de-zui-da-chang-d-g6gk/)

``` java
class Solution {
    int ans = 0;
    public int maxLength(List<String> arr) {
        // 用于保存没有重复字符的字符串
        List<Integer> list = new ArrayList<>();
        
        for (String str : arr) {
            int mask = 0;
            for (int i = 0; i < str.length(); i++) {
                int ch = str.charAt(i) - 'a';
                // 若 mask 已有 ch，则说明 str 含有重复字母，无法构成可行解
                if (((mask >> ch) & 1) != 0) {
                    mask = 0;

                    break ;
                }

                // 将 ch 加入 mask 中
                mask |= 1 << ch;
            }

            if (mask > 0) {
                list.add(mask);
            }
        }

        helper(list, 0, 0);

        return ans;
    }

    private void helper(List<Integer> list, int pos, int mask) {
        if (pos == list.size()) {
            ans = Math.max(ans, Integer.bitCount(mask));

            return ;
        }

        // mask 和 list[pos] 无公共元素
        if ((mask & list.get(pos)) == 0) {
            helper(list, pos + 1, mask | list.get(pos));
        }

        helper(list, pos + 1, mask);
    }
}
```

# 20210620 <font color=#ed7336>M</font> <font color=#009975>S</font>

## 1600. 皇位继承顺序

原题链接：[1600. 皇位继承顺序](https://leetcode-cn.com/problems/throne-inheritance/)

> 一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。
>
> 这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。
>
> Successor(x, curOrder):
>     如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：
>         如果 x 是国王，那么返回 null
>         否则，返回 Successor(x 的父亲, curOrder)
>     否则，返回 x 不在 curOrder 中最年长的孩子
> 比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。
>
> 1. 一开始， curOrder 为 ["king"]。
> 2. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 ["king", "Alice"] 。
> 3. 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 ["king", "Alice", "Jack"] 。
> 4. 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 ["king", "Alice", "Jack", "Bob"] 。
> 5. 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 ["king", "Alice", "Jack", "Bob"] 。
>    通过以上的函数，我们总是能得到一个唯一的继承顺序。
>
> 请你实现 ThroneInheritance 类：
>
> - ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。
> - void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。
> - void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。
> - string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。

## 1.先序遍历

``` java
class ThroneInheritance {

    // 当前的国王
    private Person king;

    // 名字和 Person 对象的映射关系
    private Map<String, Person> map;

    /**
     * 定义 Person 类
     * 用来维护名字和孩子以及是否在世状态的关系
     */
    private class Person {
        // 名字
        private String name;
		// 孩子
        private List<Person> children;
		// 是否在世
        private boolean alive;

        public Person(String name) {
            this.name = name;
            this.alive = true;
            this.children = new ArrayList<>();
        }
    }

    public ThroneInheritance(String kingName) {
        this.king = new Person(kingName);
        this.map = new HashMap<>();
        this.map.put(kingName, this.king);
    }
    
    public void birth(String parentName, String childName) {
        // 先通过名字找到对应的人
        Person parent = map.get(parentName);
        if (parent == null) {
            return ;
        }
		// 创建 Person 对象，放到对应的孩子列表中
        Person child = new Person(childName);
        parent.children.add(child);
        // 维护 child 的名字和对象关系到 map 中
        map.put(childName, child);
    }
    
    public void death(String name) {
        Person person = map.get(name);
        if (person == null) {
            return ;
        }

        // 将在世状态标记为 false，表示去世了
        person.alive = false;
    }
    
    public List<String> getInheritanceOrder() {
        List<String> resList = new ArrayList<>();
        List<Person> persons = new ArrayList<>();
        persons.add(king);

        successor(persons, resList);

        return resList;
    }

    /**
     * 先序遍历整个继承关系
     */
    private void successor(List<Person> persons, List<String> resList) {
        if (persons == null || persons.size() == 0) {
            return ;
        }

        // 先自己，再孩子
        for (Person person : persons) {
            // 还在世，才加入
            if (person.alive) {
                resList.add(person.name);
            }
			// 遍历孩子列表
            successor(person.children, resList);
        }
    }
}
```

# 20210621 <font color=#009975>E</font> <font color=#009975>S</font>

## 401. 二进制手表

原题链接：[401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

> 二进制手表顶部有 4 个 LED 代表 **小时（0-11）**，底部的 6 个 LED 代表 **分钟（0-59）**。每个 LED 代表一个 0 或 1，最低位在右侧。

## 1.枚举时分

`Integer.bitCount(x)`：返回指定 int 值的二进制补码表示中的 `1` 位数。

``` java
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        List<String> res = new ArrayList<>();
        // 枚举时分
        for (int h = 0; h < 12; h++) {
            for (int m = 0; m < 60; m++) {
                // 统计时分表示的二进制 1 的位数加起来等于 turnedOn 的组合
                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {
                    res.add(h + ":" + (m < 10 ? "0" + m : m));
                }
            }
        }

        return res;
    }
}
```

# 20210622 <font color=#ed7336>M</font> <font color=#009975>S</font>

## 剑指 Offer 38. 字符串的排列

原题链接：[剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

> 输入一个字符串，打印出该字符串中字符的所有排列。
>
> 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

## 1.递归+集合

``` java
class Solution {
    public String[] permutation(String s) {
        // 用于记录已经使用过的字符
        boolean[] visited = new boolean[s.length()];
        // 用集合保存结果以去重
        Set<String> res = new HashSet<>();
        // 递归
        helper(s, visited, "", res);

        // 将结果转换为数组
        String[] strings = new String[res.size()];
        int i = 0;
        for (String str : res) {
            strings[i++] = str;
        }

        return strings;
    }

    /**
     * 递归生成所有组合
     * @param s 原字符串
     * @param visited 记录已使用的字符
     * @param t 当前生成的字符串
     * @param res 结果集
     */
    private void helper(String s, boolean[] visited, String t, Set<String> res) {
		// 原字符串长度和当前生成的字符串长度相等
        // 表示这一轮递归结束
        if (s.length() == t.length()) {
			// 将当前生成的字符串加入结果集
            res.add(t);

            return ;
        }

        // 递归
        for (int i = 0; i < s.length(); i++) {
            // 没有使用过的字符才递归
            if (!visited[i]) {
                visited[i] = true;
                helper(s, visited, t + s.charAt(i), res);
                visited[i] = false;
            }
        }
    }
}
```

# 20210623 <font color=#009975>E</font> <font color=#009975>S</font>

## 剑指 Offer 15. 二进制中1的个数

原题链接：[剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

> 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

## 1.位运算

[bitCount 方法解析](https://segmentfault.com/a/1190000015763941)

``` java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        return Integer.bitCount(n);
    }
    
    public static int bitCount(int i) {
        // HD, Figure 5-2
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    }
}
```

# 20210624 <font color=#ec4c47>H</font> <font color=#ed7336>R</font>

## 149. 直线上最多的点数

原题链接：[149. 直线上最多的点数](https://leetcode-cn.com/problems/max-points-on-a-line/)

> 给你一个数组 `points` ，其中 `points[i] = [xi, yi]` 表示 **X-Y** 平面上的一个点。求最多有多少个点在同一条直线上。

## 1.枚举法

参考题解：[149 参考题解](https://leetcode-cn.com/problems/max-points-on-a-line/solution/gong-shui-san-xie-liang-chong-mei-ju-zhi-u44s/)

``` java
class Solution {
    public int maxPoints(int[][] points) {
        int length = points.length;
        int ans = 1;

        for (int i = 0; i < length; i++) {
            int[] x = points[i];
            for (int j = i + 1; j < length; j++) {
                int[] y = points[j];
                int count = 2;
                for (int k = j + 1; k < length; k++) {
                    int[] z = points[k];
                    // 当两条直线的斜率相等时，要么平行，要么重合
                    // 因为这里只有三个点，所以斜率相等是重合，三个点在同一直线上
                    // 即：(x[0] - y[0]) / (x[1] - y[1]) = (x[0] - z[0]) / (x[1] - z[1])
                    // 为了避免出现除法精度问题，这里将公式变换一下
                    int s1 = (x[0] - y[0]) * (x[1] - z[1]);
                    int s2 = (x[0] - z[0]) * (x[1] - y[1]);
                    // 如果 s1 == s2，即表示三点在同一直线上
                    if (s1 == s2) {
                        count++;
                    }
                }

                ans = Math.max(ans, count);
            }
        }

        return ans;
    }
}
```

# 20210625 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

## 752. 打开转盘锁

原题链接：[752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/)

> 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。
>
> 锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。
>
> 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
>
> 字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。

## 1.BFS

参考题解：[752 参考题解](https://leetcode-cn.com/problems/open-the-lock/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-wyr9/)

``` java
class Solution {
    String t, s;
    Set<String> set = new HashSet<>();
    public int openLock(String[] deadends, String target) {
        s = "0000";
        t = target;
        if (s.equals(t)) {
            return 0;
        }

        for (String d : deadends) {
            set.add(d);
        }

        if (set.contains(s)) {
            return -1;
        }

        int ans = bfs();
        
        return ans;
    }

    int bfs() {
        // d1 代表从起点 s 开始搜索（正向）
        // d2 代表从结尾 t 开始搜索（反向）
        Deque<String> d1 = new ArrayDeque<>(), d2 = new ArrayDeque<>();
        /*
         * m1 和 m2 分别记录两个方向出现的状态是经过多少次转换而来
         * e.g.
         * m1 = {"1000":1} 代表 "1000" 由 s="0000" 旋转 1 次而来
         * m2 = {"9999":3} 代表 "9999" 由 t="9996" 旋转 3 次而来
         */
        Map<String, Integer> m1 = new HashMap<>(), m2 = new HashMap<>();
        d1.addLast(s);
        m1.put(s, 0);
        d2.addLast(t);
        m2.put(t, 0);

        /*
         * 只有两个队列都不空，才有必要继续往下搜索
         * 如果其中一个队列空了，说明从某个方向搜到底都搜不到该方向的目标节点
         * e.g. 
         * 例如，如果 d1 为空了，说明从 s 搜索到底都搜索不到 t，反向搜索也没必要进行了
         */
        while (!d1.isEmpty() && !d2.isEmpty()) {
            int t = -1;
            if (d1.size() <= d2.size()) {
                t = update(d1, m1, m2);
            } else {
                t = update(d2, m2, m1);
            }
            if (t != -1) return t;
        }
        return -1;       
    }

    int update(Deque<String> deque, Map<String, Integer> cur, Map<String, Integer> other) {
        String poll = deque.pollFirst();
        char[] pcs = poll.toCharArray();
        int step = cur.get(poll);
        // 枚举替换哪个字符
        for (int i = 0; i < 4; i++) {
            // 能「正向转」也能「反向转」，这里直接枚举偏移量 [-1,1] 然后跳过 0
            for (int j = -1; j <= 1; j++) {
                if (j == 0) continue;

                // 求得替换字符串 str
                int origin = pcs[i] - '0';
                int next = (origin + j) % 10;
                if (next == -1) next = 9;

                char[] clone = pcs.clone();
                clone[i] = (char)(next + '0');
                String str = String.valueOf(clone);

                if (set.contains(str)) continue;
                if (cur.containsKey(str)) continue;

                // 如果在「另一方向」找到过，说明找到了最短路，否则加入队列
                if (other.containsKey(str)) { 
                    return step + 1 + other.get(str);
                } else {
                    deque.addLast(str);
                    cur.put(str, step + 1);
                }
            }
        }
        return -1;
    }
}
```

# 20210626 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

## 773. 滑动谜题

原题链接：[773. 滑动谜题](https://leetcode-cn.com/problems/sliding-puzzle/)

> 在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.
>
> 一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.
>
> 最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。
>
> 给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。

## 1.BFS

参考题解：[773 参考题解](https://leetcode-cn.com/problems/sliding-puzzle/solution/gong-shui-san-xie-fa-hui-a-suan-fa-zui-d-3go8/)

``` java
class Solution {
    class Node {
        String str;
        int x, y;
        Node(String _str, int _x, int _y) {
            str = _str; x = _x; y = _y;
        }
    }
    int n = 2, m = 3;
    String s, e;
    int x, y;
    public int slidingPuzzle(int[][] board) {
        s = "";
        e = "123450";
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                s += board[i][j];
                if (board[i][j] == 0) {
                    x = i; y = j;
                }
            }
        }
        int ans = bfs();
        return ans;
    }
    int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
    int bfs() {
        Deque<Node> d = new ArrayDeque<>();
        Map<String, Integer> map = new HashMap<>();
        Node root = new Node(s, x, y);
        d.addLast(root);
        map.put(s, 0);
        while (!d.isEmpty()) {
            Node poll = d.pollFirst();
            int step = map.get(poll.str);
            if (poll.str.equals(e)) return step;
            int dx = poll.x, dy = poll.y;
            for (int[] di : dirs) {
                int nx = dx + di[0], ny = dy + di[1];
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                String nStr = update(poll.str, dx, dy, nx, ny);      
                if (map.containsKey(nStr)) continue;          
                Node next = new Node(nStr, nx, ny);
                d.addLast(next);
                map.put(nStr, step + 1);
            }
        }
        return -1;
    }
    String update(String cur, int i, int j, int p, int q) {
        char[] cs = cur.toCharArray();
        char tmp = cs[i * m + j];
        cs[i * m + j] = cs[p * m + q];
        cs[p * m + q] = tmp;
        return String.valueOf(cs);
    }
}
```

# 20210627 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 909. 蛇梯棋

原题链接：[909. 蛇梯棋](https://leetcode-cn.com/problems/snakes-and-ladders/)

> N x N 的棋盘 board 上，按从 1 到 N*N 的数字给方格编号，编号 从左下角开始，每一行交替方向。
>
> 例如，一块 6 x 6 大小的棋盘，编号如下：
>
>
> r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。
>
> 玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。
>
> 每一回合，玩家需要从当前方格 x 开始出发，按下述要求前进：
>
> ![image-202106271218006666.png](../../../../img/image-202106271218006666.png)
>
> 选定目标方格：选择从编号 x+1，x+2，x+3，x+4，x+5，或者 x+6 的方格中选出一个目标方格 s ，目标方格的编号 <= N*N。
> 该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 [x+1, x+6] 之间。
> 传送玩家：如果目标方格 S 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 S。 
> 注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。
>
> 返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。

## 1.BFS

参考题解：[909 参考题解](https://leetcode-cn.com/problems/snakes-and-ladders/solution/gong-shui-san-xie-bfs-mo-ni-by-ac_oier-woh6/)

``` java
class Solution {
    public int snakesAndLadders(int[][] board) {
        int n = board.length;
        // 用来将 N * N 的棋盘从 1 ~  N * N 保存到一维的 nums 中
        int[] nums = new int[n * n + 1];
        boolean right = true;
        for (int i = n - 1,  pos = 1; i >= 0; i--) {
            for (int j = (right ? 0 : n - 1); right ? j < n : j >= 0; j += (right ? 1: -1)) {
                nums[pos++] = board[i][j];
            }

            right = !right;
        }

        return bfs(nums, n);
    }

    private int bfs(int[] nums, int n) {
        // 广度优先遍历顺序
        LinkedList<Integer> queue = new LinkedList<>();
        // 保存第 i 个位置时，移动的次数
        Map<Integer, Integer> map = new HashMap<>();
        queue.addLast(1);
        map.put(1, 0);

        while(!queue.isEmpty()) {
            int cur = queue.removeFirst();
            int count = map.get(cur);
            // 到达目的地，返回最终次数
            if (cur == n * n) {
                return count;
            }

            // 表示从编号 x+1，x+2，x+3，x+4，x+5
            // 或者 x+6 的方格中选出一个目标方格 s
            for (int i = 1; i <= 6; i++) {
                int next = cur + i;

                // 超出范围，跳过
                if (next <= 0 || next > n * n) {
                    continue ;
                }

                // 遇到蛇或梯子
                if (nums[next] != -1) {
                    // 直接跳到对应的位置
                    next = nums[next];
                }

                // 之前到达过，就不在走了
                if (map.containsKey(next)) {
                    continue ;
                }

                // 保存到达当前目的地所需要移动的次数
                map.put(next, count + 1);
                queue.addLast(next);
            }
        }

        return -1;
    }
}
```

# 20210628 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

## 815. 公交路线

原题链接：[815. 公交路线](https://leetcode-cn.com/problems/bus-routes/)

> 给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
>
> 例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
> 现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
>
> 求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。

## 1.BFS

参考题解：[815 参考题解](https://leetcode-cn.com/problems/bus-routes/solution/gong-shui-san-xie-yi-ti-shuang-jie-po-su-1roh/)

``` java
class Solution {
    int s, t;
    int[][] rs;
    public int numBusesToDestination(int[][] routes, int source, int target) {
        rs = routes; s = source; t = target;
        if (s == t) return 0;
        int ans = bfs();
        return ans;
    }
    
    int bfs() {
        // 记录某个车站可以进入的路线
        Map<Integer, Set<Integer>> map = new HashMap<>();
        // 队列存的是经过的路线
        Deque<Integer> d = new ArrayDeque<>();
        // 哈希表记录的进入该路线所使用的距离
        Map<Integer, Integer> m = new HashMap<>();
        int n = rs.length;
        for (int i = 0; i < n; i++) {
            for (int station : rs[i]) {
                // 将从起点可以进入的路线加入队列
                if (station == s) {
                    d.addLast(i);
                    m.put(i, 1);
                }
                Set<Integer> set = map.getOrDefault(station, new HashSet<>());
                set.add(i);
                map.put(station, set);
            }
        }
        while (!d.isEmpty()) {
            // 取出当前所在的路线，与进入该路线所花费的距离
            int poll = d.pollFirst();
            int step = m.get(poll);

            // 遍历该路线所包含的车站
            for (int station : rs[poll]) {
                // 如果包含终点，返回进入该路线花费的距离即可
                if (station == t) return step;

                // 将由该线路的车站发起的路线，加入队列
                Set<Integer> lines = map.get(station);
                if (lines == null) continue;
                for (int nr : lines) {
                    if (!m.containsKey(nr)) {
                        m.put(nr, step + 1);
                        d.add(nr);
                    }
                }
            }
        }
        return -1;
    }
}
```

# 20210629 <font color=#009975>E</font> <font color=#ed7336>R</font>

## 168. Excel表列名称

原题链接：[168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

> 给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。
>
> 例如：
>
> A -> 1
> B -> 2
> C -> 3
> ...
> Z -> 26
> AA -> 27
> AB -> 28 
> ...

## 1.模拟

参考题解：[168 参考题解](https://leetcode-cn.com/problems/excel-sheet-column-title/solution/gong-shui-san-xie-cong-1-kai-shi-de-26-j-g2ur/)

``` java
class Solution {
    public String convertToTitle(int columnNumber) {
        StringBuilder str = new StringBuilder();

        while (columnNumber > 0) {
            // 因为是从1开始的所以这里先减去1
            // 整体偏移
            columnNumber--;
            // 取余
            str.append((char) ('A' + columnNumber % 26));
            // 再相除
            columnNumber /= 26;
        }
        // 反转
        str.reverse();
        
        return str.toString();
    }
}
```

