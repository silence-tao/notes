# MySQL索引优化总结

1. 如果MySQL估计使用索引比全表扫描还慢，则不会使用索引；
2. 前导模糊查询不能命中索引,在做模糊查询时,不要把通配符放在最前面,否则不会命中索引；
3. 数据类型出现隐式转换的时候不会命中索引，特别是当列类型是字符串，一定要将字符常量值用引号引起来；
4. 复合索引的情况下，查询条件不包含索引列最左边部分（不满足最左原则），不会命中符合索引；
5. union、in、or 都能够命中索引，建议使用 in，查询 CPU 消耗：or>in>union；
6. 用or分割开的条件，如果or前的条件中列有索引，而后面的列中没有索引，那么涉及到的索引都不会被用到;
7. 负向条件查询不能使用索引，可以优化为in查询,负向条件有：!=、<>、not in、not exists、not like等；
8. 范围条件查询可以命中索引。范围条件有：<、<=、>、>=、between等。
9. 数据库执行计算不会命中索引,不要查询条件中使用表达式；
10. 利用覆盖索引进行查询，避免回表；
11. 建立索引的列，不允许为null；
12. 更新十分频繁的字段上不宜建立索引：因为更新操作会变更B+树，重建索引。这个过程是十分消耗数据库性能的；
13. 区分度不大的字段上不宜建立索引：类似于性别这种区分度不大的字段，建立索引的意义不大。因为不能有效过滤数据，性能和全表扫描相当。另外返回数据的比例在30%以外的情况下，优化器不会选择使用索引；
14. 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。虽然唯一索引会影响insert速度，但是对于查询的速度提升是非常明显的。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，在并发的情况下，依然有脏数据产生；
15. 多表关联时，要保证关联字段上一定有索引；
16. 创建索引时避免以下错误观念：索引越多越好，认为一个查询就需要建一个索引；宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度；抵制唯一索引，认为业务的唯一性一律需要在应用层通过“先查后插”方式解决；过早优化，在不了解系统的情况下就开始优化；
17. 没有太大的必要使用DECIMAL数据类型。即使是在需要存储财务数据时，仍然可以使用BIGINT。比如需要精确到万分之一，那么可以将数据乘以一百万然后使用BIGINT存储。这样可以避免浮点数计算不准确和DECIMAL精确计算代价高的问题；
18. 当只要一行数据时使用LIMIT 1。
19. 表字段避免null值出现，null值很难查询优化且占用额外的索引空间，推荐默认数字0代替null。
20. 尽量使用INT而非BIGINT，如果非负则加上UNSIGNED(这样数值容量会扩大一倍)，当然能使用TINYINT、SMALLINT、MEDIUM_INT更好。
21. 时间类型转化为时间戳格式,用int类型储存,建索引增加查询效率。
22. 使用TINYINT类型代替枚举ENUM。
23. 存储精确浮点数必须使用DECIMAL替代FLOAT和DOUBLE。
24. 尽量不要使用TEXT类型，如必须使用建议将不常用的大字段拆分到其它表；
25. 单表不要有太多字段，建议在20以内；
26. 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描；
27. 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描；
28. 字符字段只建前缀索引，字符字段不要做主键；
29. 不用外键，由程序保证约束，
30. 尽量不用UNIQUE，由程序保证约束；
31. 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引；

> 后续总结再补充