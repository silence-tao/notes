# 20210601 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？

原题链接：[1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？](https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/)

> 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。
>
> 你按照如下规则进行一场游戏：
>
> 你从第 0 天开始吃糖果。
> 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。
> 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。
> 请你构建一个布尔型数组 answer ，用以给出 queries 中每一项的对应答案。此数组满足：
>
> answer.length == queries.length 。answer[i] 是 queries[i] 的答案。
> answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。

## 1.前缀和

参考题解：[1744 参考题解](https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/solution/ni-neng-zai-ni-zui-xi-huan-de-na-tian-ch-boa0/)

``` java
class Solution {
    public boolean[] canEat(int[] candiesCount, int[][] queries) {
        int m = candiesCount.length;
        long[] sum = new long[m];
        sum[0] = candiesCount[0];
        // 求前缀和
        for (int i = 1; i < m; i++) {
            sum[i] = sum[i - 1] + candiesCount[i];
        }

        int n = queries.length;
        boolean[] answer  = new boolean[n];
        for (int i = 0; i < n; i++) {
            int[] query = queries[i];
            int favoriteType = query[0], favoriteDay = query[1], dailyCap = query[2];

            // 到第 favoriteDay 天，最少吃掉 favoriteDay + 1 颗糖果
            long x1 = favoriteDay + 1;
            // 最多吃掉 (favoriteDay + 1) * dailyCap 颗糖果
            long y1 = (long)(favoriteDay + 1) * dailyCap;

            // 吃到第 favoriteType 种类型的糖果最少得吃 x2 颗糖果
            long x2 = favoriteType == 0 ? 1 : sum[favoriteType - 1] + 1;
            // 吃到第 favoriteType 种类型的糖果最多得吃 y2 颗糖果
            long y2 = sum[favoriteType];

            // [x1, y1] 与 [x2, y2] 两个区间有交集时才满足条件
            answer[i] = !(y1 < x2 || y2 < x1);
        }

        return answer;
    }
}
```

# 20210602 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 523. 连续的子数组和

原题链接：[523. 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

> 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：
>
> 子数组大小 至少为 2 ，且
> 子数组元素总和为 k 的倍数。
> 如果存在，返回 true ；否则，返回 false 。
>
> 如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。

## 1.前缀和 + 哈希表

参考题解：[523 参考题解](https://leetcode-cn.com/problems/continuous-subarray-sum/solution/lian-xu-de-zi-shu-zu-he-by-leetcode-solu-rdzi/)

``` java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int length = nums.length;
        if (length <= 1) {
            return false;
        }

        // 用哈希表记录 (前缀和 % k) 以及对应下标 i 的映射关系
        Map<Integer, Integer> memory = new HashMap<>();
        memory.put(0, -1);
        int sum = 0;
        for (int i = 0; i < length; i++) {
            sum = (sum + nums[i]) % k;
            // 如果前缀和对 k 取余后的结果在之前出现过
            // 说明数组中存在和为 k 的倍数的连续数组
            if (memory.containsKey(sum)) {
                // 当前位置 i 和 之前 sum 出现的位置差距是否大于 2
                if (i - memory.get(sum) >= 2) {
                    // 大于 2 则满足条件，返回 true
                    return true;
                }
            } else {
                // 没出现过就保存 sum 和 i 的映射关系
                memory.put(sum, i);
            }
        }

        return false;
    }
}
```

# 20210603 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 525. 连续数组

原题链接：[525. 连续数组](https://leetcode-cn.com/problems/contiguous-array/)

> 给定一个二进制数组 `nums` , 找到含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

## 1.前缀和 + 哈希表

参考题解：[525 参考题解](https://leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode-solution-mvnm/)

``` java
class Solution {
    public int findMaxLength(int[] nums) {
        int length = nums.length;
        
        // 用 -1 表示二进制的 0
        // 用 1 表示二进制的 1
        // 用哈希表记录前缀和以及对应下标 i 的映射关系
        Map<Integer, Integer> memory = new HashMap<>();
        memory.put(0, -1);

        int sum = 0, res = 0;
        for (int i = 0; i < length; i++) {
            sum += nums[i] == 0 ? -1 : 1;
			
            // 当 sum 在之前出现过时
            // 表示 memory.containsKey(sum) ~ i 之间的连续子数组中
            // 0 和 1 的数量是相同的
            if (memory.containsKey(sum)) {
                // 取连续子数组长度的最大值
                res = Math.max(res, i - memory.get(sum));
            } else {
                memory.put(sum, i);
            }
        }

        return res;
    }
}
```

# 20210604 <font color=#009975>E</font> <font color=#009975>S</font>

## 160. 相交链表

原题链接：[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
>
> 图示两个链表在节点 c1 开始相交：
>
> ![image-2021061311200006666.png](../../../../img/image-2021061311200006666.png)
>
> 题目数据 保证 整个链式结构中不存在环。
>
> 注意，函数返回结果后，链表必须 保持其原始结构 。

## 1.快慢指针

``` java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }

        ListNode node1 = headA;
        // 先跳到链表 headA 的末尾
        while (node1 != null && node1.next != null) {
            node1 = node1.next;
        }

        // 用链表 headA 的尾连着链表 headB 的头
        // 使两个链表形成一个环（如果两个链表有交点的话）
        node1.next = headB;

        // 利用快慢指针判断是否有环
        ListNode fast = headA, slow = headA;
        while (fast.next != null && fast.next.next != null) {
            fast = fast.next.next;
            slow = slow.next;

            // 如果有环，快慢指针会相遇
            if (fast == slow) {
                break ;
            }
        }

        // 如果无环，则满足 fast.next == null || fast.next.next == null
        if (fast.next == null || fast.next.next == null) {
            node1.next = null;
			
            // 无环直接返回 null
            return null;
        }

        // 让 slow 从链表的 headA 的头结点开始
        // 和 fast 以同样的速度前进
        slow = headA;
        while (slow != fast) {
            // 当 slow == fast 时，就是两个链表相交的位置
            fast = fast.next;
            slow = slow.next;
        }

        // 断开链表，恢复原来的状态
        node1.next = null;
        return fast;
    }
```

# 20210605 <font color=#009975>E</font> <font color=#009975>S</font>

## 203. 移除链表元素

原题链接：[203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

## 1.迭代法

``` java
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }

        // newHead 用来充当新节点，用来指向结果链表
        // 因为可能出现第一个节点值就等于 val 的情况
        ListNode newHead = new ListNode(), pre = newHead, node = head;
        // 直接遍历链表 head
        while (node != null) {
            // 如果当前节点的值等于 val
            if (node.val == val) {
                // 表示要删除当前节点 node
                // 所以先让 pre.next 指向 node.next
                pre.next = node.next;
                // node.next 置位 null，断开与后面节点的连接
                node.next = null;
                // 当前节点 node 跳到新的 next 节点
                node = pre.next;
                // 这一步 pre 不需要跳到下一个节点
                // 因为新的 next 节点值有可能还等于 val
            } else {
                // 不相等 pre 和 node 都跳到下一个节点
                pre.next = node;
                pre = pre.next;

                node = node.next;
            }
        }

        // newHead.next 就是新
        return newHead.next;
    }
}
```

# 20210606 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 474. 一和零

原题链接：[474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

> 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
>
> 请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。
>
> 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

## 1.动态规划

参考题解：[474 参考题解](https://leetcode-cn.com/problems/ones-and-zeroes/solution/yi-he-ling-by-leetcode-solution-u2z2/)

``` java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int length = strs.length;
        // dp[i][j][k] 表示在前 i 个字符串中
        // 使用 j 个 0 和 k 个 1 的情况下最多可以得到的字符串数量
        int[][][] dp = new int[length + 1][m + 1][n + 1];
        
        for (int i = 1; i <= length; i++) {
            String str = strs[i - 1];
            // 统计当前字符串 0 和 1 的数量
            int zeros = 0, ones = 0;
            for (int j = 0; j < str.length(); j++) {
                char c = str.charAt(j);
                if (c == '0') {
                    zeros++;
                } else {
                    ones++;
                }
            }

            for (int j = 0; j <= m; j++) {
                for (int k = 0; k <= n; k++) {
                    // 如果 j < zeros 或 k < ones
                    // 则不能选第 i 个字符串，此时有 dp[i][j][k] = dp[i - 1][j][k]
                    dp[i][j][k] = dp[i - 1][j][k];
                    if (j >= zeros && k >= ones) {
                        // 当 j >= zeros 或 k >= ones 时
                        // 如果不选第 i 个字符串，此时有 dp[i][j][k] = dp[i - 1][j][k]
                        // 如果选择第 i 个字符串
                        // 则有 dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)
                        // 选上面两项中最大值
                        dp[i][j][k] = Math.max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1);
                    }
                }
            }
        }

        return dp[length][m][n];
    }
}
```

# 20210607 <font color=#ed7336>M</font> <font color=#009975>S</font>

## 494. 目标和

原题链接：[494. 目标和](https://leetcode-cn.com/problems/target-sum/)

> 给你一个整数数组 nums 和一个整数 target 。
>
> 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：
>
> 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
> 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

## 1.递归法

``` java
class Solution {
    int count = 0;
    public int findTargetSumWays(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        findTargetSumWays(nums, target, 0, 0);
        
        return count;
    }

    /**
     * 递归函数
     * @param i 表示当前递归的位置
     * @param sum 表示当前递归的和
     */
    public void findTargetSumWays(int[] nums, int target, int i, int sum) {
         if (i == nums.length) {
             // 当前递归和 sum 等于目标
             if (target == sum) {
                // count 加一，计数一次
                count++;
             }
         } else {
             // 当前符号为 +
             findTargetSumWays(nums, target, i + 1, sum + nums[i]);
             // 当前符号为 -
             findTargetSumWays(nums, target, i + 1, sum - nums[i]);
         }
    }
}
```

# 20210608 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

## 1049. 最后一块石头的重量 II

原题链接：[1049. 最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

> 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。
>
> 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：
>
> 如果 x == y，那么两块石头都会被完全粉碎；
> 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
> 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

## 1.动态规划

参考题解：[1049 参考题解](https://leetcode-cn.com/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/)

暂时还没有搞懂，先晾着

``` java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int length = stones.length;

        int sum = 0;
        for (int stone : stones) {
            sum += stone;
        }
        int t = sum / 2;
        int[][] dp = new int[length + 1][t + 1];

        for (int i = 1; i <= length; i++) {
            int stone = stones[i - 1];
            for (int j = 0; j <= t; j++) {
                dp[i][j] = dp[i - 1][j];
                if (j >= stone) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - stone] + stone);
                }
            }
        }

        return Math.abs(sum - 2 * dp[length][t]);
    }
}
```

# 20210609 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

## 879. 盈利计划

原题链接：[879. 盈利计划](https://leetcode-cn.com/problems/profitable-schemes/)

> 集团里有 n 名员工，他们可以完成各种各样的工作创造利润。
>
> 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。
>
> 工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。
>
> 有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。

## 1.动态规划

参考题解：[879 参考题解](https://leetcode-cn.com/problems/profitable-schemes/solution/gong-shui-san-xie-te-shu-duo-wei-fei-yon-7su9/)

还没有理解到题解的意思，暂时未写注释

``` java
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int mod = (int)1e9+7;
        int m = group.length;
        long[][][] dp = new long[m + 1][n + 1][minProfit + 1];
        for (int i = 0; i <= n; i++) {
            dp[0][i][0] = 1;
        }

        for (int i = 1; i <= m; i++) {
            int g = group[i - 1], p = profit[i - 1];
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k <= minProfit; k++) {
                    dp[i][j][k] = dp[i - 1][j][k];

                    if (j >= g) {
                        int u = Math.max(k - p, 0);
                        dp[i][j][k] += dp[i - 1][j - g][u];
                        if (dp[i][j][k] >= mod) {
                            dp[i][j][k] %= mod;
                        }
                    }
                }
            }
        }

        return (int)dp[m][n][minProfit];
    }
}
```

# 20210610 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

## 518. 零钱兑换 II

原题链接：[518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

> 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

## 1.完全背包

参考题解：[518 参考题解](https://leetcode-cn.com/problems/coin-change-2/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-6hxv/)

``` java
class Solution {

    public int change(int amount, int[] coins) {
        int n = coins.length;
        // 定义 dp[i][j] 为考虑前 i 个硬币，凑成总和为 j 的方案数量
        int[][] dp = new int[n + 1][amount + 1];
        // 0 个硬币凑成 0 元的方案为 1
        dp[0][0] = 1;

        for (int i = 1; i <= n; i++) {
            int val = coins[i - 1];
            for (int j = 0; j <= amount; j++) {
                // 不使用该硬币
                dp[i][j] = dp[i - 1][j];

                // 使用该硬币：由于每个硬币可以被选择多次（容量允许的情况下）
                // 因此方案数量应当是选择「任意个」该硬币的方案总和
                for (int k = 1; k * val <= j; k++) {
                    dp[i][j] += dp[i - 1][j - k * val];
                }
            }
        }

        return dp[n][amount];
    }
}
```

# 20210611 <font color=#ed7336>M</font> <font color=#009975>S</font>

## 279. 完全平方数

原题链接：[279. 完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

> 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
>
> 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
>
> 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

## 1.动态规划

``` java
class Solution {
    public int numSquares(int n) {
        // dp[i] 表示和为第 i 个正整数的完全平方数的最少数量
        int[] dp = new int[n + 1];
		// 因为要求最小值，所以这里给 dp 赋一个不可能的值作为最大值
        // 这里赋值 n + 1 是因为只有当完全平方数是 1 时，和为 n 的完全平方数最大为 n
        // 所以 n + 1 是不可能达到的值
        Arrays.fill(dp, n + 1);
        // 设定初始值，没有完全平方数的和为 0，所以 dp[0] = 0
        dp[0] = 0;

        // 自底向上
        // 从 1 开始计算和为 i 的完全平方数的最少数量
        for (int i = 1; i <= n; i++) {
            // 完全平方数肯定要小于 i
            for (int j = 1; j * j <= i; j++) {
                // 使用完全平方数 j * j，再在 dp[i - j * j] 基础上加 1
                // 每个完全平方数都用一遍，然后取最终组合的最小值
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }

        return dp[n];
    }
}
```

# 20210612 <font color=#ec4c47>H</font> <font color=#ed7336>R</font>

## 1449. 数位成本和为目标值的最大数字

原题链接：[1449. 数位成本和为目标值的最大数字](https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/)

> 给你一个整数数组 cost 和一个整数 target 。请你返回满足如下规则可以得到的 最大 整数：
>
> 给当前结果添加一个数位（i + 1）的成本为 cost[i] （cost 数组下标从 0 开始）。
> 总成本必须恰好等于 target 。
> 添加的数位中没有数字 0 。
> 由于答案可能会很大，请你以字符串形式返回。
>
> 如果按照上述要求无法得到任何整数，请你返回 "0" 。
>
>  
>
> 示例 1：
>
> 输入：cost = [4,3,2,5,6,7,2,5,5], target = 9
> 输出："7772"
> 解释：添加数位 '7' 的成本为 2 ，添加数位 '2' 的成本为 3 。所以 "7772" 的代价为 2*3+ 3*1 = 9 。 "977" 也是满足要求的数字，但 "7772" 是较大的数字。
>  数字     成本
>   1  ->   4
>   2  ->   3
>   3  ->   2
>   4  ->   5
>   5  ->   6
>   6  ->   7
>   7  ->   2
>   8  ->   5
>   9  ->   5

## 1.动态规划 + 贪心

参考题解：[1449 参考题解](https://leetcode-cn.com/problems/form-largest-integer-with-digits-that-add-up-to-target/solution/gong-shui-san-xie-fen-liang-bu-kao-lu-we-uy4y/)

``` java
class Solution {
    public String largestNumber(int[] cost, int target) {
        // dp[i] 表示总成本为 i 时，需要最多的数位
        // 根据长度进行比较，长度较长数字较大
        int[] dp = new int[target + 1];
        Arrays.fill(dp, Integer.MIN_VALUE);
        dp[0] = 0;
        // 先求出总成本从 1 ~ target 所需要的最多数位
        for (int i = 1; i <= 9; i++) {
            int num = cost[i - 1];
            for (int j = num; j <= target; j++) {
                dp[j] = Math.max(dp[j], dp[j - num] + 1);
            }
        }

        // 如果无法 target 返回 "0"
        if (dp[target] < 0) {
            return "0";
        }

        String ans = "";
        // 对于长度相等的数值，从高位往低位进行比较
        // 找到第一位不同，不同位值大的数值较大
        for (int i = 9, j = target; i > 0; i--) {
            int num = cost[i - 1];
            // while 循环是可能会重复用到 num
            // dp[j] == dp[j - num] + 1 表示当前选择了 num
            while (j >= num && dp[j] == dp[j - num] + 1) {
                ans += String.valueOf(i);
                // 当前选择了 num 就要减掉
                j -= num;
            }
        }

        return ans;
    }
}
```

# 20210613 <font color=#009975>E</font> <font color=#009975>S</font>

## 278. 第一个错误的版本

原题链接：[278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

> 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
>
> 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
>
> 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

## 1.二分法

``` java
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        // 二分法解决，将区间分为 [left, mid] 和 [mid + 1, right]
        int left = 1, right = n;
        while (left < right) {
            int mid = (left + right) >>> 1;
            // 如果 mid 是错误版本，则表示第一个错误版本在 [left, mid] 区间内
            if (isBadVersion(mid)) {
                // 所以收缩右边，让 right = mid
                right = mid;
            } else {
                // 否则表示第一个错误版本在 [mid + 1, right] 区间内
                // 所以收缩坐边，让 left = mid + 1
                left = mid + 1;
            }
        }
		
        // 最后 left == right，返回 left 或者 right 皆可
        return left;
    }
}
```

# 20210614 <font color=#009975>E</font> <font color=#009975>S</font>

## 374. 猜数字大小

原题链接：[374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

> 猜数字游戏的规则如下：
>
> 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
> 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。
> 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：
>
> -1：我选出的数字比你猜的数字小 pick < num
> 1：我选出的数字比你猜的数字大 pick > num
> 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num
> 返回我选出的数字。

## 1.二分法

``` java
public class Solution extends GuessGame {
    
    /**
     * 标准的二分法
     */
    public int guessNumber(int n) {
        int left = 1, right = n;
        while (left <= right) {
            int mid = (left + right) >>> 1;
            int guess = guess(mid);
            if (guess < 0) {
                right = mid - 1;
            } else if (guess > 0) {
                left = mid + 1;
            } else {
                return mid;
            }
        }

        return left;
    }
}
```

