# 2021年9月力扣每日1题

## 20210901 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 165. 比较版本号

原题链接：[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

> 给你两个版本号 version1 和 version2 ，请你比较它们。
>
> 版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
>
> 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。
>
> 返回规则如下：
>
> 如果 version1 > version2 返回 1，
> 如果 version1 < version2 返回 -1，
> 除此之外返回 0。
>
> 提示：
>
> 1 <= version1.length, version2.length <= 500
> version1 和 version2 仅包含数字和 '.'
> version1 和 version2 都是 有效版本号
> version1 和 version2 的所有修订号都可以存储在 32 位整数 中

### 1.直接法

``` java
class Solution {
    public int compareVersion(String version1, String version2) {
        // 先将两个版本号分割成字符串数组
        String[] arr1 = version1.split("\\.");
        String[] arr2 = version2.split("\\.");

        int len1 = arr1.length, len2 = arr2.length;
        // 然后按位比较每一位的大小
        for (int i = 0; i < Math.max(len1, len2); i++) {
            // 将每一位修订号转成整型
            // 如果超出数组范围则转成0
            int ver1 = i < len1 ? Integer.parseInt(arr1[i]) : 0;
            int ver2 = i < len2 ? Integer.parseInt(arr2[i]) : 0;

            // 比较两个修订号是否相等
            if (ver1 != ver2) {
                // 不相等ver1 > ver2返回1
                // 否则返回-1
                return ver1 > ver2 ? 1 : -1;
            }
        }

        // 到了这里说明所有的修订号都相等
        // 即两个版本号相等，返回0
        return 0;
    }
}
```

## 20210902 <font color=#009975>E</font> <font color=#009975>S</font>

### 剑指 Offer 22. 链表中倒数第k个节点

原题链接：[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
>
> 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

### 1.双指针

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        int idx = 1;
        ListNode first = head;
        // 想让第一个指针跳到第k个节点
        while (idx++ < k) {
            first = first.next;
        }

        // 然后再让第一个指针从头开始
        ListNode second = head;
        // 两个指针同时前进
        // 当第一个指针到达最后一个节点时
        // 第二个指针刚好到倒数第k个节点的位置
        while (first.next != null) {
            first = first.next;
            second = second.next;
        }

        return second;
    }
}
```

## 20210903 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 面试题 17.14. 最小K个数

原题链接：[面试题 17.14. 最小K个数](https://leetcode-cn.com/problems/smallest-k-lcci/)

> 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
>
> **提示：**
>
> - `0 <= len(arr) <= 100000`
> - `0 <= k <= min(100000, len(arr))`

### 1.排序

``` java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        Arrays.sort(arr);

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = arr[i];
        }

        return res;
    }
}
```

## 20210904 <font color=#009975>E</font> <font color=#009975>S</font>

### 剑指 Offer 10- I. 斐波那契数列

原题链接：[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> **提示：**
>
> - `0 <= n <= 100`

### 1.动态规划

``` java
class Solution {
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }

        int INF = 1000000007;

        // 斐波那契数列其实只需要前两个数的状态
        // 所以这里用first表示F(N - 2)
        // second表示F(N - 1)
        int first = 0, second = 1;
        for (int i = 2; i <= n; i++) {
            // t表示F(N)
            int t = (first + second) % INF;

            // 为下一轮更新F(N - 2)
            // 即现在的F(N - 1)
            first = second;
            // 为下一轮更新F(N - 1)
            // 即现在的F(N)
            second = t;
        }

        // 所以当循环结束时
        // second
        return second;
    }
}
```

## 20210905 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 470. 用 Rand7() 实现 Rand10()

原题链接：[470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

> 已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。
>
> 不要使用系统的 Math.random() 方法。
>
> **提示:**
>
> 1. `rand7` 已定义。
> 2. 传入参数: `n` 表示 `rand10` 的调用次数。

### 1.拒绝采样

[参考题解](https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/)

``` java
/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */
class Solution extends SolBase {
    public int rand10() {
        int a, b, num;
        do {
            a = rand7();
            b = rand7();

            num = a + (b - 1) * 7;
        } while (num > 40);

        return 1 + (num - 1) % 10;
    }
}
```

## 20210906 <font color=#009975>E</font> <font color=#009975>S</font>

### 704. 二分查找

原题链接：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

### 1.二分法

``` java
class Solution {
    public int search(int[] nums, int target) {
        int length = nums.length;

        // 在区间[left, right]内搜索target
        int left = 0, right = length - 1;
        while (left < right) {
        	// 将整个区间分为[left, mid]和[mid + 1, right]
            // 其中区间[left, mid]小于target
            // 区间[mid + 1, right]大于等于target
            int mid = (left + right) >> 1;
            if (nums[mid] < target) {
                // 当nums[mid] < target时
                // 缩小左边的区间
                left = mid + 1;
            } else {
                // 否则缩小右边的区间
                right = mid;
            }
        }
        
        // 判断nums[left]是否等于target
        // 等于target返回left，否则返回-1
        return nums[left] == target ? left : -1;
    }
}
```

