# 2021年7月力扣每日1题

## 20210701 <font color=#009975>E</font> <font color=#009975>S</font>

### LCP 07. 传递信息

原题链接：[LCP 07. 传递信息](https://leetcode-cn.com/problems/chuan-di-xin-xi/)

> 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
>
> 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
> 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
> 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
> 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
>
> 示例 1：
>
> 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
>
> 输出：3
>
> 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。
>
> 示例 2：
>
> 输入：n = 3, relation = [[0,2],[2,1]], k = 2
>
> 输出：0
>
> 解释：信息不能从小 A 处经过 2 轮传递到编号 2

### 1.递归

``` java
class Solution {
    int res = 0;
    public int numWays(int n, int[][] relation, int k) {
        // 用map保存玩家与能传递信息玩家的对应关系，一对多
        Map<Integer, List<Integer>> map = new HashMap<>();
        for (int i = 0; i < relation.length; i++) {
            List<Integer> list = map.get(relation[i][0]);
            if (list == null) {
                list = new ArrayList<>();
                map.put(relation[i][0], list);
            }

            list.add(relation[i][1]);
        }

        helper(0, n, map, 0, k);

        return res;
    }

    // 递归判断满足条件的方案
    private void helper(int pos, int n, Map<Integer, List<Integer>> map, int times, int k) {
        // 次数满足条件
        if (times == k) {
            // 已传递到最后一个玩家
            if (pos == n - 1) {
                // 记录次数
                res++;
            }

            return ;
        }

        List<Integer> list = map.get(pos);
        if (list == null || list.size() == 0) {
            return ;
        }

        for (Integer next : list) {
            // 按照当前能传递到的下一个玩家来递归
            helper(next, n, map, times + 1, k);
        }
    }
}
```

## 20210702 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 1833. 雪糕的最大数量

原题链接：[1833. 雪糕的最大数量](https://leetcode-cn.com/problems/maximum-ice-cream-bars/)

> 夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。
>
> 商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。
>
> 给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。
>
> 注意：Tony 可以按任意顺序购买雪糕。
>

### 1.排序法

``` java
class Solution {
    public int maxIceCream(int[] costs, int coins) {
        // 先对雪糕的定价按从小到大排序
        Arrays.sort(costs);

        int res = 0;
        // 再按价格从小到大开始购买，直到剩余现金量不够时为止
        for (int i = 0; i < costs.length; i++) {
            if (costs[i] <= coins) {
                // 扣除当前购买雪糕的价钱
                coins -= costs[i];
				// 计数
                res++;
            }
        }

        return res;
    }
}
```

