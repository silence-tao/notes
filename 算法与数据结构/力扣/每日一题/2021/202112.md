# 2021年12月力扣每日1题

## 20211201 <font color=#009975>E</font> <font color=#009975>S</font>

### 1446. 连续字符

原题链接：[1446. 连续字符](https://leetcode-cn.com/problems/consecutive-characters/)

> 给你一个字符串 `s` ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。
>
> 请你返回字符串的能量。
>
> **提示：**
>
> - `1 <= s.length <= 500`
> - `s` 只包含小写英文字母。

### 1.迭代法

``` java
class Solution {
    public int maxPower(String s) {
        int length = s.length();

        int max = 1, sum = 1;
        char a = s.charAt(0);
        for (int i = 1; i < length; i++) {
            if (a == s.charAt(i)) {
                sum++;
            } else {
                sum = 1;
                a = s.charAt(i);
            }

            max = Math.max(sum, max);
        }

        return max;
    }
}
```

## 20211202 <font color=#009975>E</font> <font color=#009975>S</font>

### 506. 相对名次

原题链接：[506. 相对名次](https://leetcode-cn.com/problems/relative-ranks/)

> 给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。
>
> 运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：
>
> 名次第 1 的运动员获金牌 "Gold Medal" 。
> 名次第 2 的运动员获银牌 "Silver Medal" 。
> 名次第 3 的运动员获铜牌 "Bronze Medal" 。
> 从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 "x"）。
> 使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。

### 1.排序 + 哈希

``` java
class Solution {
    public String[] findRelativeRanks(int[] score) {
        int length = score.length;
        int[] copy = new int[length];
        for (int i = 0; i < length; i++) {
            copy[i] = score[i];
        }

        Arrays.sort(copy);
        Map<Integer, String> memory = new HashMap<>();
        for (int i = 1; i <= length; i++) {
            int temp = copy[length - i];
            if (i == 1) {
                memory.put(temp, "Gold Medal");
            } else if (i == 2) {
                memory.put(temp, "Silver Medal");
            } else if (i == 3) {
                memory.put(temp, "Bronze Medal");
            } else {
                memory.put(temp, Integer.toString(i));
            }
        }

        String[] strs = new String[length];
        for (int i = 0; i < length; i++) {
            strs[i] = memory.get(score[i]);
        }

        return strs;
    }
}
```

## 20211203 <font color=#009975>E</font> <font color=#009975>S</font>

### 1005. K 次取反后最大化的数组和

原题链接：[1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

> 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
>
> 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
> 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
>
> 以这种方式修改数组后，返回数组 可能的最大和 。
>
> **提示：**
>
> - `1 <= nums.length <= 104`
> - `-100 <= nums[i] <= 100`
> - `1 <= k <= 104`

### 1.贪心

``` java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        int length = nums.length;

        // 排序，把可能有的负数排到前面
        Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < length; i++) {
            // 贪心：如果是负数，而k还有盈余，就把负数反过来
            if (nums[i] < 0 && k > 0) {
                nums[i] = -nums[i];
                k--;
            }

            sum += nums[i];
        }
        
        Arrays.sort(nums);

        // 如果k没剩，那说明能转的负数都转正了，已经是最大和，返回sum
        // 如果k有剩，说明负数已经全部转正，所以如果k还剩偶数个就自己抵消掉，不用删减
        // 如果k还剩奇数个就减掉2倍最小正数。
        return sum - (k % 2 == 0 ? 0 : 2 * nums[0]);
    }
}
```

## 20211204 <font color=#009975>E</font> <font color=#009975>S</font>

### 383. 赎金信

原题链接：[383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

> 为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。
>
> 给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。
>
> 如果可以构成，返回 true ；否则返回 false 。
>
> magazine 中的每个字符只能在 ransomNote 中使用一次。
>
> 提示：
>
> 1 <= ransomNote.length, magazine.length <= 105
> ransomNote 和 magazine 由小写英文字母组成

### 1.数组计数

``` java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
		// 用数组记录出现字符的数量
        int[] memory = new int[26];

        // 统计ransomNote中出现的字符
        for (int i = 0; i < ransomNote.length(); i++) {
            char c = ransomNote.charAt(i);
            memory[c - 'a']++;
        }

        // 将出现在magazine中的字符从memory减去
        for (int i = 0; i < magazine.length(); i++) {
            char c = magazine.charAt(i);
            int n = c - 'a';
            
            if (memory[n] > 0) {
                memory[n]--;
            }
        }

        // 校验memory中是否都为0
        for (int num : memory) {
            if (num > 0) {
                // 有一个不为0，就不符合条件
                return false;
            }
        }

        return true;
    }
}
```

## 20211205 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 372. 超级次方

原题链接：[372. 超级次方](https://leetcode-cn.com/problems/super-pow/)

> 你的任务是计算 `ab` 对 `1337` 取模，`a` 是一个正整数，`b` 是一个非常大的正整数且会以数组形式给出。
>
> **提示：**
>
> - `1 <= a <= 231 - 1`
> - `1 <= b.length <= 2000`
> - `0 <= b[i] <= 9`
> - `b` 不含前导 0

### 1.快速幂

[参考题解](https://leetcode-cn.com/problems/super-pow/solution/gong-shui-san-xie-di-gui-kuai-su-mi-ying-yx1j/)

``` java
class Solution {
    int MOD = 1337;

    public int superPow(int a, int[] b) {
        return dfs(a, b, b.length - 1);
    }

    private int dfs(int a, int[] b, int n) {
        if (n == -1) {
            return 1;
        }

        return pow(dfs(a, b, n - 1), 10) * pow(a, b[n]) % MOD;
    }

    private int pow(int a, int b) {
        int ans = 1;
        
        a = a % MOD;
        while (b-- > 0) {
            ans = ans * a % MOD;;
        }

        return ans;
    }
}
```

## 20211206 <font color=#009975>E</font> <font color=#009975>S</font>

### 1816. 截断句子

原题链接：[1816. 截断句子](https://leetcode-cn.com/problems/truncate-sentence/)

> 句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。
>
> 例如，"Hello World"、"HELLO" 和 "hello world hello world" 都是句子。
> 给你一个句子 s 和一个整数 k ，请你将 s 截断 ，使截断后的句子仅含 前 k 个单词。返回 截断 s 后得到的句子。
>
> 提示：
>
> 1 <= s.length <= 500
> k 的取值范围是 [1,  s 中单词的数目]
> s 仅由大小写英文字母和空格组成
> s 中的单词之间由单个空格隔开
> 不存在前导或尾随空格

### 1.迭代法

``` java
class Solution {
    public String truncateSentence(String s, int k) {
        int length = s.length();

        int i = 0;
        // 挨个遍历字符
        while (k > 0) {
            char c = s.charAt(i++);
            // 遇到空格或者最后一个字符k就减1
            if (c == ' ' || i == length) {
                k--;
            }
        }

        // 如果没有遍历到最后一个字符
        if (i != length) {
            // 则i要减1，因为在判断到空格的时候，i又多加
            i--;
        }

        return s.substring(0, i);
    }
}
```

## 20211207 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 1034. 边界着色

原题链接：[1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/)

> 给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
>
> 两个网格块属于同一 连通分量 需满足下述全部条件：
>
> 两个网格块颜色相同
> 在上、下、左、右任意一个方向上相邻
> 连通分量的边界 是指连通分量中满足下述条件之一的所有网格块：
>
> 在上、下、左、右四个方向上与不属于同一连通分量的网格块相邻
> 在网格的边界上（第一行/列或最后一行/列）
> 请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。
>
> 提示：
>
> m == grid.length
> n == grid[i].length
> 1 <= m, n <= 50
> 1 <= grid[i][j], color <= 1000
> 0 <= row < m
> 0 <= col < n

### 1.深度优先搜索

[参考题解](https://leetcode-cn.com/problems/coloring-a-border/solution/bian-kuang-zhao-se-by-leetcode-solution-0h5l/)

``` java
class Solution {
    public int[][] colorBorder(int[][] grid, int row, int col, int color) {
        int m = grid.length, n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        List<int[]> borders = new ArrayList<>();
        int originalColor = grid[row][col];
        visited[row][col] = true;
        dfs(grid, row, col, visited, borders, originalColor);
        for (int i = 0; i < borders.size(); i++) {
            int x = borders.get(i)[0], y = borders.get(i)[1];
            grid[x][y] = color;
        }
        return grid;
    }

    private void dfs(int[][] grid, int x, int y, boolean[][] visited, List<int[]> borders, int originalColor) {
        int m = grid.length, n = grid[0].length;
        boolean isBorder = false;
        int[][] direc = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for (int i = 0; i < 4; i++) {
            int nx = direc[i][0] + x, ny = direc[i][1] + y;
            if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {
                isBorder = true;
            } else if (!visited[nx][ny]){
                visited[nx][ny] = true;
                dfs(grid, nx, ny, visited, borders, originalColor);
            }                
        }
        if (isBorder) {
            borders.add(new int[]{x, y});
        }
    }
}
```

## 20211208 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 689. 三个无重叠子数组的最大和

原题链接：[689. 三个无重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)

> 给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、且 3 * k 项的和最大的子数组，并返回这三个子数组。
>
> 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。如果有多个结果，返回字典序最小的一个。
>
> 提示：
>
> 1 <= nums.length <= 2 * 104
> 1 <= nums[i] < 216
> 1 <= k <= floor(nums.length / 3)

### 1.滑动窗口

[参考题解](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/solution/san-ge-wu-zhong-die-zi-shu-zu-de-zui-da-4a8lb/)

``` java
class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int[] ans = new int[3];
        int sum1 = 0, maxSum1 = 0, maxSum1Idx = 0;
        int sum2 = 0, maxSum12 = 0, maxSum12Idx1 = 0, maxSum12Idx2 = 0;
        int sum3 = 0, maxTotal = 0;
        for (int i = k * 2; i < nums.length; ++i) {
            sum1 += nums[i - k * 2];
            sum2 += nums[i - k];
            sum3 += nums[i];
            if (i >= k * 3 - 1) {
                if (sum1 > maxSum1) {
                    maxSum1 = sum1;
                    maxSum1Idx = i - k * 3 + 1;
                }
                if (maxSum1 + sum2 > maxSum12) {
                    maxSum12 = maxSum1 + sum2;
                    maxSum12Idx1 = maxSum1Idx;
                    maxSum12Idx2 = i - k * 2 + 1;
                }
                if (maxSum12 + sum3 > maxTotal) {
                    maxTotal = maxSum12 + sum3;
                    ans[0] = maxSum12Idx1;
                    ans[1] = maxSum12Idx2;
                    ans[2] = i - k + 1;
                }
                sum1 -= nums[i - k * 3 + 1];
                sum2 -= nums[i - k * 2 + 1];
                sum3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
}
```

## 20211209 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 794. 有效的井字游戏

原题链接：[794. 有效的井字游戏](https://leetcode-cn.com/problems/valid-tic-tac-toe-state/)

> 给你一个字符串数组 board 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 board 所显示的状态时，才返回 true 。
>
> 井字游戏的棋盘是一个 3 x 3 数组，由字符 ' '，'X' 和 'O' 组成。字符 ' ' 代表一个空位。
>
> 以下是井字游戏的规则：
>
> 玩家轮流将字符放入空位（' '）中。
> 玩家 1 总是放字符 'X' ，而玩家 2 总是放字符 'O' 。
> 'X' 和 'O' 只允许放置在空位中，不允许对已放有字符的位置进行填充。
> 当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。
> 当所有位置非空时，也算为游戏结束。
> 如果游戏结束，玩家不允许再放置字符。
>
> **提示：**
>
> - `board.length == 3`
> - `board[i].length == 3`
> - `board[i][j]` 为 `'X'`、`'O'` 或 `' '`

### 1.分类讨论

[参考链接](https://leetcode-cn.com/problems/valid-tic-tac-toe-state/solution/you-xiao-de-jing-zi-you-xi-by-leetcode-s-c1j3/)

``` java
class Solution {
    public boolean validTicTacToe(String[] board) {
        int xCount = 0, oCount = 0;
        for (String row : board) {
            for (char c : row.toCharArray()) {
                xCount = (c == 'X') ? (xCount + 1) : xCount;
                oCount = (c == 'O') ? (oCount + 1) : oCount;
            }
        }
        if (oCount != xCount && oCount != xCount - 1) {
            return false;
        }
        if (win(board, 'X') && oCount != xCount - 1) {
            return false;
        }
        if (win(board, 'O') && oCount != xCount) {
            return false;
        }
        return true;
    }

    public boolean win(String[] board, char p) {
        for (int i = 0; i < 3; ++i) {
            if (p == board[0].charAt(i) && p == board[1].charAt(i) && p == board[2].charAt(i)) {
                return true;
            }
            if (p == board[i].charAt(0) && p == board[i].charAt(1) && p == board[i].charAt(2)) {
                return true;
            }
        }
        if (p == board[0].charAt(0) && p == board[1].charAt(1) && p == board[2].charAt(2)) {
            return true;
        }
        if (p == board[0].charAt(2) && p == board[1].charAt(1) && p == board[2].charAt(0)) {
            return true;
        }
        return false;
    }
}
```

## 20211210 <font color=#009975>E</font> <font color=#009975>S</font>

### 748. 最短补全词

原题链接：[748. 最短补全词](https://leetcode-cn.com/problems/shortest-completing-word/)

> 给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出并返回 words 中的 最短补全词 。
>
> 补全词 是一个包含 licensePlate 中所有的字母的单词。在所有补全词中，最短的那个就是 最短补全词 。
>
> 在匹配 licensePlate 中的字母时：
>
> 忽略 licensePlate 中的 数字和空格 。
> 不区分大小写。
> 如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。
> 例如：licensePlate = "aBc 12c"，那么它的补全词应当包含字母 'a'、'b' （忽略大写）和两个 'c' 。可能的 补全词 有 "abccdef"、"caaacab" 以及 "cbca" 。
>
> 请你找出并返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 最靠前的 那个。
>
> 提示：
>
> 1 <= licensePlate.length <= 7
> licensePlate 由数字、大小写字母或空格 ' ' 组成
> 1 <= words.length <= 1000
> 1 <= words[i].length <= 15
> words[i] 由小写英文字母组成

### 1.迭代计数法

``` java
class Solution {
    public String shortestCompletingWord(String licensePlate, String[] words) {
        int[] arr = getLettersNum(licensePlate.toLowerCase());

        int min = Integer.MAX_VALUE, pos = 0;
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            if (check(arr, getLettersNum(word)) && word.length() < min) {
                min = word.length();
                pos = i;
            }
        }

        return words[pos];
    }

    private int[] getLettersNum(String letter) {
        int[] arr = new int[26];

        for (int i = 0; i < letter.length(); i++) {
            char c = letter.charAt(i);
            if (c >= 'a' && c <= 'z') {
                arr[c - 'a']++;
            }
        }

        return arr;
    }

    private boolean check(int[] arr, int[] tempArr) {
        for (int i = 0; i < 26; i++) {
            if (arr[i] > tempArr[i]) {
                return false;
            }
        }

        return true;
    }
}
```

## 20211211 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 911. 在线选举

原题链接：[911. 在线选举](https://leetcode-cn.com/problems/online-election/)

> 给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。
>
> 对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。
>
> 在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。
>
> 实现 TopVotedCandidate 类：
>
> TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。
> int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。
>
> 提示：
>
> 1 <= persons.length <= 5000
> times.length == persons.length
> 0 <= persons[i] < persons.length
> 0 <= times[i] <= 109
> times 是一个严格递增的有序数组
> times[0] <= t <= 109
> 每个测试用例最多调用 104 次 q

### 1.预计算 + 二分查找

[参考链接](https://leetcode-cn.com/problems/online-election/solution/zai-xian-xuan-ju-by-leetcode-solution-4835/)

``` java
class TopVotedCandidate {
    // 记录每个times[i]时刻的获胜者
    private List<Integer> tops;
    // 保存候选人和选票数量的映射关系
    private Map<Integer, Integer> votesMap;
    int[] times;

    public TopVotedCandidate(int[] persons, int[] times) {
        tops = new ArrayList<>();
        votesMap = new HashMap<>();
        votesMap.put(-1, -1);

        // 当前times[i]时刻的获胜者
        int top = -1;
        // 统计每个times[i]时刻的获胜者
        // 以及候选人和选票数量的映射关系
        for (int i = 0; i < persons.length; i++) {
            int person = persons[i];
            votesMap.put(person, votesMap.getOrDefault(person, 0) + 1);
            // 在当前times[i]时刻投票完之后
            // person的选票数量大于当前获胜者
            // 则更新获胜者为person
            if (votesMap.get(person) >= votesMap.get(top)) {
                top = person;
            }

            // 将当前times[i]时刻投票完之后的获胜者放入tops集合中
            tops.add(top);
        }

        this.times = times;
    }
    
    public int q(int t) {
        // 利用二分法找到离t时刻最近的一次投票的获胜者
        // 即为t时刻的获胜者
        int left = 0, right = times.length - 1;
        while (left < right) {
            int mid = (left + right + 1) >> 1;
            if (t < times[mid]) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }

        return tops.get(left);
    }
}

/**
 * Your TopVotedCandidate object will be instantiated and called as such:
 * TopVotedCandidate obj = new TopVotedCandidate(persons, times);
 * int param_1 = obj.q(t);
 */
```

## 20211212 <font color=#009975>E</font> <font color=#009975>S</font>

### 709. 转换成小写字母

原题链接：[709. 转换成小写字母](https://leetcode-cn.com/problems/to-lower-case/)

> 给你一个字符串 `s` ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。
>
> **提示：**
>
> - `1 <= s.length <= 100`
> - `s` 由 ASCII 字符集中的可打印字符组成

### 1.JDK

``` java
class Solution {
    public String toLowerCase(String s) {
        return s.toLowerCase();
    }
}
```

