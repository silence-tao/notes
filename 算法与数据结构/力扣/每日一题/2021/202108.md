# 2021年8月力扣每日1题

## 20210801 <font color=#009975>E</font> <font color=#009975>S</font>

### 1337. 矩阵中战斗力最弱的 K 行

原题链接：[1337. 矩阵中战斗力最弱的 K 行](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/)

> 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
>
> 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
>
> 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
>
> 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

### 1.排序

``` java
class Solution {

    // 用Row类表示每一行的信息
    // 包括行号和军人数量
    public static class Row {
        
        // 第几行
        int idx;

        // 军人数量
        int soldiers;

        Row(int idx, int soldiers) {
            this.idx = idx;
            this.soldiers = soldiers;
        }
    }

    public int[] kWeakestRows(int[][] mat, int k) {
        int m = mat.length, n = mat[0].length;

        // 统计每一行的军人数量并构建Row对象放入rows集合中
        List<Row> rows = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            int soldiers = 0;
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1) {
                    soldiers++;
                }
            }

            rows.add(new Row(i, soldiers));
        }

        // 排序：soldiers相同按idx从小到大排序
        // soldiers不相同按soldiers从小到大排序
        Collections.sort(rows, (a, b) -> {
            if (a.soldiers == b.soldiers) {
                return a.idx - b.idx;
            } else {
                return a.soldiers - b.soldiers;
            }
        });

        // 收集前k个结果并返回
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = rows.get(i).idx;
        }

        return res;
    }
}
```

## 20210802 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 743. 网络延迟时间

原题链接：[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

> 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
>
> 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

### 1.Dijkstra

[参考题解](https://leetcode-cn.com/problems/network-delay-time/solution/wang-luo-yan-chi-shi-jian-by-leetcode-so-6phc/)

``` java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        // 表示最大值
        final int INF = Integer.MAX_VALUE / 2;

        // 二维数组g表示源节点到目标节点的距离
        // 无法到达置为INF
        int[][] g = new int[n][n];
        // 初始化二维数组g
        for (int i = 0; i < n; ++i) {
            Arrays.fill(g[i], INF);
        }

        // 将源节点到目标节点的距离填充到二维数组中
        for (int[] t : times) {
            int x = t[0] - 1, y = t[1] - 1;
            g[x][y] = t[2];
        }

        // 用数组dist表示节点k到图中各个节点的最短距离
        int[] dist = new int[n];
        // 初始化数组dist
        Arrays.fill(dist, INF);
        // 表示k到k节点的距离为0
        dist[k - 1] = 0;
        // 标记访问过的节点
        boolean[] used = new boolean[n];

        // 利用Dijkstra算法计算单源最短路径
        for (int i = 0; i < n; ++i) {
            // 1.找到图中k节点能够到达的节点中路径最短的一个节点
            int x = -1;
            for (int y = 0; y < n; ++y) {
                if (!used[y] && (x == -1 || dist[y] < dist[x])) {
                    x = y;
                }
            }

            // 2.将这个节点标记为已访问
            used[x] = true;

            // 3.把x能到达的节点更新一遍
            for (int y = 0; y < n; ++y) {
                dist[y] = Math.min(dist[y], dist[x] + g[x][y]);
            }
        }

        // k节点到达图中各个节点最短路径的最大值
        // 就是能使所有节点都收到信号的时间
        int ans = Arrays.stream(dist).max().getAsInt();
        
        // 如果这个值为INF表示有节点无法通过节点k到达
        return ans == INF ? -1 : ans;
    }
}
```

