# 2021年8月力扣每日1题

## 20210801 <font color=#009975>E</font> <font color=#009975>S</font>

### 1337. 矩阵中战斗力最弱的 K 行

原题链接：[1337. 矩阵中战斗力最弱的 K 行](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/)

> 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
>
> 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
>
> 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
>
> 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

### 1.排序

``` java
class Solution {

    // 用Row类表示每一行的信息
    // 包括行号和军人数量
    public static class Row {
        
        // 第几行
        int idx;

        // 军人数量
        int soldiers;

        Row(int idx, int soldiers) {
            this.idx = idx;
            this.soldiers = soldiers;
        }
    }

    public int[] kWeakestRows(int[][] mat, int k) {
        int m = mat.length, n = mat[0].length;

        // 统计每一行的军人数量并构建Row对象放入rows集合中
        List<Row> rows = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            int soldiers = 0;
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1) {
                    soldiers++;
                }
            }

            rows.add(new Row(i, soldiers));
        }

        // 排序：soldiers相同按idx从小到大排序
        // soldiers不相同按soldiers从小到大排序
        Collections.sort(rows, (a, b) -> {
            if (a.soldiers == b.soldiers) {
                return a.idx - b.idx;
            } else {
                return a.soldiers - b.soldiers;
            }
        });

        // 收集前k个结果并返回
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = rows.get(i).idx;
        }

        return res;
    }
}
```

