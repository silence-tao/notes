# 2021年8月力扣每日1题

## 20210801 <font color=#009975>E</font> <font color=#009975>S</font>

### 1337. 矩阵中战斗力最弱的 K 行

原题链接：[1337. 矩阵中战斗力最弱的 K 行](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/)

> 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
>
> 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
>
> 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
>
> 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

### 1.排序

``` java
class Solution {

    // 用Row类表示每一行的信息
    // 包括行号和军人数量
    public static class Row {
        
        // 第几行
        int idx;

        // 军人数量
        int soldiers;

        Row(int idx, int soldiers) {
            this.idx = idx;
            this.soldiers = soldiers;
        }
    }

    public int[] kWeakestRows(int[][] mat, int k) {
        int m = mat.length, n = mat[0].length;

        // 统计每一行的军人数量并构建Row对象放入rows集合中
        List<Row> rows = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            int soldiers = 0;
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1) {
                    soldiers++;
                }
            }

            rows.add(new Row(i, soldiers));
        }

        // 排序：soldiers相同按idx从小到大排序
        // soldiers不相同按soldiers从小到大排序
        Collections.sort(rows, (a, b) -> {
            if (a.soldiers == b.soldiers) {
                return a.idx - b.idx;
            } else {
                return a.soldiers - b.soldiers;
            }
        });

        // 收集前k个结果并返回
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = rows.get(i).idx;
        }

        return res;
    }
}
```

## 20210802 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 743. 网络延迟时间

原题链接：[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

> 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
>
> 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

### 1.Dijkstra

[参考题解](https://leetcode-cn.com/problems/network-delay-time/solution/wang-luo-yan-chi-shi-jian-by-leetcode-so-6phc/)

``` java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        // 表示最大值
        final int INF = Integer.MAX_VALUE / 2;

        // 二维数组g表示源节点到目标节点的距离
        // 无法到达置为INF
        int[][] g = new int[n][n];
        // 初始化二维数组g
        for (int i = 0; i < n; ++i) {
            Arrays.fill(g[i], INF);
        }

        // 将源节点到目标节点的距离填充到二维数组中
        for (int[] t : times) {
            int x = t[0] - 1, y = t[1] - 1;
            g[x][y] = t[2];
        }

        // 用数组dist表示节点k到图中各个节点的最短距离
        int[] dist = new int[n];
        // 初始化数组dist
        Arrays.fill(dist, INF);
        // 表示k到k节点的距离为0
        dist[k - 1] = 0;
        // 标记访问过的节点
        boolean[] used = new boolean[n];

        // 利用Dijkstra算法计算单源最短路径
        for (int i = 0; i < n; ++i) {
            // 1.找到图中k节点能够到达的节点中路径最短的一个节点
            int x = -1;
            for (int y = 0; y < n; ++y) {
                if (!used[y] && (x == -1 || dist[y] < dist[x])) {
                    x = y;
                }
            }

            // 2.将这个节点标记为已访问
            used[x] = true;

            // 3.把x能到达的节点更新一遍
            for (int y = 0; y < n; ++y) {
                dist[y] = Math.min(dist[y], dist[x] + g[x][y]);
            }
        }

        // k节点到达图中各个节点最短路径的最大值
        // 就是能使所有节点都收到信号的时间
        int ans = Arrays.stream(dist).max().getAsInt();
        
        // 如果这个值为INF表示有节点无法通过节点k到达
        return ans == INF ? -1 : ans;
    }
}
```

## 20210803 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 581. 最短无序连续子数组

原题链接：[581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

> 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
>
> 请你找出符合题意的 最短 子数组，并输出它的长度。

### 1.双指针 + 排序

[参考题解](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-e1le/)

``` java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int length = nums.length;
        // 先将数组nums复制一份放到数组clone中
		int[] clone = new int[length];
		for (int i = 0; i < length; i++) {
			clone[i] = nums[i];
		}

        // 然后对数组clone进行排序
		Arrays.sort(clone);

        // 利用双指针比较数组nums和clone不同的地方
		int i = 0, j = length - 1;
		while (i <= j && nums[i] == clone[i]) {
			i++;
		}

		while (i <= j && nums[j] == clone[j]) {
			j--;
		}
			
        // 区间[i, j]就是最短子数组
		return j - i + 1;
    }
}
```

## 20210804 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 611. 有效三角形的个数

原题链接：[611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

> 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

### 1.排序 + 二分法

[参考题解](https://leetcode-cn.com/problems/valid-triangle-number/solution/you-xiao-san-jiao-xing-de-ge-shu-by-leet-t2td/)

``` java
class Solution {
    public int triangleNumber(int[] nums) {
        int length = nums.length;

        // 要保证三元组能组成三角形，那么必须保证两边之和大于第三边
        // 这里先对数组nums升序排序
        Arrays.sort(nums);

        // 排序后的nums满足：nums[i] < nums[j] < nums[k] (i < j < k)
        // 必然有nums[i] + nums[k] > nums[j]和nums[j] + nums[k] > nums[i]
        // 那么只需要保证nums[i] + nums[j] > nums[k]即可使三元组组成三角形
        int sum = 0;
        for (int i = 0; i < length; i++) {
            for (int j = i + 1; j < length; j++) {
                // 通过二分法找到能使nums[i] + nums[j] > nums[k]成立的k的区间
                // 这个区间所有的元素都能和nums[i]与nums[j]组成三角形
                int left = j + 1, right = length - 1, k = j;
                while (left <= right) {
                    int mid = left + right >> 1;
                    if (nums[i] + nums[j] > nums[mid]) {
                        left = mid + 1;
                        k = mid;
                    } else {
                        right = mid - 1;
                    }
                }

                // (j, k]就是满足条件的区间
                sum += k - j;
            }
        }

        return sum;
    }
}
```

## 20210805 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 802. 找到最终的安全状态

原题链接：[802. 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)

> 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。
>
> 对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。
>
> 返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。
>
> 该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。
>
> 提示：
>
> n == graph.length
> 1 <= n <= 104
> 0 <= graph[i].length <= n
> graph[i] 按严格递增顺序排列。
> 图中可能包含自环。
> 图中边的数目在范围 [1, 4 * 104] 内。
>

### 1.递归

``` java
class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        int n = graph.length;

        List<Integer> res = new ArrayList<>();
        
        // 用数组visited表示节点是否被访问过
        // 其中visited[i]表示第i个节点的访问情况
        int[] visited = new int[n];
        // 1.取visited[i]值二进制的左边第一位表示是否访问过
        // 左边第一位二进制位0表示未访问，1表示已访问
        // 2.取visited[i]值二进制的左边第二位表示是否安全
        // 左边第二位二进制位0表示不安全，1表示安全
        // 所以visited[i] == 1表示已访问
        // visited[i] == 3表示已访问且安全
        for (int i = 0; i < n; i++) {
            // visited[i] == 3表示安全
            if (visited[i] == 3) {
                // 将i加入结果集合中
                res.add(i);
                
                continue ;
            }

            // 递归判断第idx个节点是否安全
            if (helper(graph, i, visited)) {
                // 安全就将visited[i]的值置为3
                visited[i] = 3;
                
				// 将i加入结果集合中
                res.add(i);
            }
        }

        return res;
    }
	
    /**
     * 递归判断第idx个节点是否安全
     * 安全返回true，否则返回false
     */
    private boolean helper(int[][] graph, int idx, int[] visited) {
        // visited[i] == 1表示已访问
        if ((visited[idx] & 1) == 1) {
            // 已访问且visited[i] == 3才表示安全
            return visited[idx] == 3;
        }

        int[] targets = graph[idx];
        // targets为空
        if (targets == null || targets.length == 0) {
            // 表示当前节点不能通向其它节点
            // 当前节点安全
            return true;
        }

        // 将当前节点标记为已访问
        visited[idx] = 1;
        for (int target : targets) {
            // 如果当前节点等于目标节点
            if (idx == target) {
                // 表示当前节点形成了自环
                // 不安全，返回false
                return false;
            }

            // 在判断当前节点连通的其它节点是否安全
            if (helper(graph, target, visited)) {
                // 当前节点通向target是安全的
                // 那么将visited[target]置为3标记target节点也安全
                visited[target] = 3;
            } else {
                // 只要有一个通向的节点不安全，那么当前节点就不安全
                return false;
            }
        }

        // 只有通向的所有节点都是安全的，当前节点才安全
        return true;
    }
}
```

## 20210806 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 847. 访问所有节点的最短路径

原题链接：[847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)

> 存在一个由 n 个节点组成的无向连通图，图中的节点按从 0 到 n - 1 编号。
>
> 给你一个数组 graph 表示这个图。其中，graph[i] 是一个列表，由所有与节点 i 直接相连的节点组成。
>
> 返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。
>
> 提示：
>
> n == graph.length
> 1 <= n <= 12
> 0 <= graph[i].length < n
> graph[i] 不包含 i
> 如果 graph[a] 包含 b ，那么 graph[b] 也包含 a
> 输入的图总是连通图

### 1.状态压缩 + 广度优先搜索

[参考题解](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/solution/fang-wen-suo-you-jie-dian-de-zui-duan-lu-mqc2/)

``` java
class Solution {
    public int shortestPathLength(int[][] graph) {
        int n = graph.length;
        Queue<int[]> queue = new LinkedList<int[]>();
        boolean[][] seen = new boolean[n][1 << n];
        for (int i = 0; i < n; ++i) {
            queue.offer(new int[]{i, 1 << i, 0});
            seen[i][1 << i] = true;
        }

        int ans = 0;
        while (!queue.isEmpty()) {
            int[] tuple = queue.poll();
            int u = tuple[0], mask = tuple[1], dist = tuple[2];
            if (mask == (1 << n) - 1) {
                ans = dist;
                break;
            }
            // 搜索相邻的节点
            for (int v : graph[u]) {
                // 将 mask 的第 v 位置为 1
                int maskV = mask | (1 << v);
                if (!seen[v][maskV]) {
                    queue.offer(new int[]{v, maskV, dist + 1});
                    seen[v][maskV] = true;
                }
            }
        }
        return ans;
    }
}
```

## 20210807 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 457. 环形数组是否存在循环

原题链接：[457. 环形数组是否存在循环](https://leetcode-cn.com/problems/circular-array-loop/)

> 存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：
>
> 如果 nums[i] 是正数，向前 移动 nums[i] 步
> 如果 nums[i] 是负数，向后 移动 nums[i] 步
> 因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。
>
> 数组中的 循环 由长度为 k 的下标序列 seq ：
>
> 遵循上述移动规则将导致重复下标序列 seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...
> 所有 nums[seq[j]] 应当不是 全正 就是 全负
> k > 1
> 如果 nums 中存在循环，返回 true ；否则，返回 false 。
>
> **提示：**
>
> - `1 <= nums.length <= 5000`
> - `-1000 <= nums[i] <= 1000`
> - `nums[i] != 0`

### 1.快慢指针

[参考题解](https://leetcode-cn.com/problems/circular-array-loop/solution/huan-xing-shu-zu-shi-fou-cun-zai-xun-hua-0ay2/)

``` java
class Solution {
    public boolean circularArrayLoop(int[] nums) {
        int length = nums.length;
        for (int i = 0; i < length; i++) {
            if (nums[i] == 0) {
                continue ;
            }

            int slow = i, fast = next(nums, i);
            while (nums[slow] * nums[fast] > 0 && nums[slow] * nums[next(nums, fast)] > 0) {
                if (slow == fast) {
                    if (slow != next(nums, slow)) {
                        return true;
                    } else {
                        break ;
                    }
                }

                slow = next(nums, slow);
                fast = next(nums, next(nums, fast));
            }

            int add = i;
            while (nums[add] * nums[next(nums, add)] > 0) {
                int temp = add;
                add = next(nums, add);
                nums[temp] = 0;
            }
        }

        return false;
    }

    private int next(int[] nums, int cur) {
        int length = nums.length;

        return ((cur + nums[cur]) % length + length) % length;
    }
}
```

## 20210808 <font color=#009975>E</font> <font color=#009975>S</font>

### 1137. 第 N 个泰波那契数

 原题链接：[1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

> 泰波那契序列 Tn 定义如下： 
>
> T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
>
> 给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

### 1.动态规划

``` java
class Solution {
    public int tribonacci(int n) {
        // n小于等于2，返回初始值
        if (n <= 2) {
            return n == 0 ? 0 : 1;
        }

        // 用x，y，z分别保存Tn，Tn+1，Tn+2的值
        int x = 0, y = 1, z = 1;
        for (int i = 3; i <= n; i++) {
            // 用t记录Tn+3的结果
            int t = x + y + z;

            // 更新Tn，Tn+1，Tn+2的值
            // 以便下一轮循环
            x = y;
            y = z;
            z = t;
        }

        return z;
    }
}
```

## 20210809 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 313. 超级丑数

原题链接：[313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)

> 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
>
> 给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
>
> 题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。

### 1.k指针法

``` java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        int[] p = new int[primes.length];   // 对应primes[i]的指针位置
        int[] ans = new int[n];
        ans[0] = 1;
        int curr = 1;   // 当前计算第curr+1个丑数
        while (curr < n){
            int next = Integer.MAX_VALUE;  
            int nextIdx = 0;
            for (int i=0; i<primes.length; ++i){
                int tmp = primes[i]*ans[p[i]];
                if (tmp > ans[curr-1] && tmp < next){ 
                    next = tmp;
                    nextIdx = i;
                }
            }
            ans[curr] = next;
            ++curr;
            for (int i=0; i<primes.length; ++i){    // 如果满足条件，对应指针+1
                if (next == primes[i]*ans[p[i]]) ++p[i];
            }
        }
        return ans[n-1];
    }
}
```

## 202108010 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 413. 等差数列划分

原题链接：[413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

> 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。
>
> 例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。
> 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。
>
> 子数组 是数组中的一个连续序列。
>
> **提示：**
>
> - `1 <= nums.length <= 5000`
> - `-1000 <= nums[i] <= 1000`

### 1.差分 + 计数

[参考题解](https://leetcode-cn.com/problems/arithmetic-slices/solution/deng-chai-shu-lie-hua-fen-by-leetcode-so-g7os/)

``` java
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int length = nums.length;
        if (length < 3) {
            return 0;
        }

        // 以nums[1]和nums[0]的差为基准，用d表示
        // t用来记录当前满足等差数列的个数
        int res = 0, d = nums[1] - nums[0], t = 0;
        // 因为至少要三个元素，所以这里从2开始
        for (int i = 2; i < length; i++) {
            // 如果nums[i]和nums[i - 1]的差和d相等
            if (nums[i] - nums[i - 1] == d) {
                // 当前个数加1
                t++;
            } else {
                // 不相等说明nums[i]和nums[i - 1]不满足等差数列
                // 将d和t重置
                d = nums[i] - nums[i - 1];
                t = 0;
            }

            // 将当前等差数列的个数累加到结果res中
            res += t;
        }

        return res;
    }
}
```

## 20210811 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 446. 等差数列划分 II - 子序列

原题链接：[446. 等差数列划分 II - 子序列](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/)

> 给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。
>
> 如果一个序列中 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该序列为等差序列。
>
> 例如，[1, 3, 5, 7, 9]、[7, 7, 7, 7] 和 [3, -1, -5, -9] 都是等差序列。
> 再例如，[1, 1, 2, 5, 7] 不是等差序列。
> 数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。
>
> 例如，[2,5,10] 是 [1,2,1,2,4,1,5,10] 的一个子序列。
> 题目数据保证答案是一个 32-bit 整数。
>
> **提示：**
>
> - `1 <= nums.length <= 1000`
> - `-231 <= nums[i] <= 231 - 1`

### 1.动态规划 + 哈希表

[参考题解](https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/solution/deng-chai-shu-lie-hua-fen-ii-zi-xu-lie-b-77pl/)

``` java
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int ans = 0;
        int n = nums.length;
        Map<Long, Integer>[] f = new Map[n];
        for (int i = 0; i < n; ++i) {
            f[i] = new HashMap<Long, Integer>();
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                long d = 1L * nums[i] - nums[j];
                int cnt = f[j].getOrDefault(d, 0);
                ans += cnt;
                f[i].put(d, f[i].getOrDefault(d, 0) + cnt + 1);
            }
        }
        return ans;
    }
}
```

## 20210812 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 516. 最长回文子序列

原题链接：[516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

> 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
>
> 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s` 仅由小写英文字母组成

### 1.动态规划

[参考题解](https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/zui-chang-hui-wen-zi-xu-lie-by-leetcode-hcjqp/)

``` java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int length = s.length();

        // 定义一个二维数组用来表示区间[i, j]最长回文串
        int[][] dp = new int[length][length];
        // 从后面往前面遍历
        for (int i = length - 1; i >= 0; i--) {
            dp[i][i] = 1;
            char c1 = s.charAt(i);
            for (int j = i + 1; j < length; j++) {
                char c2 = s.charAt(j);
                if (c1 == c2) {
                    // 如果相等，那就往[i + 1, j - 1]区间加2
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    // 不相等则取[i + 1, j]和[i, j - 1]两个区间的最大值
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        // 然后将区间[0, length - 1]的最长回文子串输出即可
        return dp[0][length - 1];
    }
}
```

## 20210813 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 233. 数字 1 的个数

原题链接：[233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)

> 给定一个整数 `n`，计算所有小于等于 `n` 的非负整数中数字 `1` 出现的个数。
>
> **提示：**
>
> - `0 <= n <= 2 * 109`

### 1.枚举

[参考题解](https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/)

``` java
class Solution {
    public int countDigitOne(int n) {
        // mulk 表示 10^k
        // 在下面的代码中，可以发现 k 并没有被直接使用到（都是使用 10^k）
        // 但为了让代码看起来更加直观，这里保留了 k
        long mulk = 1;
        int ans = 0;
        for (int k = 0; n >= mulk; ++k) {
            ans += (n / (mulk * 10)) * mulk + Math.min(Math.max(n % (mulk * 10) - mulk + 1, 0), mulk);
            mulk *= 10;
        }
        return ans;
    }
}
```

## 20210814 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 1583. 统计不开心的朋友

原题链接：[1583. 统计不开心的朋友](https://leetcode-cn.com/problems/count-unhappy-friends/)

> 给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。
>
> 对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。
>
> 所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。
>
> 但是，这样的配对情况可能会是其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：
>
> x 与 u 的亲近程度胜过 x 与 y，且
> u 与 x 的亲近程度胜过 u 与 v
> 返回 不开心的朋友的数目 。
>
> 提示：
>
> 2 <= n <= 500
> n 是偶数
> preferences.length == n
> preferences[i].length == n - 1
> 0 <= preferences[i][j] <= n - 1
> preferences[i] 不包含 i
> preferences[i] 中的所有值都是独一无二的
> pairs.length == n/2
> pairs[i].length == 2
> xi != yi
> 0 <= xi, yi <= n - 1
> 每位朋友都 恰好 被包含在一对中

### 1.模拟 + 哈希表

``` java
class Solution {
    public int unhappyFriends(int n, int[][] preferences, int[][] pairs) {
        int res = 0;

        // 用一个哈希数组保存朋友i与其它n - 1位朋友的亲近程度
        // 用哈希数组的目的是保证能在O(1)时间复杂度获取到朋友i与朋友preferences[i][j]的亲近程度
        Map<Integer, Integer>[] mapArr = new Map[n];
        for (int i = 0; i < n; i++) {
            // 创建第i位朋与的亲近程度哈希表并放入数组中
            mapArr[i] = new HashMap<>(n);
            for (int j = 0; j < n - 1; j++) {
                // 将朋友i与朋友preferences[i][j]的亲近程度j放入哈希表中
                mapArr[i].put(preferences[i][j], j);
            }
        }

        // 然后遍历配对情况，这里需要校验配对中的两位朋友分别为x的情况
        for (int i = 0; i < pairs.length; i++) {
            int[] pair = pairs[i];
            // 当pair[0]为x时
            if (helper(pair[0], pair[1], mapArr, pairs, i)) {
                res++;
            }
            // 当pair[1]为x时
            if (helper(pair[1], pair[0], mapArr, pairs, i)) {
                res++;
            }
        }

        return res;
    }

    /**
     * 校验x是否不开心
     * return false:开心;true:不开心
     */
    private boolean helper(int x, int y, Map<Integer, Integer>[] mapArr, int[][] pairs, int pos) {
        // 获取朋友x与朋友y的亲近程度
        int a = mapArr[x].get(y);
        // 如果亲近程度为0，表示x是开心的
        // 因为不可能有比0更亲近的亲近程度了
        if (a == 0) {
            return false;
        }

        // 挨个遍历pairs，找到能使x不开心的配对情况
        // 这里也要对配对关系中两位的朋友进行分别校验
        for (int i = 0; i < pairs.length; i++) {
            // 当u为pairs[i][0]
            int u = pairs[i][0], v = pairs[i][1];
            // x != u是为了避免当x和u都表示同一位朋友的情况
            // 如果x与u的亲近程度胜过x与y
            if (x != u && mapArr[x].get(u) < a) {
                // 且u与x的亲近程度胜过u与v
                if (mapArr[u].get(x) < mapArr[u].get(v)) {
                    // 表示x不开心，返回true
                    return true;
                }
            }
            
            // 当u为pairs[i][1]
            u = pairs[i][1];
            v = pairs[i][0];
            // 同上
            if (x != u && mapArr[x].get(u) < a) {
                if (mapArr[u].get(x) < mapArr[u].get(v)) {
                    return true;
                }
            }
        }

        // 如果没有找到能使x不开心的配对关系，返回
        return false;
    }
}
```

## 20210815 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 576. 出界的路径数

原题链接：[576. 出界的路径数](https://leetcode-cn.com/problems/out-of-boundary-paths/)

> 给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。
>
> 给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。
>
> **提示：**
>
> - `1 <= m, n <= 50`
> - `0 <= maxMove <= 50`
> - `0 <= startRow < m`
> - `0 <= startColumn < n`

### 1.动态规划

[参考题解](https://leetcode-cn.com/problems/out-of-boundary-paths/solution/chu-jie-de-lu-jing-shu-by-leetcode-solut-l9dw/)

``` java
class Solution {
    public int findPaths(int m, int n, int maxMove, int startRow, int startColumn) {
        int mod = 1000000007;
        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

        int res = 0;
        int[][][] dp = new int[maxMove + 1][m][n];
        dp[0][startRow][startColumn] = 1;
        for (int i = 0; i < maxMove; i++) {
            for (int j = 0; j < m; j++) {
                for (int k = 0; k < n; k++) {
                    int count = dp[i][j][k];
                    if (count > 0) {
                        for (int[] direction : directions) {
                            int x = j + direction[0], y = k + direction[1];
                            if (x >= 0 && x < m && y >= 0 && y < n) {
                                dp[i + 1][x][y] = (dp[i + 1][x][y] + count) % mod;
                            } else {
                                res = (res + count) % mod;
                            }
                        }
                    }
                }
            }
        }

        return res;
    }
}
```

## 20210816 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 526. 优美的排列

原题链接：[526. 优美的排列](https://leetcode-cn.com/problems/beautiful-arrangement/)

> 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：
>
> 第 i 位的数字能被 i 整除
> i 能被第 i 位上的数字整除
> 现在给定一个整数 N，请问可以构造多少个优美的排列？
>
> **说明:**
>
> 1. **N** 是一个正整数，并且不会超过15。

### 1.回溯

[参考题解](https://leetcode-cn.com/problems/beautiful-arrangement/solution/you-mei-de-pai-lie-by-leetcode-solution-vea2/)

``` java
class Solution {

    // 用于满足条件的排列数
    int sum = 0;
    public int countArrangement(int n) {
        // 用于标记整数是否被使用过
        boolean[] visited = new boolean[n + 1];
        // 将数组第i位满足条件的整数放到match
        List<List<Integer>> match = new ArrayList<>();
        match.add(new ArrayList<>());
        // 预处理：将符合条件的整数放入match中对应的位置
        for (int i = 1; i <= n; i++) {
            match.add(new ArrayList<>());
            for (int j = 1; j <= n; j++) {
                if (i % j == 0 || j % i == 0) {
                    // 表示满足条件
                    match.get(i).add(j);
                }
            }
        }

        helper(n, 1, visited, match);
        
        return sum;
    }

    /**
     * 回溯：找出能满足条件的排列数
     */
    private void helper(int n, int idx, boolean[] visited, List<List<Integer>> match) {
        // 如果idx == n + 1
        if (idx == n + 1) {
            // 表示数组所有位置都放入了满足条件的整数
            // 数量加1
            sum++;

            // 直接返回
            return ;
        }

        // 遍历第idx位满足条件的整数
        for (int num : match.get(idx)) {
            // 且这个整数要是之前没有被使用过的
            if (!visited[num]) {
                // 标记num被使用过
                visited[num] = true;
                // 回溯下一个位置
                helper(n, idx + 1, visited, match);
                // 恢复num为未被使用
                visited[num] = false;
            }
        }
    }
}
```

## 20210817 <font color=#009975>E</font> <font color=#009975>S</font>

### 551. 学生出勤记录 I

原题链接：[551. 学生出勤记录 I](https://leetcode-cn.com/problems/student-attendance-record-i/)

> 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
>
> 'A'：Absent，缺勤
> 'L'：Late，迟到
> 'P'：Present，到场
> 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
>
> 按 总出勤 计，学生缺勤（'A'）严格 少于两天。
> 学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。
> 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s[i]` 为 `'A'`、`'L'` 或 `'P'`

### 1.迭代

``` java
class Solution {
    public boolean checkRecord(String s) {
        int length = s.length();

        // 用a表示缺勤数
        // 用l表示连续迟到数
        int a = 0, l = 0;
        // 遍历字符串的每个字符
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            // 如果当前字符为缺勤（'A'）
            if (c == 'A') {
                // 缺勤数加1
                a++;
                // 重置连续迟到数
                // 因为出现了缺勤（'A'），迟到（'L'）必然不连续
                l = 0;

                // 如果缺勤数大于等于2
                if (a >= 2) {
                    // 不满足出勤奖励，返回false
                    return false;
                }
            } else if (c == 'L') {
                // 如果当前字符为迟到（'L'）
                // 连续迟到数加1
                l++;

                // 如果连续迟到数大于等于3
                if (l >= 3) {
                    // 不满足出勤奖励，返回false
                    return false;
                }
            } else {
                // 到了这里表示当前字符为到场（'P'）
                // 重置连续迟到数
                l = 0;
            }
        }

        // 没有出现不满足出勤奖励的情况
        // 返回true
        return true;
    }
}
```

## 20210818 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 552. 学生出勤记录 II

原题链接：[552. 学生出勤记录 II](https://leetcode-cn.com/problems/student-attendance-record-ii/)

> 可以用字符串表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
> 'A'：Absent，缺勤
> 'L'：Late，迟到
> 'P'：Present，到场
> 如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
>
> 按 总出勤 计，学生缺勤（'A'）严格 少于两天。
> 学生 不会 存在 连续 3 天或 连续 3 天以上的迟到（'L'）记录。
> 给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。答案可能很大，所以返回对 109 + 7 取余 的结果。
>
>  **提示：**
>
> - `1 <= n <= 105`

### 1.记忆化搜索

[参考题解](https://leetcode-cn.com/problems/student-attendance-record-ii/solution/gong-shui-san-xie-yi-ti-san-jie-ji-yi-hu-fdfx/)

``` java
class Solution {
    int mod = 1000000007;
    public int checkRecord(int n) {
        
        int[][][] cache = new int[n + 1][2][3];
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j < 2; j++) {
                for (int k = 0; k < 3; k++) {
                    cache[i][j][k] = -1;
                }
            }
        }

        return helper(0, 0, n, cache);
    }

    private int helper(int a, int l, int p, int[][][] cache) {
        if (a >= 2 || l >= 3) {
            return 0;
        }

        if (p == 0) {
            return 1;
        }

        if (cache[p][a][l] != -1) {
            return cache[p][a][l];
        }

        int ans = helper(a + 1, 0, p - 1, cache) % mod;
        ans = (ans + helper(a, l + 1, p - 1, cache)) % mod;
        ans = (ans + helper(a, 0, p - 1, cache)) % mod;

        cache[p][a][l] = ans;

        return ans;
    }
}
```

## 20210819 <font color=#009975>E</font> <font color=#009975>S</font>

### 345. 反转字符串中的元音字母

原题链接：[345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

> 给你一个字符串 `s` ，仅反转字符串中的所有元音字母，并返回结果字符串。
>
> 元音字母包括 `'a'`、`'e'`、`'i'`、`'o'`、`'u'`，且可能以大小写两种形式出现。
>
> **提示：**
>
> - `1 <= s.length <= 3 * 105`
> - `s` 由 **可打印的 ASCII** 字符组成

### 1.双指针

``` java
class Solution {
    public String reverseVowels(String s) {
        int length;
        if (s == null || (length = s.length()) == 0) {
            return s;
        }

        // 先将字符串里面的字符放入chars数组中
        char[] chars = new char[length];
        for (int i = 0; i < length; i++) {
            chars[i] = s.charAt(i);
        }

        // 然后利用左右指针遍历字符串中的每一个字符
        int left = 0, right = length - 1;
        while (left < right) {
            // 先遍历左边，遇到元音字母停止遍历
            while (left < right && !isVowel(s.charAt(left))) {
                left++;
            }

            // 再遍历右边，遇到元音字母停止遍历
            while (left < right && !isVowel(s.charAt(right))) {
                right--;
            }

            // 在上面的左右遍历过程中，有可能出现左右指针相遇的情况
            if (left == right) {
                // 这个时候要退出循环
                break ;
            }

            // 交换左右指针对应字符的位置
            chars[left] = s.charAt(right);
            chars[right] = s.charAt(left);

            // 左右指针分别跳到下一个位置
            left++;
            right--;
        }

        // 将转换后的结果放入StringBuilder
        StringBuilder builder = new StringBuilder();
        for (char c : chars) {
            builder.append(c);
        }

        // 返回
        return builder.toString();
    }

    /**
     * 判断字母是否为元音字母
     */
    private boolean isVowel(char c) {
        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
                || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';
    }
}
```

