

# 2022年1月力扣每日1题

## 20220101 <font color=#009975>E</font> <font color=#009975>S</font>

### 2022. 将一维数组转变成二维数组

原题链接：[2022. 将一维数组转变成二维数组](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)

> 给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和  n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。
>
> original 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。
>
> 请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。
>
> 提示：
>
> 1 <= original.length <= 5 * 104
> 1 <= original[i] <= 105
> 1 <= m, n <= 4 * 104

### 1.迭代法

``` java
class Solution {
    public int[][] construct2DArray(int[] original, int m, int n) {
        if (original.length != m * n) {
            return new int[0][0];
        }

        int[][] resArr = new int[m][n];
        // 遍历一维数组然后放入二维数组
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                resArr[i][j] = original[i * n + j];
            }
        }

        return resArr;
    }
}
```

## 20220102 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 390. 消除游戏

原题链接：[390. 消除游戏](https://leetcode-cn.com/problems/elimination-game/)

> 列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。请你对 arr 应用下述算法：
>
> 从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
> 重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
> 不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
> 给你整数 n ，返回 arr 最后剩下的数字。
>
> **提示：**
>
> - `1 <= n <= 109`

### 1.等差数列模拟

[参考题解](https://leetcode-cn.com/problems/elimination-game/solution/xiao-chu-you-xi-by-leetcode-solution-ydpb/)

``` java
class Solution {
    public int lastRemaining(int n) {
        int a1 = 1;
        int k = 0, cnt = n, step = 1;

        while (cnt > 1) {
            if (k % 2 == 0) { // 正向
                a1 = a1 + step;
            } else { // 反向
                a1 = (cnt % 2 == 0) ? a1 : a1 + step;
            }
            
            k++;
            cnt = cnt >> 1;
            step = step << 1;
        }

        return a1;
    }
}
```

## 20220103 <font color=#009975>E</font> <font color=#ed7336>R</font>

### 1185. 一周中的第几天

原题链接：[1185. 一周中的第几天](https://leetcode-cn.com/problems/day-of-the-week/)

> 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。
>
> 输入为三个整数：day、month 和 year，分别表示日、月、年。
>
> 您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。
>
> **提示：**
>
> - 给出的日期一定是在 `1971` 到 `2100` 年之间的有效日期。

### 1.模拟

[参考题解](https://leetcode-cn.com/problems/day-of-the-week/solution/yi-zhou-zhong-de-di-ji-tian-by-leetcode-w43iw/)

``` java
class Solution {
    public String dayOfTheWeek(int day, int month, int year) {
        String[] weeks = new String[] {"Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"};
        int[] monthDays = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30};

        // 输入年份之前的年份天数贡献
        int days = 365 * (year - 1971) + (year - 1969) / 4;
        // 输入月份的天数贡献
        for (int i = 0; i < month - 1; i++) {
            days += monthDays[i];
        }

        if (month > 2 && (year % 400 == 0 || (year % 4 == 0 && year % 100 != 0))) {
            days++;
        }

        // 输入日份的天数贡献
        days += day;

        return weeks[(days + 3) % 7];
    }
}
```

## 20220104 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 913. 猫和老鼠

原题链接：[913. 猫和老鼠](https://leetcode-cn.com/problems/cat-and-mouse/)

> 两位玩家分别扮演猫和老鼠，在一张 无向 图上进行游戏，两人轮流行动。
>
> 图的形式是：graph[a] 是一个列表，由满足 ab 是图中的一条边的所有节点 b 组成。
>
> 老鼠从节点 1 开始，第一个出发；猫从节点 2 开始，第二个出发。在节点 0 处有一个洞。
>
> 在每个玩家的行动中，他们 必须 沿着图中与所在当前位置连通的一条边移动。例如，如果老鼠在节点 1 ，那么它必须移动到 graph[1] 中的任一节点。
>
> 此外，猫无法移动到洞中（节点 0）。
>
> 然后，游戏在出现以下三种情形之一时结束：
>
> 如果猫和老鼠出现在同一个节点，猫获胜。
> 如果老鼠到达洞中，老鼠获胜。
> 如果某一位置重复出现（即，玩家的位置和移动顺序都与上一次行动相同），游戏平局。
> 给你一张图 graph ，并假设两位玩家都都以最佳状态参与游戏：
>
> 如果老鼠获胜，则返回 1；
> 如果猫获胜，则返回 2；
> 如果平局，则返回 0 。
>
> 提示：
>
> 3 <= graph.length <= 50
> 1 <= graph[i].length < graph.length
> 0 <= graph[i][j] < graph.length
> graph[i][j] != i
> graph[i] 互不相同
> 猫和老鼠在游戏中总是移动

### 1.动态规划

[参考题解](https://leetcode-cn.com/problems/cat-and-mouse/solution/mao-he-lao-shu-by-leetcode-solution-444x/)

``` java
class Solution {
    static final int MOUSE_WIN = 1;
    static final int CAT_WIN = 2;
    static final int DRAW = 0;
    int n;
    int[][] graph;
    int[][][] dp;

    public int catMouseGame(int[][] graph) {
        this.n = graph.length;
        this.graph = graph;
        this.dp = new int[n][n][n * 2];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                Arrays.fill(dp[i][j], -1);
            }
        }
        return getResult(1, 2, 0);
    }

    public int getResult(int mouse, int cat, int turns) {
        if (turns == n * 2) {
            return DRAW;
        }
        if (dp[mouse][cat][turns] < 0) {
            if (mouse == 0) {
                dp[mouse][cat][turns] = MOUSE_WIN;
            } else if (cat == mouse) {
                dp[mouse][cat][turns] = CAT_WIN;
            } else {
                getNextResult(mouse, cat, turns);
            }
        }
        return dp[mouse][cat][turns];
    }

    public void getNextResult(int mouse, int cat, int turns) {
        int curMove = turns % 2 == 0 ? mouse : cat;
        int defaultResult = curMove == mouse ? CAT_WIN : MOUSE_WIN;
        int result = defaultResult;
        int[] nextNodes = graph[curMove];
        for (int next : nextNodes) {
            if (curMove == cat && next == 0) {
                continue;
            }
            int nextMouse = curMove == mouse ? next : mouse;
            int nextCat = curMove == cat ? next : cat;
            int nextResult = getResult(nextMouse, nextCat, turns + 1);
            if (nextResult != defaultResult) {
                result = nextResult;
                if (result != DRAW) {
                    break;
                }
            }
        }
        dp[mouse][cat][turns] = result;
    }
}
```

## 20220105 <font color=#009975>E</font> <font color=#009975>S</font>

### 1576. 替换所有的问号

原题链接：[1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)

> 给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。
>
> 注意：你 不能 修改非 '?' 字符。
>
> 题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。
>
> 在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。
>
> **提示：**
>
> - `1 <= s.length <= 100`
> - `s` 仅包含小写英文字母和 `'?'` 字符

### 1.模拟

``` java
class Solution {
    public String modifyString(String s) {
        int length = s.length();

        char[] arr = s.toCharArray();
        for (int i = 0; i < length; i++) {
            if (arr[i] == '?') {
                for (char c = 'a'; c <= 'c'; c++) {
                    // 只要保证?左右的字符和新添加的字符不一样即可
                    if ((i > 0 && arr[i - 1] == c) || (i + 1 < length && arr[i + 1] == c)) {
                        continue ;
                    }

                    arr[i] = c;
                    break ;
                }
            }
        }

        return new String(arr);
    }
}
```

## 20220106 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 71. 简化路径

原题链接：[71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)

> 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。
>
> 在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。
>
> 请注意，返回的 规范路径 必须遵循下述格式：
>
> 始终以斜杠 '/' 开头。
> 两个目录名之间必须只有一个斜杠 '/' 。
> 最后一个目录名（如果存在）不能 以 '/' 结尾。
> 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
> 返回简化后得到的 规范路径 。
>
> 提示：
>
> 1 <= path.length <= 3000
> path 由英文字母，数字，'.'，'/' 或 '_' 组成。
> path 是一个有效的 Unix 风格绝对路径。

### 1.队列

``` java
class Solution {
    public String simplifyPath(String path) {
        // 先将path用/分隔成字符串数组
        String[] names = path.split("/");
        // 用队列保存path中的有效路径名称
        LinkedList<String> queue = new LinkedList<>();
        for (String name : names) {
            // 如果当前是..表示要返回上一级目录
            if ("..".equals(name)) {
                if (!queue.isEmpty()) {
                    // 所以将队列中的最后一个元素弹出
                    queue.pollLast();
                }
            } else if (name.length() > 0 && !".".equals(name)) {
                // 如果当前名称非空且不是.
                // 那就将字符加入到队列中
                queue.offerLast(name);
            }
        }

        StringBuilder res = new StringBuilder();
        // 将队列中的名称从头到尾用/连接起来
        if (queue.isEmpty()) {
            // 如果没有有效的名称，就返回根目录/
            res.append("/");
        } else {
            while (!queue.isEmpty()) {
                res.append("/");
                res.append(queue.pollFirst());
            }
        }

        return res.toString();
    }
}
```

## 20220107 <font color=#009975>E</font> <font color=#009975>S</font>

### 1614. 括号的最大嵌套深度

原题链接：[1614. 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)

> 如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：
>
> 字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。
> 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
> 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
> 类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：
>
> depth("") = 0
> depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
> depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
> depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串
> 例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。
>
> 给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。
>
> 提示：
>
> 1 <= s.length <= 100
> s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成
> 题目数据保证括号表达式 s 是 有效的括号表达式

### 1.模拟

``` java
class Solution {
    public int maxDepth(String s) {
        char[] chars = s.toCharArray();
        // max记录最大深度，cur记录当前的深度
        int max = 0, cur = 0;
        // 遍历字符串的每一个字符
        for (char c : chars) {
            // 如果当前字符不是括号就跳过
            if (c != '(' && c != ')') {
                continue ;
            }

            // 如果是左括号
            if (c == '(') {
                // 当前深度加1
                cur++;

                // 并更新最大深度
                max = Math.max(max, cur);
            } else {
                // 否则深度减1
                cur--;
            }
        }

        return max;
    }
}
```

## 20220108 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 89. 格雷编码

原题链接：[89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)

> n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：
> 每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
> 第一个整数是 0
> 一个整数在序列中出现 不超过一次
> 每对 相邻 整数的二进制表示 恰好一位不同 ，且
> 第一个 和 最后一个 整数的二进制表示 恰好一位不同
> 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。
>
> **提示：**
>
> - `1 <= n <= 16`

### 1.二进制数转格雷码

[参考题解](https://leetcode-cn.com/problems/gray-code/solution/ge-lei-bian-ma-by-leetcode-solution-cqi7/)

``` java
class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> ret = new ArrayList<Integer>();
        for (int i = 0; i < 1 << n; i++) {
            ret.add((i >> 1) ^ i);
        }
        return ret;
    }
}
```

## 20220109 <font color=#009975>E</font> <font color=#009975>S</font>

### 1629. 按键持续时间最长的键

原题链接：[1629. 按键持续时间最长的键](https://leetcode-cn.com/problems/slowest-key/)

> LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。
>
> 给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。
>
> 测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。
>
> 注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。
>
> 请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。
>
> 提示：
>
> releaseTimes.length == n
> keysPressed.length == n
> 2 <= n <= 1000
> 1 <= releaseTimes[i] <= 109
> releaseTimes[i] < releaseTimes[i+1]
> keysPressed 仅由小写英文字母组成

### 1.迭代法

``` java
class Solution {
    public char slowestKey(int[] releaseTimes, String keysPressed) {
        int length = releaseTimes.length, max = releaseTimes[0];
        char res = keysPressed.charAt(0);

        for (int i = 1; i < length; i++) {
            char c = keysPressed.charAt(i);
            int time = releaseTimes[i] - releaseTimes[i - 1];
            if (max < time || (max == time && c > res)) {
                max = time;
                res = c;
            }
        }

        return res;
    }
}
```

