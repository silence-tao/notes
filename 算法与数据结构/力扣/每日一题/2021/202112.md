# 2021年12月力扣每日1题

## 20211201 <font color=#009975>E</font> <font color=#009975>S</font>

### 1446. 连续字符

原题链接：[1446. 连续字符](https://leetcode-cn.com/problems/consecutive-characters/)

> 给你一个字符串 `s` ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。
>
> 请你返回字符串的能量。
>
> **提示：**
>
> - `1 <= s.length <= 500`
> - `s` 只包含小写英文字母。

### 1.迭代法

``` java
class Solution {
    public int maxPower(String s) {
        int length = s.length();

        int max = 1, sum = 1;
        char a = s.charAt(0);
        for (int i = 1; i < length; i++) {
            if (a == s.charAt(i)) {
                sum++;
            } else {
                sum = 1;
                a = s.charAt(i);
            }

            max = Math.max(sum, max);
        }

        return max;
    }
}
```

## 20211202 <font color=#009975>E</font> <font color=#009975>S</font>

### 506. 相对名次

原题链接：[506. 相对名次](https://leetcode-cn.com/problems/relative-ranks/)

> 给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。
>
> 运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：
>
> 名次第 1 的运动员获金牌 "Gold Medal" 。
> 名次第 2 的运动员获银牌 "Silver Medal" 。
> 名次第 3 的运动员获铜牌 "Bronze Medal" 。
> 从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 "x"）。
> 使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。

### 1.排序 + 哈希

``` java
class Solution {
    public String[] findRelativeRanks(int[] score) {
        int length = score.length;
        int[] copy = new int[length];
        for (int i = 0; i < length; i++) {
            copy[i] = score[i];
        }

        Arrays.sort(copy);
        Map<Integer, String> memory = new HashMap<>();
        for (int i = 1; i <= length; i++) {
            int temp = copy[length - i];
            if (i == 1) {
                memory.put(temp, "Gold Medal");
            } else if (i == 2) {
                memory.put(temp, "Silver Medal");
            } else if (i == 3) {
                memory.put(temp, "Bronze Medal");
            } else {
                memory.put(temp, Integer.toString(i));
            }
        }

        String[] strs = new String[length];
        for (int i = 0; i < length; i++) {
            strs[i] = memory.get(score[i]);
        }

        return strs;
    }
}
```

## 20211203 <font color=#009975>E</font> <font color=#009975>S</font>

### 1005. K 次取反后最大化的数组和

原题链接：[1005. K 次取反后最大化的数组和](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)

> 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
>
> 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
> 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
>
> 以这种方式修改数组后，返回数组 可能的最大和 。
>
> **提示：**
>
> - `1 <= nums.length <= 104`
> - `-100 <= nums[i] <= 100`
> - `1 <= k <= 104`

### 1.贪心

``` java
class Solution {
    public int largestSumAfterKNegations(int[] nums, int k) {
        int length = nums.length;

        // 排序，把可能有的负数排到前面
        Arrays.sort(nums);
        int sum = 0;
        for (int i = 0; i < length; i++) {
            // 贪心：如果是负数，而k还有盈余，就把负数反过来
            if (nums[i] < 0 && k > 0) {
                nums[i] = -nums[i];
                k--;
            }

            sum += nums[i];
        }
        
        Arrays.sort(nums);

        // 如果k没剩，那说明能转的负数都转正了，已经是最大和，返回sum
        // 如果k有剩，说明负数已经全部转正，所以如果k还剩偶数个就自己抵消掉，不用删减
        // 如果k还剩奇数个就减掉2倍最小正数。
        return sum - (k % 2 == 0 ? 0 : 2 * nums[0]);
    }
}
```

## 20211204 <font color=#009975>E</font> <font color=#009975>S</font>

### 383. 赎金信

原题链接：[383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

> 为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。
>
> 给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。
>
> 如果可以构成，返回 true ；否则返回 false 。
>
> magazine 中的每个字符只能在 ransomNote 中使用一次。
>
> 提示：
>
> 1 <= ransomNote.length, magazine.length <= 105
> ransomNote 和 magazine 由小写英文字母组成

### 1.数组计数

``` java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
		// 用数组记录出现字符的数量
        int[] memory = new int[26];

        // 统计ransomNote中出现的字符
        for (int i = 0; i < ransomNote.length(); i++) {
            char c = ransomNote.charAt(i);
            memory[c - 'a']++;
        }

        // 将出现在magazine中的字符从memory减去
        for (int i = 0; i < magazine.length(); i++) {
            char c = magazine.charAt(i);
            int n = c - 'a';
            
            if (memory[n] > 0) {
                memory[n]--;
            }
        }

        // 校验memory中是否都为0
        for (int num : memory) {
            if (num > 0) {
                // 有一个不为0，就不符合条件
                return false;
            }
        }

        return true;
    }
}
```

## 20211205 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 372. 超级次方

原题链接：[372. 超级次方](https://leetcode-cn.com/problems/super-pow/)

> 你的任务是计算 `ab` 对 `1337` 取模，`a` 是一个正整数，`b` 是一个非常大的正整数且会以数组形式给出。
>
> **提示：**
>
> - `1 <= a <= 231 - 1`
> - `1 <= b.length <= 2000`
> - `0 <= b[i] <= 9`
> - `b` 不含前导 0

### 1.快速幂

[参考题解](https://leetcode-cn.com/problems/super-pow/solution/gong-shui-san-xie-di-gui-kuai-su-mi-ying-yx1j/)

``` java
class Solution {
    int MOD = 1337;

    public int superPow(int a, int[] b) {
        return dfs(a, b, b.length - 1);
    }

    private int dfs(int a, int[] b, int n) {
        if (n == -1) {
            return 1;
        }

        return pow(dfs(a, b, n - 1), 10) * pow(a, b[n]) % MOD;
    }

    private int pow(int a, int b) {
        int ans = 1;
        
        a = a % MOD;
        while (b-- > 0) {
            ans = ans * a % MOD;;
        }

        return ans;
    }
}
```

## 20211206 <font color=#009975>E</font> <font color=#009975>S</font>

### 1816. 截断句子

原题链接：[1816. 截断句子](https://leetcode-cn.com/problems/truncate-sentence/)

> 句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。
>
> 例如，"Hello World"、"HELLO" 和 "hello world hello world" 都是句子。
> 给你一个句子 s 和一个整数 k ，请你将 s 截断 ，使截断后的句子仅含 前 k 个单词。返回 截断 s 后得到的句子。
>
> 提示：
>
> 1 <= s.length <= 500
> k 的取值范围是 [1,  s 中单词的数目]
> s 仅由大小写英文字母和空格组成
> s 中的单词之间由单个空格隔开
> 不存在前导或尾随空格

### 1.迭代法

``` java
class Solution {
    public String truncateSentence(String s, int k) {
        int length = s.length();

        int i = 0;
        // 挨个遍历字符
        while (k > 0) {
            char c = s.charAt(i++);
            // 遇到空格或者最后一个字符k就减1
            if (c == ' ' || i == length) {
                k--;
            }
        }

        // 如果没有遍历到最后一个字符
        if (i != length) {
            // 则i要减1，因为在判断到空格的时候，i又多加
            i--;
        }

        return s.substring(0, i);
    }
}
```

## 20211207 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 1034. 边界着色

原题链接：[1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/)

> 给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
>
> 两个网格块属于同一 连通分量 需满足下述全部条件：
>
> 两个网格块颜色相同
> 在上、下、左、右任意一个方向上相邻
> 连通分量的边界 是指连通分量中满足下述条件之一的所有网格块：
>
> 在上、下、左、右四个方向上与不属于同一连通分量的网格块相邻
> 在网格的边界上（第一行/列或最后一行/列）
> 请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。
>
> 提示：
>
> m == grid.length
> n == grid[i].length
> 1 <= m, n <= 50
> 1 <= grid[i][j], color <= 1000
> 0 <= row < m
> 0 <= col < n

### 1.深度优先搜索

[参考题解](https://leetcode-cn.com/problems/coloring-a-border/solution/bian-kuang-zhao-se-by-leetcode-solution-0h5l/)

``` java
class Solution {
    public int[][] colorBorder(int[][] grid, int row, int col, int color) {
        int m = grid.length, n = grid[0].length;
        boolean[][] visited = new boolean[m][n];
        List<int[]> borders = new ArrayList<>();
        int originalColor = grid[row][col];
        visited[row][col] = true;
        dfs(grid, row, col, visited, borders, originalColor);
        for (int i = 0; i < borders.size(); i++) {
            int x = borders.get(i)[0], y = borders.get(i)[1];
            grid[x][y] = color;
        }
        return grid;
    }

    private void dfs(int[][] grid, int x, int y, boolean[][] visited, List<int[]> borders, int originalColor) {
        int m = grid.length, n = grid[0].length;
        boolean isBorder = false;
        int[][] direc = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
        for (int i = 0; i < 4; i++) {
            int nx = direc[i][0] + x, ny = direc[i][1] + y;
            if (!(nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == originalColor)) {
                isBorder = true;
            } else if (!visited[nx][ny]){
                visited[nx][ny] = true;
                dfs(grid, nx, ny, visited, borders, originalColor);
            }                
        }
        if (isBorder) {
            borders.add(new int[]{x, y});
        }
    }
}
```

## 20211208 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 689. 三个无重叠子数组的最大和

原题链接：[689. 三个无重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)

> 给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、且 3 * k 项的和最大的子数组，并返回这三个子数组。
>
> 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置（下标从 0 开始）。如果有多个结果，返回字典序最小的一个。
>
> 提示：
>
> 1 <= nums.length <= 2 * 104
> 1 <= nums[i] < 216
> 1 <= k <= floor(nums.length / 3)

### 1.滑动窗口

[参考题解](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/solution/san-ge-wu-zhong-die-zi-shu-zu-de-zui-da-4a8lb/)

``` java
class Solution {
    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {
        int[] ans = new int[3];
        int sum1 = 0, maxSum1 = 0, maxSum1Idx = 0;
        int sum2 = 0, maxSum12 = 0, maxSum12Idx1 = 0, maxSum12Idx2 = 0;
        int sum3 = 0, maxTotal = 0;
        for (int i = k * 2; i < nums.length; ++i) {
            sum1 += nums[i - k * 2];
            sum2 += nums[i - k];
            sum3 += nums[i];
            if (i >= k * 3 - 1) {
                if (sum1 > maxSum1) {
                    maxSum1 = sum1;
                    maxSum1Idx = i - k * 3 + 1;
                }
                if (maxSum1 + sum2 > maxSum12) {
                    maxSum12 = maxSum1 + sum2;
                    maxSum12Idx1 = maxSum1Idx;
                    maxSum12Idx2 = i - k * 2 + 1;
                }
                if (maxSum12 + sum3 > maxTotal) {
                    maxTotal = maxSum12 + sum3;
                    ans[0] = maxSum12Idx1;
                    ans[1] = maxSum12Idx2;
                    ans[2] = i - k + 1;
                }
                sum1 -= nums[i - k * 3 + 1];
                sum2 -= nums[i - k * 2 + 1];
                sum3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
}
```

## 20211209 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 794. 有效的井字游戏

原题链接：[794. 有效的井字游戏](https://leetcode-cn.com/problems/valid-tic-tac-toe-state/)

> 给你一个字符串数组 board 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 board 所显示的状态时，才返回 true 。
>
> 井字游戏的棋盘是一个 3 x 3 数组，由字符 ' '，'X' 和 'O' 组成。字符 ' ' 代表一个空位。
>
> 以下是井字游戏的规则：
>
> 玩家轮流将字符放入空位（' '）中。
> 玩家 1 总是放字符 'X' ，而玩家 2 总是放字符 'O' 。
> 'X' 和 'O' 只允许放置在空位中，不允许对已放有字符的位置进行填充。
> 当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。
> 当所有位置非空时，也算为游戏结束。
> 如果游戏结束，玩家不允许再放置字符。
>
> **提示：**
>
> - `board.length == 3`
> - `board[i].length == 3`
> - `board[i][j]` 为 `'X'`、`'O'` 或 `' '`

### 1.分类讨论

[参考链接](https://leetcode-cn.com/problems/valid-tic-tac-toe-state/solution/you-xiao-de-jing-zi-you-xi-by-leetcode-s-c1j3/)

``` java
class Solution {
    public boolean validTicTacToe(String[] board) {
        int xCount = 0, oCount = 0;
        for (String row : board) {
            for (char c : row.toCharArray()) {
                xCount = (c == 'X') ? (xCount + 1) : xCount;
                oCount = (c == 'O') ? (oCount + 1) : oCount;
            }
        }
        if (oCount != xCount && oCount != xCount - 1) {
            return false;
        }
        if (win(board, 'X') && oCount != xCount - 1) {
            return false;
        }
        if (win(board, 'O') && oCount != xCount) {
            return false;
        }
        return true;
    }

    public boolean win(String[] board, char p) {
        for (int i = 0; i < 3; ++i) {
            if (p == board[0].charAt(i) && p == board[1].charAt(i) && p == board[2].charAt(i)) {
                return true;
            }
            if (p == board[i].charAt(0) && p == board[i].charAt(1) && p == board[i].charAt(2)) {
                return true;
            }
        }
        if (p == board[0].charAt(0) && p == board[1].charAt(1) && p == board[2].charAt(2)) {
            return true;
        }
        if (p == board[0].charAt(2) && p == board[1].charAt(1) && p == board[2].charAt(0)) {
            return true;
        }
        return false;
    }
}
```

## 20211210 <font color=#009975>E</font> <font color=#009975>S</font>

### 748. 最短补全词

原题链接：[748. 最短补全词](https://leetcode-cn.com/problems/shortest-completing-word/)

> 给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出并返回 words 中的 最短补全词 。
>
> 补全词 是一个包含 licensePlate 中所有的字母的单词。在所有补全词中，最短的那个就是 最短补全词 。
>
> 在匹配 licensePlate 中的字母时：
>
> 忽略 licensePlate 中的 数字和空格 。
> 不区分大小写。
> 如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。
> 例如：licensePlate = "aBc 12c"，那么它的补全词应当包含字母 'a'、'b' （忽略大写）和两个 'c' 。可能的 补全词 有 "abccdef"、"caaacab" 以及 "cbca" 。
>
> 请你找出并返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 最靠前的 那个。
>
> 提示：
>
> 1 <= licensePlate.length <= 7
> licensePlate 由数字、大小写字母或空格 ' ' 组成
> 1 <= words.length <= 1000
> 1 <= words[i].length <= 15
> words[i] 由小写英文字母组成

### 1.迭代计数法

``` java
class Solution {
    public String shortestCompletingWord(String licensePlate, String[] words) {
        int[] arr = getLettersNum(licensePlate.toLowerCase());

        int min = Integer.MAX_VALUE, pos = 0;
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            if (check(arr, getLettersNum(word)) && word.length() < min) {
                min = word.length();
                pos = i;
            }
        }

        return words[pos];
    }

    private int[] getLettersNum(String letter) {
        int[] arr = new int[26];

        for (int i = 0; i < letter.length(); i++) {
            char c = letter.charAt(i);
            if (c >= 'a' && c <= 'z') {
                arr[c - 'a']++;
            }
        }

        return arr;
    }

    private boolean check(int[] arr, int[] tempArr) {
        for (int i = 0; i < 26; i++) {
            if (arr[i] > tempArr[i]) {
                return false;
            }
        }

        return true;
    }
}
```

## 20211211 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 911. 在线选举

原题链接：[911. 在线选举](https://leetcode-cn.com/problems/online-election/)

> 给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。
>
> 对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。
>
> 在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。
>
> 实现 TopVotedCandidate 类：
>
> TopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。
> int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。
>
> 提示：
>
> 1 <= persons.length <= 5000
> times.length == persons.length
> 0 <= persons[i] < persons.length
> 0 <= times[i] <= 109
> times 是一个严格递增的有序数组
> times[0] <= t <= 109
> 每个测试用例最多调用 104 次 q

### 1.预计算 + 二分查找

[参考链接](https://leetcode-cn.com/problems/online-election/solution/zai-xian-xuan-ju-by-leetcode-solution-4835/)

``` java
class TopVotedCandidate {
    // 记录每个times[i]时刻的获胜者
    private List<Integer> tops;
    // 保存候选人和选票数量的映射关系
    private Map<Integer, Integer> votesMap;
    int[] times;

    public TopVotedCandidate(int[] persons, int[] times) {
        tops = new ArrayList<>();
        votesMap = new HashMap<>();
        votesMap.put(-1, -1);

        // 当前times[i]时刻的获胜者
        int top = -1;
        // 统计每个times[i]时刻的获胜者
        // 以及候选人和选票数量的映射关系
        for (int i = 0; i < persons.length; i++) {
            int person = persons[i];
            votesMap.put(person, votesMap.getOrDefault(person, 0) + 1);
            // 在当前times[i]时刻投票完之后
            // person的选票数量大于当前获胜者
            // 则更新获胜者为person
            if (votesMap.get(person) >= votesMap.get(top)) {
                top = person;
            }

            // 将当前times[i]时刻投票完之后的获胜者放入tops集合中
            tops.add(top);
        }

        this.times = times;
    }
    
    public int q(int t) {
        // 利用二分法找到离t时刻最近的一次投票的获胜者
        // 即为t时刻的获胜者
        int left = 0, right = times.length - 1;
        while (left < right) {
            int mid = (left + right + 1) >> 1;
            if (t < times[mid]) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }

        return tops.get(left);
    }
}

/**
 * Your TopVotedCandidate object will be instantiated and called as such:
 * TopVotedCandidate obj = new TopVotedCandidate(persons, times);
 * int param_1 = obj.q(t);
 */
```

## 20211212 <font color=#009975>E</font> <font color=#009975>S</font>

### 709. 转换成小写字母

原题链接：[709. 转换成小写字母](https://leetcode-cn.com/problems/to-lower-case/)

> 给你一个字符串 `s` ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。
>
> **提示：**
>
> - `1 <= s.length <= 100`
> - `s` 由 ASCII 字符集中的可打印字符组成

### 1.JDK

``` java
class Solution {
    public String toLowerCase(String s) {
        return s.toLowerCase();
    }
}
```

## 20211213 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 807. 保持城市天际线

原题链接：[807. 保持城市天际线](https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/)

> 给你一座由 n x n 个街区组成的城市，每个街区都包含一座立方体建筑。给你一个下标从 0 开始的 n x n 整数矩阵 grid ，其中 grid[r][c] 表示坐落于 r 行 c 列的建筑物的 高度 。
>
> 城市的 天际线 是从远处观察城市时，所有建筑物形成的外部轮廓。从东、南、西、北四个主要方向观测到的 天际线 可能不同。
>
> 我们被允许为 任意数量的建筑物 的高度增加 任意增量（不同建筑物的增量可能不同） 。 高度为 0 的建筑物的高度也可以增加。然而，增加的建筑物高度 不能影响 从任何主要方向观察城市得到的 天际线 。
>
> 在 不改变 从任何主要方向观测到的城市 天际线 的前提下，返回建筑物可以增加的 最大高度增量总和 。
>
> **提示：**
>
> - `n == grid.length`
> - `n == grid[r].length`
> - `2 <= n <= 50`
> - `0 <= grid[r][c] <= 100`

### 1.贪心

[参考链接](https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/solution/bao-chi-cheng-shi-tian-ji-xian-by-leetco-n2lu/)

``` java
class Solution {
    public int maxIncreaseKeepingSkyline(int[][] grid) {
        int length = grid.length;
        // 每一行的最大值
        int[] rowMax = new int[length];
        // 每一列的最大值
        int[] colMax = new int[length];
        
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                rowMax[i] = Math.max(rowMax[i], grid[i][j]);
                colMax[j] = Math.max(colMax[j], grid[i][j]);
            }
        }

        int sum = 0;
        for (int i = 0; i < length; i++) {
            for (int j = 0; j < length; j++) {
                // 只要取当前行的最大值和当前列的最大值中较小的值
                // 减去当前值，就能得到一个不改变天际线的增量
                sum += Math.min(rowMax[i], colMax[j]) - grid[i][j];
            }
        }

        return sum;
    }
}
```

## 20211214 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 630. 课程表 III

原题链接：[630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/)

> 这里有 n 门不同的在线课程，按从 1 到 n 编号。给你一个数组 courses ，其中 courses[i] = [durationi, lastDayi] 表示第 i 门课将会 持续 上 durationi 天课，并且必须在不晚于 lastDayi 的时候完成。
>
> 你的学期从第 1 天开始。且不能同时修读两门及两门以上的课程。
>
> 返回你最多可以修读的课程数目。
>
> **提示:**
>
> - `1 <= courses.length <= 104`
> - `1 <= durationi, lastDayi <= 104`

### 1.优先队列 + 贪心

[参考题解](https://leetcode-cn.com/problems/course-schedule-iii/solution/ke-cheng-biao-iii-by-leetcode-solution-yoyz/)

``` java
class Solution {
    public int scheduleCourse(int[][] courses) {
        Arrays.sort(courses, (a, b) -> a[1] - b[1]);

        PriorityQueue<Integer> q = new PriorityQueue<Integer>((a, b) -> b - a);
        // 优先队列中所有课程的总时间
        int total = 0;

        for (int[] course : courses) {
            int ti = course[0], di = course[1];
            if (total + ti <= di) {
                total += ti;
                q.offer(ti);
            } else if (!q.isEmpty() && q.peek() > ti) {
                total -= q.poll() - ti;
                q.offer(ti);
            }
        }

        return q.size();
    }
}
```

## 20211215 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 851. 喧闹和富有

原题链接：[851. 喧闹和富有](https://leetcode-cn.com/problems/loud-and-rich/)

> 有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 "person x "。
>
> 给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。
>
> 现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。
>
> 提示：
>
> n == quiet.length
> 1 <= n <= 500
> 0 <= quiet[i] < n
> quiet 的所有值 互不相同
> 0 <= richer.length <= n * (n - 1) / 2
> 0 <= ai, bi < n
> ai != bi
> richer 中的所有数对 互不相同
> 对 richer 的观察在逻辑上是一致的
>

### 1.拓扑排序

[参考链接](https://leetcode-cn.com/problems/loud-and-rich/solution/xuan-nao-he-fu-you-by-leetcode-solution-jnzm/)

``` java
class Solution {
    public int[] loudAndRich(int[][] richer, int[] quiet) {
        int n = quiet.length;
        List<Integer>[] g = new List[n];
        for (int i = 0; i < n; ++i) {
            g[i] = new ArrayList<Integer>();
        }
        int[] inDeg = new int[n];
        for (int[] r : richer) {
            g[r[0]].add(r[1]);
            ++inDeg[r[1]];
        }

        int[] ans = new int[n];
        for (int i = 0; i < n; ++i) {
            ans[i] = i;
        }
        Queue<Integer> q = new ArrayDeque<Integer>();
        for (int i = 0; i < n; ++i) {
            if (inDeg[i] == 0) {
                q.offer(i);
            }
        }
        while (!q.isEmpty()) {
            int x = q.poll();
            for (int y : g[x]) {
                if (quiet[ans[x]] < quiet[ans[y]]) {
                    ans[y] = ans[x]; // 更新 x 的邻居的答案
                }
                if (--inDeg[y] == 0) {
                    q.offer(y);
                }
            }
        }
        return ans;
    }
}
```

## 20211216 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 1610. 可见点的最大数目

原题链接：[1610. 可见点的最大数目](https://leetcode-cn.com/problems/maximum-number-of-visible-points/)

> 给你一个点数组 points 和一个表示角度的整数 angle ，你的位置是 location ，其中 location = [posx, posy] 且 points[i] = [xi, yi] 都表示 X-Y 平面上的整数坐标。
>
> 最开始，你面向东方进行观测。你 不能 进行移动改变位置，但可以通过 自转 调整观测角度。换句话说，posx 和 posy 不能改变。你的视野范围的角度用 angle 表示， 这决定了你观测任意方向时可以多宽。设 d 为你逆时针自转旋转的度数，那么你的视野就是角度范围 [d - angle/2, d + angle/2] 所指示的那片区域。
>
> 对于每个点，如果由该点、你的位置以及从你的位置直接向东的方向形成的角度 位于你的视野中 ，那么你就可以看到它。
>
> 同一个坐标上可以有多个点。你所在的位置也可能存在一些点，但不管你的怎么旋转，总是可以看到这些点。同时，点不会阻碍你看到其他点。
>
> 返回你能看到的点的最大数目。
>
> 提示：
>
> 1 <= points.length <= 105
> points[i].length == 2
> location.length == 2
> 0 <= angle < 360
> 0 <= posx, posy, xi, yi <= 100
>

### 1.滑动窗口

[参考链接](https://leetcode-cn.com/problems/maximum-number-of-visible-points/solution/you-xiao-ke-jian-dian-de-zui-da-shu-mu-b-r1qz/)

``` java
class Solution {
    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {
        int sameCnt = 0;
        List<Double> polarDegrees = new ArrayList<>();
        int locationX = location.get(0);
        int locationY = location.get(1);
        for (int i = 0; i < points.size(); ++i) {
            int x = points.get(i).get(0);
            int y = points.get(i).get(1);
            if (x == locationX && y == locationY) {
                sameCnt++;
                continue;
            }
            Double degree = Math.atan2(y - locationY, x - locationX);
            polarDegrees.add(degree);
        }
        Collections.sort(polarDegrees);

        int m = polarDegrees.size();
        for (int i = 0; i < m; ++i) {
            polarDegrees.add(polarDegrees.get(i) + 2 * Math.PI);
        }

        int maxCnt = 0;
        int right = 0;
        double toDegree = angle * Math.PI / 180; 
        for (int i = 0; i < m; ++i) {
            Double curr = polarDegrees.get(i) + toDegree;
            while (right < polarDegrees.size() && polarDegrees.get(right) <= curr) {
                right++;
            }
            maxCnt = Math.max(maxCnt, right - i);
        }
        
        return maxCnt + sameCnt;
    }
}
```

## 20211217 <font color=#009975>E</font> <font color=#009975>S</font>

### 1518. 换酒问题

原题链接：[1518. 换酒问题](https://leetcode-cn.com/problems/water-bottles/)

> 小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。
>
> 如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。
>
> 请你计算 最多 能喝到多少瓶酒。
>
> **提示：**
>
> - `1 <= numBottles <= 100`
> - `2 <= numExchange <= 100`

### 1.贪心

``` java
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) {
        int sum = 0;

        // 有酒就喝
        while (numBottles > 0) {
            // 喝完numExchange瓶就去兑换一瓶酒
            if (numBottles >= numExchange) {
                sum += numExchange;
                numBottles = numBottles - numExchange + 1;
            } else {
                // 直到酒被喝完不能在兑换
                sum += numBottles;
                numBottles -= numBottles;
            }
        }

        return sum;
    }
}
```

## 20211218 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 419. 甲板上的战舰

原题链接：[419. 甲板上的战舰](https://leetcode-cn.com/problems/battleships-in-a-board/)

> 给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。
>
> 战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。
>
> 提示：
>
> m == board.length
> n == board[i].length
> 1 <= m, n <= 200
> board[i][j] 是 '.' 或 'X'
>

### 1.遍历扫描

[参考链接](https://leetcode-cn.com/problems/battleships-in-a-board/solution/jia-ban-shang-de-zhan-jian-by-leetcode-s-kxpc/)

``` java
class Solution {
    public int countBattleships(char[][] board) {
        int m = board.length, n = board[0].length;

        int count = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == 'X') {
                    board[i][j] = '.';

                    for (int k = i + 1; k < m && board[k][j] == 'X'; k++) {
                        board[k][j] = '.';
                    }

                    for (int k = j + 1; k < n && board[i][k] == 'X'; k++) {
                        board[i][k] = '.';
                    }

                    count++;
                }
            }
        }

        return count;
    }
}
```

## 20211219 <font color=#009975>E</font> <font color=#009975>S</font>

### 997. 找到小镇的法官

原题链接：[997. 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)

> 在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。
>
> 如果小镇的法官真的存在，那么：
>
> 小镇的法官不相信任何人。
> 每个人（除了小镇法官外）都信任小镇的法官。
> 只有一个人同时满足条件 1 和条件 2 。
> 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。
>
> 如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。
>
> 提示：
>
> 1 <= n <= 1000
> 0 <= trust.length <= 104
> trust[i].length == 2
> trust[i] 互不相同
> trust[i][0] != trust[i][1]
> 1 <= trust[i][0], trust[i][1] <= n

### 1.统计

``` java
class Solution {
    public int findJudge(int n, int[][] trust) {
        // 统计person[i]信任的人数
        int[] trustArr = new int[n + 1];
        // 统计person[i]被信任的人数
        int[] beTrustArr = new int[n + 1];

        // 遍历trust数组统计人数
        for (int i = 0; i < trust.length; i++) {
            trustArr[trust[i][0]]++;
            beTrustArr[trust[i][1]]++;
        }

        // 再遍历统计结果
        int trustMan = 1, beTrustMan = 1;
        for (int i = 1; i <= n; i++) {
            // 如果有一个人信任的人数为0
            // 且被信任的人数等于n - 1，也就是被除了自己以外的所有人信任
            // 那么这个人就是秘密法官
            if (trustArr[i] == 0 && beTrustArr[i] == n - 1) {
                return i;
            }
        }

        return -1;
    }
}
```

## 20211220 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 475. 供暖器

原题链接：[475. 供暖器](https://leetcode-cn.com/problems/heaters/)

> 冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。
>
> 在加热器的加热半径范围内的每个房屋都可以获得供暖。
>
> 现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。
>
> 说明：所有供暖器都遵循你的半径标准，加热的半径也一样。
>
> 提示：
>
> 1 <= houses.length, heaters.length <= 3 * 104
> 1 <= houses[i], heaters[i] <= 109

### 1.排序 + 二分查找

[参考链接](https://leetcode-cn.com/problems/heaters/solution/gong-nuan-qi-by-leetcode-solution-rwui/)

``` java
class Solution {
    public int findRadius(int[] houses, int[] heaters) {
        int ans = 0;
        Arrays.sort(heaters);
        for (int house : houses) {
            int i = binarySearch(heaters, house);
            int j = i + 1;
            int leftDistance = i < 0 ? Integer.MAX_VALUE : house - heaters[i];
            int rightDistance = j >= heaters.length ? Integer.MAX_VALUE : heaters[j] - house;
            int curDistance = Math.min(leftDistance, rightDistance);
            ans = Math.max(ans, curDistance);
        }
        return ans;
    }

    public int binarySearch(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        if (nums[left] > target) {
            return -1;
        }
        while (left < right) {
            int mid = (right - left + 1) / 2 + left;
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid;
            }
        }
        return left;
    }
}
```

## 20211221 <font color=#009975>E</font> <font color=#009975>S</font>

### 1154. 一年中的第几天

原题链接：[1154. 一年中的第几天](https://leetcode-cn.com/problems/day-of-the-year/)

> 给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。
>
> 通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。
>
> 提示：
>
> date.length == 10
> date[4] == date[7] == '-'，其他的 date[i] 都是数字
> date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日

### 1.累加

``` java
class Solution {
    int[] monthDay = new int[] {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    public int dayOfYear(String date) {
        String[] arr = date.split("-");

        int year = Integer.parseInt(arr[0]);
        int month = Integer.parseInt(arr[1]);
        int d = Integer.parseInt(arr[2]);

        int day = 0;
        if (month > 1) {
            for (int i = 0; i < month - 1; i++) {
                // 能被4整除并且不能被100整除
                // 或者能被4整除并且能被400整除
                // 都是闰年，二月是29天
                if (i == 1 && (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0))) {
                    day += 29;
                } else {
                    day += monthDay[i];
                }
            }
        }

        day += d;

        return day;
    }
}
```

## 20211222 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 686. 重复叠加字符串匹配

原题链接：[686. 重复叠加字符串匹配](https://leetcode-cn.com/problems/repeated-string-match/)

> 给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。
>
> 注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。
>
> **提示：**
>
> - `1 <= a.length <= 104`
> - `1 <= b.length <= 104`
> - `a` 和 `b` 由小写英文字母组成

### 1.Rabin-Karp 算法

[参考题解](https://leetcode-cn.com/problems/repeated-string-match/solution/zhong-fu-die-jia-zi-fu-chuan-pi-pei-by-l-vnye/)

``` java
class Solution {
    static final int kMod1 = 1000000007;
    static final int kMod2 = 1337;

    public int repeatedStringMatch(String a, String b) {
        int an = a.length(), bn = b.length();
        int index = strStr(a, b);
        if (index == -1) {
            return -1;
        }
        if (an - index >= bn) {
            return 1;
        }
        return (bn + index - an - 1) / an + 2;
    }

    public int strStr(String haystack, String needle) {
        int n = haystack.length(), m = needle.length();
        if (m == 0) {
            return 0;
        }

        int k1 = 1000000009;
        int k2 = 1337;
        Random random = new Random();
        int kMod1 = random.nextInt(k1) + k1;
        int kMod2 = random.nextInt(k2) + k2;

        long hashNeedle = 0;
        for (int i = 0; i < m; i++) {
            char c = needle.charAt(i);
            hashNeedle = (hashNeedle * kMod2 + c) % kMod1;
        }
        long hashHaystack = 0, extra = 1;
        for (int i = 0; i < m - 1; i++) {
            hashHaystack = (hashHaystack * kMod2 + haystack.charAt(i % n)) % kMod1;
            extra = (extra * kMod2) % kMod1;
        }
        for (int i = m - 1; (i - m + 1) < n; i++) {
            hashHaystack = (hashHaystack * kMod2 + haystack.charAt(i % n)) % kMod1;
            if (hashHaystack == hashNeedle) {
                return i - m + 1;
            }
            hashHaystack = (hashHaystack - extra * haystack.charAt((i - m + 1) % n)) % kMod1;
            hashHaystack = (hashHaystack + kMod1) % kMod1;
        }
        return -1;
    }
}
```

## 20211223 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 1044. 最长重复子串

原题链接：[1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

> 给你一个字符串 s ，考虑其所有 重复子串 ：即，s 的连续子串，在 s 中出现 2 次或更多次。这些出现之间可能存在重叠。
>
> 返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 "" 。
>
> **提示：**
>
> - `2 <= s.length <= 3 * 104`
> - `s` 由小写英文字母组成

### 1.二分查找 + Rabin-Karp 字符串编码

[参考题解](https://leetcode-cn.com/problems/longest-duplicate-substring/solution/zui-chang-zhong-fu-zi-chuan-by-leetcode-0i9rd/)

``` java
class Solution {
    public String longestDupSubstring(String s) {
        Random random = new Random();
        // 生成两个进制
        int a1 = random.nextInt(75) + 26;
        int a2 = random.nextInt(75) + 26;
        // 生成两个模
        int mod1 = random.nextInt(Integer.MAX_VALUE - 1000000007 + 1) + 1000000007;
        int mod2 = random.nextInt(Integer.MAX_VALUE - 1000000007 + 1) + 1000000007;
        int n = s.length();
        // 先对所有字符进行编码
        int[] arr = new int[n];
        for (int i = 0; i < n; ++i) {
            arr[i] = s.charAt(i) - 'a';
        }
        // 二分查找的范围是[1, n-1]
        int l = 1, r = n - 1;
        int length = 0, start = -1;
        while (l <= r) {
            int m = l + (r - l + 1) / 2;
            int idx = check(arr, m, a1, a2, mod1, mod2);
            if (idx != -1) {
                // 有重复子串，移动左边界
                l = m + 1;
                length = m;
                start = idx;
            } else {
                // 无重复子串，移动右边界
                r = m - 1;
            }
        }
        return start != -1 ? s.substring(start, start + length) : "";
    }

    public int check(int[] arr, int m, int a1, int a2, int mod1, int mod2) {
        int n = arr.length;
        long aL1 = pow(a1, m, mod1);
        long aL2 = pow(a2, m, mod2);
        long h1 = 0, h2 = 0;
        for (int i = 0; i < m; ++i) {
            h1 = (h1 * a1 % mod1 + arr[i]) % mod1;
            h2 = (h2 * a2 % mod2 + arr[i]) % mod2;
            if (h1 < 0) {
                h1 += mod1;
            }
            if (h2 < 0) {
                h2 += mod2;
            }
        }
        // 存储一个编码组合是否出现过
        Set<Long> seen = new HashSet<Long>();
        seen.add(h1 * mod2 + h2);
        for (int start = 1; start <= n - m; ++start) {
            h1 = (h1 * a1 % mod1 - arr[start - 1] * aL1 % mod1 + arr[start + m - 1]) % mod1;
            h2 = (h2 * a2 % mod2 - arr[start - 1] * aL2 % mod2 + arr[start + m - 1]) % mod2;
            if (h1 < 0) {
                h1 += mod1;
            }
            if (h2 < 0) {
                h2 += mod2;
            }

            long num = h1 * mod2 + h2;
            // 如果重复，则返回重复串的起点
            if (!seen.add(num)) {
                return start;
            }
        }
        // 没有重复，则返回-1
        return -1;
    }

    public long pow(int a, int m, int mod) {
        long ans = 1;
        long contribute = a;
        while (m > 0) {
            if (m % 2 == 1) {
                ans = ans * contribute % mod;
                if (ans < 0) {
                    ans += mod;
                }
            }
            contribute = contribute * contribute % mod;
            if (contribute < 0) {
                contribute += mod;
            }
            m /= 2;
        }
        return ans;
    }
}
```

## 20211224 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 1705. 吃苹果的最大数目

原题链接：[1705. 吃苹果的最大数目](https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/)

> 有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。
>
> 你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。
>
> 给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。
>
> 提示：
>
> apples.length == n
> days.length == n
> 1 <= n <= 2 * 104
> 0 <= apples[i], days[i] <= 2 * 104
> 只有在 apples[i] = 0 时，days[i] = 0 才成立
>

### 1.贪心 + 优先队列

[参考题解](https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/solution/chi-ping-guo-de-zui-da-shu-mu-by-leetcod-93ka/)

``` java
class Solution {
    public int eatenApples(int[] apples, int[] days) {
        int ans = 0;
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[0] - b[0]);
        int n = apples.length;
        int i = 0;

        while (i < n) {
            while (!pq.isEmpty() && pq.peek()[0] <= i) {
                pq.poll();
            }

            int rottenDay = i + days[i];
            int count = apples[i];
            if (count > 0) {
                pq.offer(new int[] {rottenDay, count});
            }

            if (!pq.isEmpty()) {
                int[] arr = pq.peek();
                arr[1]--;
                if (arr[1] == 0) {
                    pq.poll();
                }

                ans++;
            }

            i++;
        }

        while (!pq.isEmpty()) {
            while (!pq.isEmpty() && pq.peek()[0] <= i) {
                pq.poll();
            }

            if (pq.isEmpty()) {
                break;
            }

            int[] arr = pq.poll();
            int curr = Math.min(arr[0] - i, arr[1]);
            ans += curr;
            i += curr;
        }

        return ans;
    }
}

```

## 20211225 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 1609. 奇偶树

原题链接：[1609. 奇偶树](https://leetcode-cn.com/problems/even-odd-tree/)

> 如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：
>
> 二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
> 偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增
> 奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减
> 给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。
>
> **提示：**
>
> - 树中节点数在范围 `[1, 105]` 内
> - `1 <= Node.val <= 106`

### 1.队列

``` java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isEvenOddTree(TreeNode root) {
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.addFirst(root);

        int i = 0;
        while (!queue.isEmpty()) {
            List<TreeNode> list = new ArrayList<>();
            while (!queue.isEmpty()) {
                list.add(queue.removeLast());
            }

            for (int j = 0; j < list.size(); j++) {
                TreeNode node = list.get(j);
                if (i % 2 == 0) {
                    if (node.val % 2 != 1
                        || (j + 1 < list.size() && node.val >= list.get(j + 1).val)) {
                        return false;
                    }
                } else {
                    if (node.val % 2 != 0
                        || (j + 1 < list.size() && node.val <= list.get(j + 1).val)) {
                        return false;
                    }
                }

                if (node.left != null) {
                    queue.addFirst(node.left);
                }

                if (node.right != null) {
                    queue.addFirst(node.right);
                }
            }

            i++;
        }

        return true;
    }
}
```

## 20211226 <font color=#009975>E</font> <font color=#009975>S</font>

### 1078. Bigram 分词

原题链接：[1078. Bigram 分词](https://leetcode-cn.com/problems/occurrences-after-bigram/)

> 给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 "first second third" 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。
>
> 对于每种这样的情况，将第三个词 "third" 添加到答案中，并返回答案。
>
> 提示：
>
> 1 <= text.length <= 1000
> text 由小写英文字母和空格组成
> text 中的所有单词之间都由 单个空格字符 分隔
> 1 <= first.length, second.length <= 10
> first 和 second 由小写英文字母组成

### 1.字符串切割

``` java
class Solution {
    public String[] findOcurrences(String text, String first, String second) {
        String[] strs = text.split(" ");

        List<String> resList = new ArrayList<>();
        for (int i = 0; i < strs.length; i++) {
            String str = strs[i];
            if (str.equals(first)
                && i + 1 < strs.length && strs[i + 1].equals(second)
                && i + 2 < strs.length) {
                resList.add(strs[i + 2]);
            }
        }

        String[] res = new String[resList.size()];
        for (int i = 0; i < resList.size(); i++) {
            res[i] = resList.get(i);
        }

        return res;
    }
}
```

## 20211227 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 825. 适龄的朋友

原题链接：[825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/)

> 在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。
>
> 如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：
>
> age[y] <= 0.5 * age[x] + 7
> age[y] > age[x]
> age[y] > 100 && age[x] < 100
> 否则，x 将会向 y 发送一条好友请求。
>
> 注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。
>
> 返回在该社交媒体网站上产生的好友请求总数。
>
> **提示：**
>
> - `n == ages.length`
> - `1 <= n <= 2 * 104`
> - `1 <= ages[i] <= 120`

### 1.排序 + 双指针

[参考题解](https://leetcode-cn.com/problems/friends-of-appropriate-ages/solution/gua-ling-de-peng-you-by-leetcode-solutio-v7yk/)

``` java
class Solution {
    public int numFriendRequests(int[] ages) {
        int length = ages.length;
        Arrays.sort(ages);

        int left = 0, right = 0, res = 0;
        for (int age : ages) {
        	if (age < 15) {
                continue;
            }

            while (ages[left] <= 0.5 * age + 7) {
                ++left;
            }

            while (right + 1 < length && ages[right + 1] <= age) {
                ++right;
            }
            
            res += right - left;
        }

        return res;
    }
}
```

## 20211228 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 472. 连接词

原题链接：[472. 连接词](https://leetcode-cn.com/problems/concatenated-words/)

> 给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。
>
> 连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。
>
> 提示：
>
> 1 <= words.length <= 104
> 0 <= words[i].length <= 1000
> words[i] 仅由小写字母组成
> 0 <= sum(words[i].length) <= 105

### 1.字典树 + 深度优先搜索

[参考题解](https://leetcode-cn.com/problems/concatenated-words/solution/lian-jie-ci-by-leetcode-solution-mj4d/)

``` java
class Solution {
    Trie trie = new Trie();

    public List<String> findAllConcatenatedWordsInADict(String[] words) {
        List<String> ans = new ArrayList<String>();
        Arrays.sort(words, (a, b) -> a.length() - b.length());
        for (int i = 0; i < words.length; i++) {
            String word = words[i];
            if (word.length() == 0) {
                continue;
            }
            if (dfs(word, 0)) {
                ans.add(word);
            } else {
                insert(word);
            }
        }
        return ans;
    }

    public boolean dfs(String word, int start) {
        if (word.length() == start) {
            return true;
        }
        Trie node = trie;
        for (int i = start; i < word.length(); i++) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            node = node.children[index];
            if (node == null) {
                return false;
            }
            if (node.isEnd) {
                if (dfs(word, i + 1)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    public void insert(String word) {
        Trie node = trie;
        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
}

class Trie {
    Trie[] children;
    boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
}
```

## 20211229 <font color=#009975>E</font> <font color=#009975>S</font>

### 1995. 统计特殊四元组

原题链接：[1995. 统计特殊四元组](https://leetcode-cn.com/problems/count-special-quadruplets/)

> 给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：
>
> nums[a] + nums[b] + nums[c] == nums[d] ，且
> a < b < c < d
>
> **提示：**
>
> - `4 <= nums.length <= 50`
> - `1 <= nums[i] <= 100`

### 1.迭代法

``` java
class Solution {
    public int countQuadruplets(int[] nums) {
    int length = nums.length;

    	int res = 0;
    	for (int a = 0; a < length; a++) {
    		for (int b = a + 1; b < length; b++) {
    			for (int c = b + 1; c < length; c++) {
    				for (int d = c + 1; d < length; d++) {
    					if (nums[a] + nums[b] + nums[c] == nums[d]) {
    						res++;
    					}
    				}
    			}
    		}
    	}

    	return res;
    }
}
```

## 20211230 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 846. 一手顺子

原题链接：[846. 一手顺子](https://leetcode-cn.com/problems/hand-of-straights/)

> Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。
>
> 给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。
>
> **提示：**
>
> - `1 <= hand.length <= 104`
> - `0 <= hand[i] <= 109`
> - `1 <= groupSize <= hand.length`

### 1.贪心

[参考题解](https://leetcode-cn.com/problems/hand-of-straights/solution/yi-shou-shun-zi-by-leetcode-solution-4lwn/)

``` java
class Solution {
    public boolean isNStraightHand(int[] hand, int groupSize) {
        int n = hand.length;
        if (n % groupSize != 0) {
            return false;
        }
        Arrays.sort(hand);
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
        for (int x : hand) {
            cnt.put(x, cnt.getOrDefault(x, 0) + 1);
        }
        for (int x : hand) {
            if (!cnt.containsKey(x)) {
                continue;
            }
            for (int j = 0; j < groupSize; j++) {
                int num = x + j;
                if (!cnt.containsKey(num)) {
                    return false;
                }
                cnt.put(num, cnt.get(num) - 1);
                if (cnt.get(num) == 0) {
                    cnt.remove(num);
                }
            }
        }
        return true;
    }
}
```

## 20211231 <font color=#009975>E</font> <font color=#009975>S</font>

### 507. 完美数

原题链接：[507. 完美数](https://leetcode-cn.com/problems/perfect-number/)

> 对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。
>
> 给定一个 整数 n， 如果是完美数，返回 true，否则返回 false
>
> **提示：**
>
> - `1 <= num <= 108`

### 1.迭代法

``` java
class Solution {
    public boolean checkPerfectNumber(int num) {
        int sum = 0;
        
        for (int i = 1; i * 2 <= num; i++) {
            if (num % i == 0) {
                sum += i;
            }
        }

        return sum == num;
    }
}
```

