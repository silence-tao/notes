> 使用面向对象编程（OOP）有一些弊端，当需要为多个不具有继承关系的对象引入同一个公共行为时，例如日志、安全检测等，我们只有在每个对象里引用公共行为，这样程序中就产生了大量的重复代码，程序就不便于维护了，所以就有了一个对面向对象编程的补充，即**面向方面编程（AOP）**，AOP 所关注的方向是横向的，不同于 OOP 的纵向。
>
> Spring 2.0 采用 @AspectJ 注解对 POJO 进行标注，从而定义一个包含切点信息和增强横切逻辑的切面。Spring 2.0 可以将这个切面织入到匹配的目标 Bean 中。@AspectJ 注解使用 AspectJ 切点表达式语法进行切点定义，可以通过**切点函数、运算符、通配符**等高级功能进行切点定义，拥有强大的连接点描述能力。

# 1.动态 APO 的自定义标签

在 AopNamespaceHandler 中定义了 AOP 相关自定义标签的解析器，源码如下：

``` java
/**
 * AopNamespaceHandler.java
 */
public class AopNamespaceHandler extends NamespaceHandlerSupport {

	/**
	 * Register the {@link BeanDefinitionParser BeanDefinitionParsers} for the
	 * '{@code config}', '{@code spring-configured}', '{@code aspectj-autoproxy}'
	 * and '{@code scoped-proxy}' tags.
	 */
	@Override
	public void init() {
		// In 2.0 XSD as well as in 2.1 XSD.
		registerBeanDefinitionParser("config", new ConfigBeanDefinitionParser());
		registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser());
		registerBeanDefinitionDecorator("scoped-proxy", new ScopedProxyBeanDefinitionDecorator());

		// Only in 2.0 XSD: moved to context namespace as of 2.1
		registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
	}

}
```

从上面的源码中可以得知，Spring 在解析 XML 配置文件时，如果遇到了 aspectj-autoproxy 标签，就会使用 AspectJAutoProxyBeanDefinitionParser 解析器进行解析。

## 1.1 注册 AnnotationAwareAspectJAutoProxyCreator

所有解析器，因为是对 BeanDefinitionParser 接口的统一实现，入口都是从 parse 函数开始的，AspectJAutoProxyBeanDefinitionParser 的 parse 方法如下：

``` java
/**
 * AspectJAutoProxyBeanDefinitionParser.java
 * 解析自定义标签
 */
public BeanDefinition parse(Element element, ParserContext parserContext) {
    // 注册 AnnotationAwareAspectJAutoProxyCreator
    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);
    // 对于注解中子类的处理
    extendBeanDefinition(element, parserContext);
    return null;
}
```

其中 registerAspectJAnnotationAutoProxyCreatorIfNecessary 方法是关键逻辑的实现，源码如下：

``` java
/**
 * AopNamespaceUtils.java
 * 注册 AnnotationAwareAspectJAutoProxyCreator
 */
public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(
			ParserContext parserContext, Element sourceElement) {
    // 注册或升级 AnnotationAwareAspectJAutoProxyCreator
    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(
        parserContext.getRegistry(), parserContext.extractSource(sourceElement));
    // 对于 proxy-target-class 以及 expose-proxy 属性的处理
    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
    // 注册组件并通知，便于监听器做进一步处理
    // 其中 beanDefinition 的 className 为 AnnotationAwareAspectJAutoProxyCreator
    registerComponentIfNecessary(beanDefinition, parserContext);
}
```

在 registerAspectJAnnotationAutoProxyCreatorIfNecessary 方法中主要完成了 3 件事情：

1. 注册或升级 AnnotationAwareAspectJAutoProxyCreator；
2. 对 proxy-target-class 以及 expose-proxy 属性的处理；
3. 注册组件并通知。

### 1.1.1 注册或升级 AnnotationAwareAspectJAutoProxyCreator

对于 AOP 的实现，基本上都是靠 AnnotationAwareAspectJAutoProxyCreator 去完成，它可以根据 @Point 注解定义的切点来自动代理相匹配的 bean。但是为了配置简便，Spring 使用了自定义配置来帮助我们自动注册 AnnotationAwareAspectJAutoProxyCreator，其注册过程就是在这里实现的。

``` java
/**
 * AopNamespaceUtils.java
 * 注册 AnnotationAwareAspectJAutoProxyCreator
 */
public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(
			BeanDefinitionRegistry registry, @Nullable Object source) {
    return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
}

/**
 * AopNamespaceUtils.java
 * 创建自动代理创建器
 */
private static BeanDefinition registerOrEscalateApcAsRequired(
			Class<?> cls, BeanDefinitionRegistry registry, @Nullable Object source) {

    Assert.notNull(registry, "BeanDefinitionRegistry must not be null");

    // 如果已经存在了自动代理创建器
    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
        BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
        
        // 且存在的自动代理创建器与现在的不一致
        if (!cls.getName().equals(apcDefinition.getBeanClassName())) {
            int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
            int requiredPriority = findPriorityForClass(cls);
            // 那么就根据优先级来判断到底需要使用哪一个代理创建器
            if (currentPriority < requiredPriority) {
                // 改变 bean 最重要的就是改变 bean 所对应的 className 属性
                apcDefinition.setBeanClassName(cls.getName());
            }
        }
        
        // 如果已经存在自动代理创建器并且与将要创建的一致，那么无须再次创建
        return null;
    }

    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);
    beanDefinition.setSource(source);
    beanDefinition.getPropertyValues().add("order", Ordered.HIGHEST_PRECEDENCE);
    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
    return beanDefinition;
}
```

以上代码中实现了自动注册 AnnotationAwareAspectJAutoProxyCreator 类的功能，同时这里还涉及了一个优先级的问题，如果已经存在了自动代理创建器，而且存在的自动代理创建器与现在的不一致，那么需要根据优先级来判断到底需要使用哪个。

### 1.1.2 对 proxy-target-class 以及 expose-proxy 属性的处理

useClassProxyingIfNecessary 实现了对 proxy-target-class 以及 expose-proxy 属性的处理。

``` java
/**
 * AopNamespaceUtils.java
 * 处理 proxy-target-class 以及 expose-proxy 属性
 */
private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, @Nullable Element sourceElement) {
    if (sourceElement != null) {
        // 对 proxy-target-class 属性的处理
        boolean proxyTargetClass = Boolean.parseBoolean(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));
        if (proxyTargetClass) {
            AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
        }
        
        // 对 expose-proxy 属性的处理
        boolean exposeProxy = Boolean.parseBoolean(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));
        if (exposeProxy) {
            AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
        }
    }
}

/**
 * AopConfigUtils.java
 * 处理 proxy-target-class 属性
 */
public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {
    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
        definition.getPropertyValues().add("proxyTargetClass", Boolean.TRUE);
    }
}

/**
 * AopConfigUtils.java
 * 处理 expose-proxy 属性
 */
public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {
    if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
        BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
        definition.getPropertyValues().add("exposeProxy", Boolean.TRUE);
    }
}
```

1.**proxy-target-class**：Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理。（建议尽量使用 JDK 的动态代理），**如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理**。所有该目标类型实现的接口都将被代理。若该目标对象没有实现任何接口，则创建一个 CGLIB 代理。如果你希望强制使用 CGLIB 代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个问题。

- 无法通知（advise）Final方法，因为它们不能被覆写。
- 你需要将CGLIB二进制发行包放在classpath下面。

与之相较，JDK 本身就提供了动态代理，强制使用 CGLIB 代理需要将 \<aop:config\> 的 proxy-target-class 属性设为true：

``` xml
<aop:config proxy-target-class="true">...</aop:config>
```

当需要使用 CGLIB 代理和 @AspectJ 自动代理支持，可以按照以下方式设置 \<aop:aspectj-autoproxy\> 的 proxy-target-class 属性：

``` xml
<aop:aspectj-autoproxy proxy-target-class="true" />
```

2.**JDK 动态代理**：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。

3.**CGLIB 代理**：实现原理类似于 JDK 动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB 是高效的代码生成包，底层是依靠 ASM（开源的 Java 字节码编辑类库）操作字节码实现的，性能比 JDK 强。

4.**expose-proxy**：有时候目标对象内部的自我调用将无法实施切面中的增强，如下示例：

``` java
public interface Service {
    void a();
    void b();
}

public class ServiceImpl implements Service {
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void a() {
        this.b();
    }
    
    @Transactional(propagation = Propagation.REQUIRED_NEW)
    public void a() {
		
    }
}
```

此处的this指向目标对象，因此调用 this.b() 将不会执行b事务切面，即不会执行事务增强，因此 b 方法的事务定义 `@Transactional(propagation=Propagation.REQUIRES_NEW)` 将不会实施，为了解决这个问题，我们可以这样做：

``` xml
<aop:aspectj-auto proxyexpose-proxy="true" />
```

然后将以上代码中的 `this.b();` 修改为 `((AService) AopContext.currentProxy()).b();`即可。通过以上的修改便可以完成对a和b方法的同时增强。

# 2.创建 AOP 代理

那么 AnnotationAwareAspectJAutoProxyCreator 是怎么完成 AOP 操作的呢，先来看看 AnnotationAwareAspectJAutoProxyCreator 类的层次结构：

![AnnotationAwareAspectJAutoProxyCreator 类的层次结构图](../img/image-20210522175943588.png)

在类的层级中，我们看到 AnnotationAwareAspectJAutoProxyCreator 实现了 BeanPostProcessor 接口，而实现 BeanPostProcessor 后，当 Spring 加载这个 Bean 时会在实例化前调用其 postProcessAfterInitialization 方法，而我们对于 AOP 逻辑的分析也由此开始。
在父类 AbstractAutoProxyCreator 的 postProcessAfterInitialization 中代码如下：

``` java
/**
 * AbstractAutoProxyCreator.java
 * 如果 Bean 被子类标识为要代理的 bean，则使用配置的拦截器创建代理。
 */
@Override
public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
    if (bean != null) {
        // 根据给定的 bean 的 class 和 name 构建出一个 key
        // 格式：beanClassName_beanName
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
 		// 如果它适合被代理
        if (this.earlyProxyReferences.remove(cacheKey) != bean) {
            // 封装指定的 bean
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}

/**
 * AbstractAutoProxyCreator.java
 * 封装需要被代理的 bean
 */
protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
    // 如果已经处理过直接返回
    if (StringUtils.hasLength(beanName) && this.targetSourcedBeans.contains(beanName)) {
        return bean;
    }
    
    // 无须增强
    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
        return bean;
    }
    
    // 给定 bean 类是否代表一个基础设施类
    // 基础设施类不应代理，或者配置了指定 bean 不需要自动代理
    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
        this.advisedBeans.put(cacheKey, Boolean.FALSE);
        return bean;
    }

    // Create proxy if we have advice.
    // 如果存在增强方法则创建代理
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
    // 如果获取到了增强方法则需要对增强方法创建代理
    if (specificInterceptors != DO_NOT_PROXY) {
        this.advisedBeans.put(cacheKey, Boolean.TRUE);
        // 创建代理
        Object proxy = createProxy(
            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }

    this.advisedBeans.put(cacheKey, Boolean.FALSE);
    return bean;
}
```

函数中我们已经看到了代理创建的雏形。当然，真正开始之前还需要经过一些判断，比如是否已经处理过或者是否是需要跳过的 bean，而真正创建代理的代码是从 getAdvicesAndAdvisorsForBean 开始的。创建代理主要包含了两个步骤：

1. 获取增强方法或者增强器；
2. 根据获取的增强进行代理。

先看看获取增强方法的实现：

``` java
/**
 * AbstractAdvisorAutoProxyCreator.java
 * 返回是否要代理给定的 bean，需要代理则返回增强方法
 */
@Override
protected Object[] getAdvicesAndAdvisorsForBean(
    Class<?> beanClass, String beanName, @Nullable TargetSource targetSource) {

    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
    if (advisors.isEmpty()) {
        // 增强方法为空，返回 null
        return DO_NOT_PROXY;
    }
    return advisors.toArray();
}

/**
 * AbstractAdvisorAutoProxyCreator.java
 * 获取增强方法
 */
protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
    // 获取所有的增强方法
    List<Advisor> candidateAdvisors = findCandidateAdvisors();
    // 寻找所有增强方法中适用于 bean 的增强并应用
    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
    extendAdvisors(eligibleAdvisors);
    if (!eligibleAdvisors.isEmpty()) {
        eligibleAdvisors = sortAdvisors(eligibleAdvisors);
    }
    return eligibleAdvisors;
}
```

对于指定 bean 的增强方法的获取一定是包含两个步骤的：

- 获取所有的增强
- 寻找所有增强中适用于bean的增强并应用

那么 findCandidateAdvisors 与 findAdvisorsThatCanApply 便是做了这两件事情。当然，如果无法找到对应的增强器便返回 DO_NOT_PROXY，其中 DO_NOT_PROXY = null。

## 2.1 获取增强器

由于我们分析的是使用注解进行的 AOP，所以对于 findCandidateAdvisors 的实现其实是由 AnnotationAwareAspectJAutoProxyCreator 类完成的，我们继续跟踪 AnnotationAwareAspectJAutoProxyCreator 的 findCandidateAdvisors 方法。

``` java
/**
 * AnnotationAwareAspectJAutoProxyCreator.java
 * 获取所有的增强方法
 */
@Override
protected List<Advisor> findCandidateAdvisors() {
    // Add all the Spring advisors found according to superclass rules.
    // 当使用注解方式配置 AOP 的时候并不是丢弃了对 XML 配置的支持
    // 在这里调用父类方法加载配置文件中的 AOP 声明
    List<Advisor> advisors = super.findCandidateAdvisors();
    // Build Advisors for all AspectJ aspects in the bean factory.
    if (this.aspectJAdvisorsBuilder != null) {
        advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
    }
    return advisors;
}
```

AnnotationAwareAspectJAutoProxyCreator 间接继承了 AbstractAdvisorAutoProxyCreator，在实现获取增强的方法中除了保留父类的获取配置文件中定义的增强外，同时添加了获取 Bean 的注解增强的功能，那么其实现正是由 `this.aspectJAdvisorsBuilder.buildAspectJAdvisors()` 来实现的，具体流程如下：

1. 获取所有beanName，这一步骤中所有在beanFacotry中注册的Bean都会被提取出来；
2. 遍历所有beanName，并找出声明AspectJ注解的类，进行进一步的处理；
3. 对标记为AspectJ注解的类进行增强器的提取；
4. 将提取结果加入缓存。

现在我们来看看函数实现，对Spring中所有的类进行分析，提取Advisor：

``` java
/**
 * BeanFactoryAspectJAdvisorsBuilder.java
 * 在当前的 bean 工厂中查找使用了 @Aspect 注解的切面 bean
 * 并返回到代表它们的 Spring AOP 增强方法列表
 */
public List<Advisor> buildAspectJAdvisors() {
    List<String> aspectNames = this.aspectBeanNames;

    if (aspectNames == null) {
        synchronized (this) {
            aspectNames = this.aspectBeanNames;
            if (aspectNames == null) {
                List<Advisor> advisors = new ArrayList<>();
                aspectNames = new ArrayList<>();
                // 获取所有的 beanName
                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
                    this.beanFactory, Object.class, true, false);
                // 循环所有的 beanName 找出对应的增强方法
                for (String beanName : beanNames) {
                    // 不合法的 bean 则略过，由子类定义规则，默认返回 true
                    if (!isEligibleBean(beanName)) {
                        continue;
                    }
                    // We must be careful not to instantiate beans eagerly as in this case they
                    // would be cached by the Spring container but would not have been weaved.
                    // 获取对应的 bean 的类型
                    Class<?> beanType = this.beanFactory.getType(beanName);
                    if (beanType == null) {
                        continue;
                    }
                    // 如果存在 @Aspect 注解
                    if (this.advisorFactory.isAspect(beanType)) {
                        aspectNames.add(beanName);
                        AspectMetadata amd = new AspectMetadata(beanType, beanName);
                        if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
                            MetadataAwareAspectInstanceFactory factory =
                                new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
                            // 解析使用了 @Aspect 注解 bean 中的增强方法
                            List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);
                            if (this.beanFactory.isSingleton(beanName)) {
                                this.advisorsCache.put(beanName, classAdvisors);
                            }
                            else {
                                this.aspectFactoryCache.put(beanName, factory);
                            }
                            advisors.addAll(classAdvisors);
                        }
                        else {
                            // Per target or per this.
                            if (this.beanFactory.isSingleton(beanName)) {
                                throw new IllegalArgumentException("Bean with name '" + beanName +
                                                                   "' is a singleton, but aspect instantiation model is not singleton");
                            }
                            MetadataAwareAspectInstanceFactory factory =
                                new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
                            this.aspectFactoryCache.put(beanName, factory);
                            advisors.addAll(this.advisorFactory.getAdvisors(factory));
                        }
                    }
                }
                this.aspectBeanNames = aspectNames;
                return advisors;
            }
        }
    }

    if (aspectNames.isEmpty()) {
        return Collections.emptyList();
    }
    // 记录在缓存中
    List<Advisor> advisors = new ArrayList<>();
    for (String aspectName : aspectNames) {
        List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);
        if (cachedAdvisors != null) {
            advisors.addAll(cachedAdvisors);
        }
        else {
            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
            advisors.addAll(this.advisorFactory.getAdvisors(factory));
        }
    }
    return advisors;
}
```

至此，我们已经完成了 Advisor 的提取，在上面的步骤中最为重要也最为繁杂的就是增强器的获取。而这一功能委托给了 getAdvisors 方法去实现 `this.advisorFactory.getAdvisors(factory)`：

``` java
/**
 * ReflectiveAspectJAdvisorFactory.java
 * 为指定切面的实例上的所有带 AspcetJ 注解的方法创建增强方法
 */
@Override
public List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
    // 获取标记为 AspectJ 的类
    Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
    // 获取标记为 AspectJ 的 name
    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();
    // 验证
    validate(aspectClass);

    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator
    // so that it will only instantiate once.
    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =
        new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

    List<Advisor> advisors = new ArrayList<>();
    for (Method method : getAdvisorMethods(aspectClass)) {
        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);
        if (advisor != null) {
            advisors.add(advisor);
        }
    }

    // If it's a per target aspect, emit the dummy instantiating aspect.
    if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
        // 如果寻找的增强器不为空，而且又配置了增强延迟初始化
        // 那么需要在首位加入同步实例化增强器
        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
        advisors.add(0, instantiationAdvisor);
    }

    // Find introduction fields.
    // 获取 DeclareParents 注解
    for (Field field : aspectClass.getDeclaredFields()) {
        Advisor advisor = getDeclareParentsAdvisor(field);
        if (advisor != null) {
            advisors.add(advisor);
        }
    }

    return advisors;
}
```

函数中首先完成了对增强器的获取，包括获取注解以及根据注解生成增强的步骤，然后考虑到在配置中可能会将增强配置成延迟初始化，那么需要在首位加入同步实例化增强器以保证增强使用之前的实例化，最后是对 DeclareParents 注解的获取。

### 2.1.1 普通增强器的获取

普通增强器的获取逻辑通过 getAdvisor 方法实现，实现步骤包括对切点的注解的获取以及根据注解信息生成增强。

``` java
/**
 * ReflectiveAspectJAdvisorFactory.java
 * 为给定的切面方法生成增强器
 */
@Override
@Nullable
public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
                          int declarationOrderInAspect, String aspectName) {

    validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());

    // 切点信息获取
    AspectJExpressionPointcut expressionPointcut = getPointcut(candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
    if (expressionPointcut == null) {
        return null;
    }
	// 根据切点信息生成增强器
    return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod, this, aspectInstanceFactory, declarationOrderInAspect, spectName);
}
```

1.切点信息的获取：所谓获取切点信息就是指定注解的表达式信息的获取，如 `@Before("test()")`。

``` java
/**
 * ReflectiveAspectJAdvisorFactory.java
 * 切点信息的获取
 */
@Nullable
private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {
    // 获取方法上的注解
    AspectJAnnotation<?> aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
    if (aspectJAnnotation == null) {
        return null;
    }
    // 使用 AspectJExpressionPointcut 实例封装获取的信息
    AspectJExpressionPointcut ajexp =
        new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);
    // 获取得到的注解中的表达式
    // 如：@Pointcut("execution(* *.*test*(..))") 中的 execution(* *.*test*(..))
    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
    if (this.beanFactory != null) {
        ajexp.setBeanFactory(this.beanFactory);
    }
    return ajexp;
}

/**
 * AbstractAspectJAdvisorFactory.java
 * 找到并返回方法上的第一个 AspectJ 注解
 */
@SuppressWarnings("unchecked")
@Nullable
protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {
    for (Class<?> clazz : ASPECTJ_ANNOTATION_CLASSES) {
        AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) clazz);
        if (foundAnnotation != null) {
            return foundAnnotation;
        }
    }
    return null;
}

/**
 * AbstractAspectJAdvisorFactory.java
 * 获取指定方法上的注解并使用 AspectJAnnotation 封装
 */
@Nullable
private static <A extends Annotation> AspectJAnnotation<A> findAnnotation(Method method, Class<A> toLookFor) {
    A result = AnnotationUtils.findAnnotation(method, toLookFor);
    if (result != null) {
        return new AspectJAnnotation<>(result);
    }
    else {
        return null;
    }
}
```

2.根据切点信息生成增强：所有的增强都由 Advisor 的实现类 InstantiationModelAwarePointcutAdvisorImpl 同一封装。

``` java
/**
 * InstantiationModelAwarePointcutAdvisorImpl.java
 * InstantiationModelAwarePointcutAdvisorImpl 类的构造方法
 */
public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut, Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

    this.declaredPointcut = declaredPointcut;
    this.declaringClass = aspectJAdviceMethod.getDeclaringClass();
    this.methodName = aspectJAdviceMethod.getName();
    this.parameterTypes = aspectJAdviceMethod.getParameterTypes();
    this.aspectJAdviceMethod = aspectJAdviceMethod;
    this.aspectJAdvisorFactory = aspectJAdvisorFactory;
    this.aspectInstanceFactory = aspectInstanceFactory;
    this.declarationOrder = declarationOrder;
    this.aspectName = aspectName;

    if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
        // Static part of the pointcut is a lazy type.
        Pointcut preInstantiationPointcut = Pointcuts.union(
            aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);

        // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.
        // If it's not a dynamic pointcut, it may be optimized out
        // by the Spring AOP infrastructure after the first evaluation.
        this.pointcut = new PerTargetInstantiationModelPointcut(
            this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);
        this.lazy = true;
    }
    else {
        // A singleton aspect.
        this.pointcut = this.declaredPointcut;
        this.lazy = false;
        this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);
    }
}
```

在封装过程中只是简单地将信息封装在类的实例中，所有的信息单纯地赋值，在实例初始化的过程中还完成了对于增强器的初始化。因为不同的增强所体现的逻辑是不同的，比如 `@Before("test()")` 与 `@After("test()")` 标签的不同就是增强器增强的位置不同，所以就需要不同的增强器来完成不同的逻辑，而根据注解中的信息初始化对应的增强器就是在 instantiateAdvice 函数中实现的。

``` java
/**
 * InstantiationModelAwarePointcutAdvisorImpl.java
 * 初始化增强器
 */
private Advice instantiateAdvice(AspectJExpressionPointcut pointcut) {
    Advice advice = this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pointcut, this.aspectInstanceFactory, this.declarationOrder, this.aspectName);
    return (advice != null ? advice : EMPTY_ADVICE);
}

/**
 * ReflectiveAspectJAdvisorFactory.java
 * 为给定的切面方法生成增强器
 */
@Override
@Nullable
public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut, MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

    Class<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
    validate(candidateAspectClass);

    AspectJAnnotation<?> aspectJAnnotation =
        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
    if (aspectJAnnotation == null) {
        return null;
    }

    // If we get here, we know we have an AspectJ method.
    // Check that it's an AspectJ-annotated class
    if (!isAspect(candidateAspectClass)) {
        throw new AopConfigException("Advice must be declared inside an aspect type: " +
                                     "Offending method '" + candidateAdviceMethod + "' in class [" +
                                     candidateAspectClass.getName() + "]");
    }

    if (logger.isDebugEnabled()) {
        logger.debug("Found AspectJ method: " + candidateAdviceMethod);
    }

    AbstractAspectJAdvice springAdvice;
	// 根据不同的注解类型封装不同的增强器
    switch (aspectJAnnotation.getAnnotationType()) {
        case AtPointcut:
            if (logger.isDebugEnabled()) {
                logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'");
            }
            return null;
        case AtAround:
            springAdvice = new AspectJAroundAdvice(
                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            break;
        case AtBefore:
            springAdvice = new AspectJMethodBeforeAdvice(
                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            break;
        case AtAfter:
            springAdvice = new AspectJAfterAdvice(
                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            break;
        case AtAfterReturning:
            springAdvice = new AspectJAfterReturningAdvice(
                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();
            if (StringUtils.hasText(afterReturningAnnotation.returning())) {
                springAdvice.setReturningName(afterReturningAnnotation.returning());
            }
            break;
        case AtAfterThrowing:
            springAdvice = new AspectJAfterThrowingAdvice(
                candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
            AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();
            if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {
                springAdvice.setThrowingName(afterThrowingAnnotation.throwing());
            }
            break;
        default:
            throw new UnsupportedOperationException(
                "Unsupported advice type on method: " + candidateAdviceMethod);
    }

    // Now to configure the advice...
    springAdvice.setAspectName(aspectName);
    springAdvice.setDeclarationOrder(declarationOrder);
    String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);
    if (argNames != null) {
        springAdvice.setArgumentNamesFromStringArray(argNames);
    }
    springAdvice.calculateArgumentBindings();

    return springAdvice;
}
```

从函数中可以看到，Spring 会根据不同的注解生成不同的增强器。

- MethodBeforeAdviceInterceptor

``` java
/**
 * MethodBeforeAdviceInterceptor.java
 * 包装 MethodBeforeAdvice 类的拦截器
 */
@SuppressWarnings("serial")
public class MethodBeforeAdviceInterceptor implements MethodInterceptor, BeforeAdvice, Serializable {

	private final MethodBeforeAdvice advice;


	/**
	 * Create a new MethodBeforeAdviceInterceptor for the given advice.
	 * @param advice the MethodBeforeAdvice to wrap
	 */
	public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
		Assert.notNull(advice, "Advice must not be null");
		this.advice = advice;
	}


	@Override
	public Object invoke(MethodInvocation mi) throws Throwable {
		this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());
		return mi.proceed();
	}

}
```

其中的属性 MethodBeforeAdvice 代表着前置增强的 AspectJMethodBeforeAdvice，跟踪 before 方法：

``` java
/**
 * AspectJMethodBeforeAdvice.java
 * 调用给定方法之前的回调
 */
@Override
public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {
    invokeAdviceMethod(getJoinPointMatch(), null, null);
}

/**
 * AbstractAspectJAdvice.java
 * 调用增强方法
 */
protected Object invokeAdviceMethod(
    @Nullable JoinPointMatch jpMatch, @Nullable Object returnValue, @Nullable Throwable ex)
    throws Throwable {

    return invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));
}

/**
 * AbstractAspectJAdvice.java
 * 实现对增强方法的调用
 */
protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {
    Object[] actualArgs = args;
    if (this.aspectJAdviceMethod.getParameterCount() == 0) {
        actualArgs = null;
    }
    try {
        ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);
        // TODO AopUtils.invokeJoinpointUsingReflection
        // 激活增强方法
        return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
    }
    catch (IllegalArgumentException ex) {
        throw new AopInvocationException("Mismatch on arguments to advice method [" +
                                         this.aspectJAdviceMethod + "]; pointcut expression [" +
                                         this.pointcut.getPointcutExpression() + "]", ex);
    }
    catch (InvocationTargetException ex) {
        throw ex.getTargetException();
    }
}
```

invokeAdviceMethodWithGivenArgs 方法中的 aspectJAdviceMethod 正是对于前置增强的方法，在这里实现了调用。

- AspectJAfterAdvice

后置增强与前置增强有稍许不一致的地方。回顾之前讲过的前置增强，大致的结构是在拦截器链中放置 MethodBeforeAdviceInterceptor，而在 MethodBeforeAdviceInterceptor 中又放置了 AspectJMethodBeforeAdvice，并在调用 invoke 时首先串联调用。但是在后置增强的时候却不一样，没有提供中间的类，而是直接在拦截器链中使用了中间的 AspectJAfterAdvice。

``` java
/**
 * AspectJAfterAdvice.java
 * Spring AOP 后置通知包装类
 */
public class AspectJAfterAdvice extends AbstractAspectJAdvice
		implements MethodInterceptor, AfterAdvice, Serializable {

	public AspectJAfterAdvice(
			Method aspectJBeforeAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif) {

		super(aspectJBeforeAdviceMethod, pointcut, aif);
	}


	@Override
	public Object invoke(MethodInvocation mi) throws Throwable {
		try {
			return mi.proceed();
		}
		finally {
            // 激活增强方法
			invokeAdviceMethod(getJoinPointMatch(), null, null);
		}
	}

	@Override
	public boolean isBeforeAdvice() {
		return false;
	}

	@Override
	public boolean isAfterAdvice() {
		return true;
	}

}
```

### 2.2.2 增强同步实例化增强器

如果寻找的增强器不为空而且又配置了增强延迟初始化，那么就需要在首位加入同步实例化增强器。同步实例化增强器 SyntheticInstantiationAdvisor 如下：

``` java
/**
 * ReflectiveAspectJAdvisorFactory.java
 * 同步实例化增强器
 */
protected static class SyntheticInstantiationAdvisor extends DefaultPointcutAdvisor {

    public SyntheticInstantiationAdvisor(final MetadataAwareAspectInstanceFactory aif) {
        // 目标方法前调用，类似 @Before
        super(aif.getAspectMetadata().getPerClausePointcut(), (MethodBeforeAdvice)
              // 简单初始化 aspect
              (method, args, target) -> aif.getAspectInstance());
    }
}
```

### 2.2.3 获取 DeclareParents 注解

DeclareParents 主要用于引介增强的注解形式的实现，而其实现方式与普通增强很类似，只不过使用 DeclareParentsAdvisor 对功能进行封装。

``` java
/**
 * ReflectiveAspectJAdvisorFactory.java
 * 获取 DeclareParents 注解
 */
@Nullable
private Advisor getDeclareParentsAdvisor(Field introductionField) {
    DeclareParents declareParents = introductionField.getAnnotation(DeclareParents.class);
    if (declareParents == null) {
        // Not an introduction field
        return null;
    }

    if (DeclareParents.class == declareParents.defaultImpl()) {
        throw new IllegalStateException("'defaultImpl' attribute must be set on DeclareParents");
    }

    return new DeclareParentsAdvisor(
        introductionField.getType(), declareParents.value(), declareParents.defaultImpl());
}
```

## 2.2 寻找匹配的增强器

前面的函数中已经完成了所有增强器的解析，但是对于所有增强器来讲，并不一定都适用于当前的 Bean，还要挑取出适合的增强器，也就是满足我们配置的通配符的增强器。具体实现在 findAdvisorsThatCanApply 中：

``` java
/**
 * AbstractAdvisorAutoProxyCreator.java
 * 在给定的增强器中搜索可应用于指定 bean 的所有增强器
 */
protected List<Advisor> findAdvisorsThatCanApply(
    List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {

    ProxyCreationContext.setCurrentProxiedBeanName(beanName);
    try {
        // 过滤已经得到的 advisors
        return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
    }
    finally {
        ProxyCreationContext.setCurrentProxiedBeanName(null);
    }
}

/**
 * AopUtils.java
 * 确定适用于给定类的 codeCandidateAdvisors 列表的子列表
 */
public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {
    if (candidateAdvisors.isEmpty()) {
        return candidateAdvisors;
    }
    // 首先处理引介增强
    List<Advisor> eligibleAdvisors = new ArrayList<>();
    for (Advisor candidate : candidateAdvisors) {
        if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {
            eligibleAdvisors.add(candidate);
        }
    }
    boolean hasIntroductions = !eligibleAdvisors.isEmpty();
    for (Advisor candidate : candidateAdvisors) {
        // 引介增强已处理
        if (candidate instanceof IntroductionAdvisor) {
            // already processed
            continue;
        }
        // 对于普通 bean 的处理
        if (canApply(candidate, clazz, hasIntroductions)) {
            eligibleAdvisors.add(candidate);
        }
    }
    return eligibleAdvisors;
}
```

findAdvisorsThatCanApply 函数的主要功能是寻找所有增强器中适用于当前 class 的增强器。引介增强与普通的增强是处理不一样的，所以分开处理。而对于真正的匹配在 canApply 中实现。

``` java
/**
 * AopUtils.java
 * 给定的增强器是否可以应用于 targetClass
 */
public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {
    if (advisor instanceof IntroductionAdvisor) {
        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
    }
    else if (advisor instanceof PointcutAdvisor) {
        PointcutAdvisor pca = (PointcutAdvisor) advisor;
        return canApply(pca.getPointcut(), targetClass, hasIntroductions);
    }
    else {
        // It doesn't have a pointcut so we assume it applies.
        return true;
    }
}

/**
 * AopUtils.java
 * 给定的增强器是否可以应用于 targetClass
 */
public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {
    Assert.notNull(pc, "Pointcut must not be null");
    if (!pc.getClassFilter().matches(targetClass)) {
        return false;
    }

    MethodMatcher methodMatcher = pc.getMethodMatcher();
    if (methodMatcher == MethodMatcher.TRUE) {
        // No need to iterate the methods if we're matching any method anyway...
        return true;
    }

    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
    }

    Set<Class<?>> classes = new LinkedHashSet<>();
    if (!Proxy.isProxyClass(targetClass)) {
        classes.add(ClassUtils.getUserClass(targetClass));
    }
    classes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetClass));

    // 遍历方法，判断方法是否能匹配
    for (Class<?> clazz : classes) {
        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
        for (Method method : methods) {
            if (introductionAwareMethodMatcher != null ?
                introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions) :
                methodMatcher.matches(method, targetClass)) {
                return true;
            }
        }
    }

    return false;
}
```

## 2.3 创建代理

在获取了所有对应的 bean 的增强器后，便可以进行代理的创建了：

``` java
/**
 * AbstractAutoProxyCreator.java
 * 为当前类创建代理
 */
protected Object createProxy(Class<?> beanClass, @Nullable String beanName,
                             @Nullable Object[] specificInterceptors, TargetSource targetSource) {

    if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
    }

    ProxyFactory proxyFactory = new ProxyFactory();
    // 获取当前类中相关属性
    proxyFactory.copyFrom(this);

    // 决定对于给定的 bean 是否应该使用 targetClass 而不是它的接口代理
    if (!proxyFactory.isProxyTargetClass()) {
        // 检查 proxyTargetClass 设置以及 preserveTargetClass 属性
        if (shouldProxyTargetClass(beanClass, beanName)) {
            proxyFactory.setProxyTargetClass(true);
        }
        else {
            // 添加代理接口
            evaluateProxyInterfaces(beanClass, proxyFactory);
        }
    }
	
    // 将拦截器封装为增强器
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    // 加入增强器
    proxyFactory.addAdvisors(advisors);
    // 设置要代理的类
    proxyFactory.setTargetSource(targetSource);
    // 定制代理
    customizeProxyFactory(proxyFactory);
	// 用来控制代理工厂被配置之后，是否还允许修改通知
    // 缺省值为 false（即在代理被配置之后，不允许修改代理的配置）
    proxyFactory.setFrozen(this.freezeProxy);
    if (advisorsPreFiltered()) {
        proxyFactory.setPreFiltered(true);
    }

    return proxyFactory.getProxy(getProxyClassLoader());
}

/**
 * ProxyProcessorSupport.java
 * 检查给定 bean 类上的接口并将它们应用到 ProxyFactory，如果合适的话。
 */
protected void evaluateProxyInterfaces(Class<?> beanClass, ProxyFactory proxyFactory) {
    Class<?>[] targetInterfaces = ClassUtils.getAllInterfacesForClass(beanClass, getProxyClassLoader());
    boolean hasReasonableProxyInterface = false;
    for (Class<?> ifc : targetInterfaces) {
        if (!isConfigurationCallbackInterface(ifc) && !isInternalLanguageInterface(ifc) && ifc.getMethods().length > 0) {
            hasReasonableProxyInterface = true;
            break;
        }
    }
    if (hasReasonableProxyInterface) {
        // Must allow for introductions; can't just set interfaces to the target's interfaces only.
        for (Class<?> ifc : targetInterfaces) {
            proxyFactory.addInterface(ifc);
        }
    }
    else {
        proxyFactory.setProxyTargetClass(true);
    }
}
```

对于代理类的创建及处理，Spring 委托给了 ProxyFactory 去处理，而在 createProxy 函数中主要是对 ProxyFactory 的初始化操作，进而对真正的创建代理做准备，这些初始化操作包括如下内容：
1. 获取当前类中的属性；
2. 添加代理接口；
3. 封装 Advisor 并加入到 ProxyFactory 中；
4. 设置要代理的类；
5. 当然在 Spring 中还为子类提供了定制的函数 customizeProxyFactory，子类可以在此函数中进行对 ProxyFactory 的进一步封装；
6. 进行获取代理操作。

其中，封装 Advisor 并加入到 ProxyFactory 中以及创建代理是两个相对繁琐的过程，可以通过 ProxyFactory 提供的 addAdvisors 方法直接将增强器置入代理创建工厂中，但是将拦截器封装为增强器还是需要一定的逻辑的，具体代码如下：

``` java
/**
 * AbstractAutoProxyCreator.java
 * 将拦截器封装为增强器
 */
protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) {
    // Handle prototypes correctly...
    // 解析注册的所有 interceptorName
    Advisor[] commonInterceptors = resolveInterceptorNames();

    List<Object> allInterceptors = new ArrayList<>();
    if (specificInterceptors != null) {
        // 加入拦截器
        allInterceptors.addAll(Arrays.asList(specificInterceptors));
        if (commonInterceptors.length > 0) {
            if (this.applyCommonInterceptorsFirst) {
                allInterceptors.addAll(0, Arrays.asList(commonInterceptors));
            }
            else {
                allInterceptors.addAll(Arrays.asList(commonInterceptors));
            }
        }
    }
    if (logger.isTraceEnabled()) {
        int nrOfCommonInterceptors = commonInterceptors.length;
        int nrOfSpecificInterceptors = (specificInterceptors != null ? specificInterceptors.length : 0);
        logger.trace("Creating implicit proxy for bean '" + beanName + "' with " + nrOfCommonInterceptors +
                     " common interceptors and " + nrOfSpecificInterceptors + " specific interceptors");
    }

    Advisor[] advisors = new Advisor[allInterceptors.size()];
    for (int i = 0; i < allInterceptors.size(); i++) {
        // 拦截器进行封装转化为 Advisor
        advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));
    }
    return advisors;
}

/**
 * DefaultAdvisorAdapterRegistry.java
 * 拦截器进行封装转化为 Advisor
 */
public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException {
    // 如果要封装的对象本身就是 Advisor 类型的，那么无须再做过多的处理
    if (adviceObject instanceof Advisor) {
        return (Advisor) adviceObject;
    }
    // 因为此封装方法只对 Advisor 与 Advice 两种类型的数据有效，如果不是将不能封装
    if (!(adviceObject instanceof Advice)) {
        throw new UnknownAdviceTypeException(adviceObject);
    }
    Advice advice = (Advice) adviceObject;
    if (advice instanceof MethodInterceptor) {
        // So well-known it doesn't even need an adapter.
        // 如果是 MethodInterceptor 类型则使用 DefaultPointcutAdvisor 封装
        return new DefaultPointcutAdvisor(advice);
    }
    // 如果存在 Advisor 的适配器那么也同样需要进行封装
    for (AdvisorAdapter adapter : this.adapters) {
        // Check that it is supported.
        if (adapter.supportsAdvice(advice)) {
            return new DefaultPointcutAdvisor(advice);
        }
    }
    throw new UnknownAdviceTypeException(advice);
}
```

由于 Spring 中涉及过多的拦截器、增强器、增强方法等方式来对逻辑进行增强，所以非常有必要统一封装成 Advisor 来进行代理的创建，完成了增强的封装过程，那么解析最重要的一步就是代理的创建与获取了。

``` java
/**
 * ProxyFactory.java
 * 创建代理
 */
public Object getProxy(@Nullable ClassLoader classLoader) {
    return createAopProxy().getProxy(classLoader);
}
```

再来看看创建代理类的具体实现：

``` java
/**
 * ProxyCreatorSupport.java
 * 获取 AOP 代理策略
 */
protected final synchronized AopProxy createAopProxy() {
    if (!this.active) {
        activate();
    }
    // 选择代理策略
    return getAopProxyFactory().createAopProxy(this);
}

/**
 * DefaultAopProxyFactory.java
 * 选择 AOP 代理策略
 */
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
        Class<?> targetClass = config.getTargetClass();
        if (targetClass == null) {
            throw new AopConfigException("TargetSource cannot determine target class: " +
                                         "Either an interface or a target is required for proxy creation.");
        }
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
	        // 使用 jdk 动态代理创建代理类
            return new JdkDynamicAopProxy(config);
        }
        
        // 使用 Cglib 创建动态代理类
        return new ObjenesisCglibAopProxy(config);
    }
    else {
        // 使用 jdk 动态代理创建代理类
        return new JdkDynamicAopProxy(config);
    }
}
```

现在可以从源码的角度来分析 Spring 中的代理类是由 JDKProxy（JDK 动态代理）还是由 CglibProxy（Cglib 动态代理）来创建的，从 if 中的判断条件可以看到 3 个方面影响着 Spring 的判断：

- optimize：用来控制通过 CGLIB 创建的代理是否使用激进的优化策略。除非完全了解 AOP 代理如何处理优化，否则不推荐用户使用这个设置。目前这个属性仅用于 CGLIB 代理，对于 JDK 动态代理（缺省代理）无效；
- proxyTargetClass：这个属性为 true 时，目标类本身被代理而不是目标类的接口。如果这个属性值被设为 true，CGLIB 代理将被创建，设置方式：`<aop:aspectj-autoproxyproxy-target-class="true"/>`；
- hasNoUserSuppliedProxyInterfaces：是否存在代理接口。

下面是对 JDK 与 Cglib 方式的总结：
- **如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理实现 AOP**；
- **如果目标对象实现了接口，可以强制使用 CGLIB 实现 AOP**；
- **如果目标对象没有实现了接口，必须采用 CGLIB 库，Spring 会自动在 JDK 动态代理和 CGLIB 之间转换**。


如何强制使用 CGLIB 实现 AOP？
1. 添加 CGLIB 库：`Spring_HOME/cglib/*.jar`；
2. 在 Spring 配置文件中加入 `<aop:aspectj-autoproxyproxy-target-class="true"/>`。


JDK 动态代理和 CGLIB 字节码生成的区别？
- **JDK 动态代理只能对实现了接口的类生成代理，而不能针对类**；
- **CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以该类或方法最好不要声明成 final**。

### 2.3.1 JDK 动态代理

继续之前的源码跟踪，到达 JdkDynamicAopProxy 的 getProxy：

``` java
/**
 * JdkDynamicAopProxy.java
 * 创建代理类
 */
public Object getProxy(@Nullable ClassLoader classLoader) {
    if (logger.isTraceEnabled()) {
        logger.trace("Creating JDK dynamic proxy: " + this.advised.getTargetSource());
    }
    Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
}
```

查看源码可知 JdkDynamicAopProxy 实现了 InvocationHandler 接口，而 JDK 动态代理的真正实现正是由  InvocationHandler 的 invoke 方法实现的，Spring AOP 使用 JDK 动态代理的核心逻辑正是由 JdkDynamicAopProxy 的 invoke 方法实现的，源码如下：

``` java
/**
 * JdkDynamicAopProxy.java
 * InvocationHandler.invoke 代理方法的实现
 */
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    MethodInvocation invocation;
    Object oldProxy = null;
    boolean setProxyContext = false;

    TargetSource targetSource = this.advised.targetSource;
    Object target = null;

    try {
        if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {
            // equals 方法的处理
            // The target does not implement the equals(Object) method itself.
            return equals(args[0]);
        }
        else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {
            // hash 方法的处理
            // The target does not implement the hashCode() method itself.
            return hashCode();
        }
        else if (method.getDeclaringClass() == DecoratingProxy.class) {
            // There is only getDecoratedClass() declared -> dispatch to proxy config.
            return AopProxyUtils.ultimateTargetClass(this.advised);
        }
        else if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&
                 method.getDeclaringClass().isAssignableFrom(Advised.class)) {
            // Class 类的 isAssignableFrom(Class cls) 方法:
            // 如果调用这个方法的 class 或接口与参数 cls 表示的类或接口相同，　　
            // 或者是参数 cls 表示的类或接口的父类，则返回 true。　　
            // 形象地：<自身类>.class.isAssignableFrom(<自身类或子类>.class) 返回 true　　
            // 例：　　
            // System.out.println(ArrayList.class.isAssignableFrom(Object.class));　　　
            // false　　
            // System.out.println(Object.class.isAssignableFrom(ArrayList.class));　　　
            // true
            // Service invocations on ProxyConfig with the proxy config...
            return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
        }

        Object retVal;
		// 有时候目标对象内部的自我调用无法实施切面中的增强则需要通过此属性暴露代理
        if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        }

        // Get as late as possible to minimize the time we "own" the target,
        // in case it comes from a pool.
        target = targetSource.getTarget();
        Class<?> targetClass = (target != null ? target.getClass() : null);

        // Get the interception chain for this method.
        // 获取当前方法的拦截器链
        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

        // Check whether we have any advice. If we don't, we can fallback on direct
        // reflective invocation of the target, and avoid creating a MethodInvocation.
        if (chain.isEmpty()) {
            // We can skip creating a MethodInvocation: just invoke the target directly
            // Note that the final invoker must be an InvokerInterceptor so we know it does
            // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
            // 如果没有发现任何拦截器那么直接调用切点方法
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
        }
        else {
            // We need to create a method invocation...
            // 将拦截器封装在 ReflectiveMethodInvocation
            // 以便于使用其 proceed 进行链接表用拦截器
            invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
            // Proceed to the joinpoint through the interceptor chain.
            // 执行拦截器链
            retVal = invocation.proceed();
        }

        // Massage return value if necessary.
        Class<?> returnType = method.getReturnType();
        // 返回结果
        if (retVal != null && retVal == target &&
            returnType != Object.class && returnType.isInstance(proxy) &&
            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
            // Special case: it returned "this" and the return type of the method
            // is type-compatible. Note that we can't help if the target sets
            // a reference to itself in another returned object.
            retVal = proxy;
        }
        else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {
            throw new AopInvocationException(
                "Null return value from advice does not match primitive return type for: " + method);
        }
        return retVal;
    }
    finally {
        if (target != null && !targetSource.isStatic()) {
            // Must have come from TargetSource.
            targetSource.releaseTarget(target);
        }
        if (setProxyContext) {
            // Restore old proxy.
            AopContext.setCurrentProxy(oldProxy);
        }
    }
}
```

上面的函数中最主要的工作就是创建了一个拦截器链，并使用 ReflectiveMethodInvocation 类进行了链的封装，而在 ReflectiveMethodInvocation 类的 proceed 方法中实现了拦截器的逐一调用，那么我们继续来探究，在 proceed 方法中是怎么实现前置增强在目标方法前调用后置增强在目标方法后调用的逻辑：

``` java
/**
 * ReflectiveMethodInvocation.java
 * 执行拦截器链与目标方法
 */
public Object proceed() throws Throwable {
    //	We start with an index of -1 and increment early.
    // 执行完所有增强执行切点方法
    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
        return invokeJoinpoint();
    }

    // 获取下一个拦截器
    Object interceptorOrInterceptionAdvice =
        this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
        // Evaluate dynamic method matcher here: static part will already have
        // been evaluated and found to match.
        // 动态匹配
        InterceptorAndDynamicMethodMatcher dm =
            (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
        Class<?> targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());
        if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {
            return dm.interceptor.invoke(this);
        }
        else {
            // Dynamic matching failed.
            // Skip this interceptor and invoke the next in the chain.
            // 不匹配则不执行拦截器
            return proceed();
        }
    }
    else {
        // It's an interceptor, so we just invoke it: The pointcut will have
        // been evaluated statically before this object was constructed.
        /*
         * 普通拦截器，直接调用拦截器，比如：
         * ExposeInvocationInterceptor
         * DelegatePerTargetObjectIntroductionInterceptor
         * MethodBeforeAdviceInterceptor
         * AspectJAroundAdvice
         * AspectJAfterAdvice
         */
        // 将 this 作为参数传递以保证当前实例中调用链的执行
        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
    }
}
```

在 proceed 方法中，或许代码逻辑并没有我们想象得那么复杂，ReflectiveMethodInvocation 中的主要职责是维护了链接调用的计数器，记录着当前调用链接的位置，以便链可以有序地进行下去，那么在这个方法中并没有我们之前设想的维护各种增强的顺序，而是将此工作委托给了各个增强器，使各个增强器在内部进行逻辑实现。

### 2.3.2 CGLIB 动态代理

**CGLIB 是一个强大的高性能的代码生成包**。它广泛地被许多 AOP 的框架使用，例如 SpringAOP 和 dynaop，为他们提供方法的 Interception（拦截）。最流行的 ORMapping 工具 Hibernate 也使用 CGLIB 来代理单端 single-ended（多对一和一对一）关联（对集合的延迟抓取是采用其他机制实现的）。EasyMock 和 jMock 是通过使用模仿（moke）对象来测试 Java 代码的包。它们都通过使用 CGLIB 来为那些没有接口的类创建模仿（moke）对象。

CGLIB 包的底层通过使用一个小而快的字节码处理框架 ASM，来转换字节码并生成新的类。除了 CGLIB 包，脚本语言例如 Groovy 和 BeanShell，也是使用 ASM 来生成 Java 的字节码。当然不鼓励直接使用 ASM，因为它要求你必须对 JVM 内部结构包括 class 文件的格式和指令集都很熟悉。

继续之前的对 ObjenesisCglibAopProxy 源码跟踪，到达 CglibAopProxy 的 getProxy：

``` java
/**
 * CglibAopProxy.java
 * 创建代理类
 */
public Object getProxy(@Nullable ClassLoader classLoader) {
    if (logger.isTraceEnabled()) {
        logger.trace("Creating CGLIB proxy: " + this.advised.getTargetSource());
    }

    try {
        Class<?> rootClass = this.advised.getTargetClass();
        Assert.state(rootClass != null, "Target class must be available for creating a CGLIB proxy");

        Class<?> proxySuperClass = rootClass;
        if (ClassUtils.isCglibProxyClass(rootClass)) {
            proxySuperClass = rootClass.getSuperclass();
            Class<?>[] additionalInterfaces = rootClass.getInterfaces();
            for (Class<?> additionalInterface : additionalInterfaces) {
                this.advised.addInterface(additionalInterface);
            }
        }

        // Validate the class, writing log messages as necessary.
        // 验证 Class
        validateClassIfNecessary(proxySuperClass, classLoader);

        // Configure CGLIB Enhancer...
        // 创建及配置 Enhancer
        Enhancer enhancer = createEnhancer();
        if (classLoader != null) {
            enhancer.setClassLoader(classLoader);
            if (classLoader instanceof SmartClassLoader &&
                ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
                enhancer.setUseCache(false);
            }
        }
        enhancer.setSuperclass(proxySuperClass);
        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
        enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));

        // 设置拦截器
        Callback[] callbacks = getCallbacks(rootClass);
        Class<?>[] types = new Class<?>[callbacks.length];
        for (int x = 0; x < types.length; x++) {
            types[x] = callbacks[x].getClass();
        }
        // fixedInterceptorMap only populated at this point, after getCallbacks call above
        enhancer.setCallbackFilter(new ProxyCallbackFilter(
            this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
        enhancer.setCallbackTypes(types);

        // Generate the proxy class and create a proxy instance.
        return createProxyClassAndInstance(enhancer, callbacks);
    }
    catch (CodeGenerationException | IllegalArgumentException ex) {
        throw new AopConfigException("Could not generate CGLIB subclass of " + this.advised.getTargetClass() +
                                     ": Common causes of this problem include using a final class or a non-visible class",
                                     ex);
    }
    catch (Throwable ex) {
        // TargetSource.getTarget() failed
        throw new AopConfigException("Unexpected AOP exception", ex);
    }
}

/**
 * CglibAopProxy.java
 * 生成代理类以及创建代理
 */
protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {
    enhancer.setInterceptDuringConstruction(false);
    enhancer.setCallbacks(callbacks);
    return (this.constructorArgs != null && this.constructorArgTypes != null ?
            enhancer.create(this.constructorArgTypes, this.constructorArgs) :
            enhancer.create());
}
```

以上函数完整地阐述了一个创建 Spring 中的 Enhancer 的过程，读者可以参考 Enhancer 的文档查看每个步骤的含义，这里最重要的是通过 getCallbacks 方法设置拦截器链，源码如下：

``` java
/**
 * CglibAopProxy.java
 * 封装拦截器链
 */
private Callback[] getCallbacks(Class<?> rootClass) throws Exception {
    // Parameters used for optimization choices...
    // 对 expose-proxy 属性的处理
    boolean exposeProxy = this.advised.isExposeProxy();
    boolean isFrozen = this.advised.isFrozen();
    boolean isStatic = this.advised.getTargetSource().isStatic();

    // Choose an "aop" interceptor (used for AOP calls).
    // 将拦截器封装在 DynamicAdvisedInterceptor 中
    Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised);

    // Choose a "straight to target" interceptor. (used for calls that are
    // unadvised but can return this). May be required to expose the proxy.
    Callback targetInterceptor;
    if (exposeProxy) {
        targetInterceptor = (isStatic ?
                             new StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) :
                             new DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource()));
    }
    else {
        targetInterceptor = (isStatic ?
                             new StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) :
                             new DynamicUnadvisedInterceptor(this.advised.getTargetSource()));
    }

    // Choose a "direct to target" dispatcher (used for
    // unadvised calls to static targets that cannot return this).
    Callback targetDispatcher = (isStatic ?
                                 new StaticDispatcher(this.advised.getTargetSource().getTarget()) : new SerializableNoOp());

    Callback[] mainCallbacks = new Callback[] {
        // 将拦截器加入到 Callback 中
        aopInterceptor,  // for normal advice
        targetInterceptor,  // invoke target without considering advice, if optimized
        new SerializableNoOp(),  // no override for methods mapped to this
        targetDispatcher, this.advisedDispatcher,
        new EqualsInterceptor(this.advised),
        new HashCodeInterceptor(this.advised)
    };

    Callback[] callbacks;

    // If the target is a static one and the advice chain is frozen,
    // then we can make some optimizations by sending the AOP calls
    // direct to the target using the fixed chain for that method.
    if (isStatic && isFrozen) {
        Method[] methods = rootClass.getMethods();
        Callback[] fixedCallbacks = new Callback[methods.length];
        this.fixedInterceptorMap = new HashMap<>(methods.length);

        // TODO: small memory optimization here (can skip creation for methods with no advice)
        for (int x = 0; x < methods.length; x++) {
            List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);
            fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(
                chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());
            this.fixedInterceptorMap.put(methods[x].toString(), x);
        }

        // Now copy both the callbacks from mainCallbacks
        // and fixedCallbacks into the callbacks array.
        callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];
        System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);
        System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);
        this.fixedInterceptorOffset = mainCallbacks.length;
    }
    else {
        callbacks = mainCallbacks;
    }
    return callbacks;
}
```

在 getCallback 中 Spring 考虑了很多情况，但是对于我们来说，只需要理解最常用的就可以了，比如将 advised 属性封装在 DynamicAdvisedInterceptor 并加入在 callbacks 中。DynamicAdvisedInterceptor 继承自 MethodInterceptor，加入 Callback 中后，在再次调用代理时会直接调用 DynamicAdvisedInterceptor 中的 intercept 方法，由此推断，对于 CGLIB 方式实现的代理，其核心逻辑必然在 DynamicAdvisedInterceptor 中的 intercept 中，源码如下：

``` java
/**
 * CglibAopProxy.java
 * CGLIB 代理实现的核心逻辑，代理方法的调用
 */
public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
    Object oldProxy = null;
    boolean setProxyContext = false;
    Object target = null;
    TargetSource targetSource = this.advised.getTargetSource();
    try {
        if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
        }
        // Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...
        target = targetSource.getTarget();
        Class<?> targetClass = (target != null ? target.getClass() : null);
        // 获取拦截器链
        List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
        Object retVal;
        // Check whether we only have one InvokerInterceptor: that is,
        // no real advice, but just reflective invocation of the target.
        if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {
            // We can skip creating a MethodInvocation: just invoke the target directly.
            // Note that the final invoker must be an InvokerInterceptor, so we know
            // it does nothing but a reflective operation on the target, and no hot
            // swapping or fancy proxying.
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            // 如果拦截器链为空则直接激活原方法
            retVal = methodProxy.invoke(target, argsToUse);
        }
        else {
            // We need to create a method invocation...
            // 进入链
            retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
        }
        retVal = processReturnType(proxy, target, method, retVal);
        return retVal;
    }
    finally {
        if (target != null && !targetSource.isStatic()) {
            targetSource.releaseTarget(target);
        }
        if (setProxyContext) {
            // Restore old proxy.
            AopContext.setCurrentProxy(oldProxy);
        }
    }
}
```

上述的实现与 JDK 方式实现代理中的 invoke 方法大同小异，都是首先构造链，然后封装此链进行串联调用，稍有些区别就是在 JDK 中直接构造 ReflectiveMethodInvocation，而在 cglib 中使用 CglibMethodInvocation。CglibMethodInvocation 继承自 ReflectiveMethodInvocation，但是 proceed 方法并没有重写。

# 3.创建 AOP 静态代理

## 3.1 自定义标签

在 Spring 中如果需要使用 AspectJ 的功能，首先要做的第一步就是在配置文件中加入配置：`<context:load-time-weaver/>`。我们根据之前介绍的自定义命名空间的知识便可以推断，引用 AspectJ 的入口便是这里，可以通过查找 load-time-weaver 来找到对应的自定义命名处理类。于是我们找到了 ContextNamespaceHandler，在其中有这样一个方法：

``` java
/**
 * ContextNamespaceHandler.java
 */
public void init() {
    registerBeanDefinitionParser("property-placeholder", new PropertyPlaceholderBeanDefinitionParser());
    registerBeanDefinitionParser("property-override", new PropertyOverrideBeanDefinitionParser());
    registerBeanDefinitionParser("annotation-config", new AnnotationConfigBeanDefinitionParser());
    registerBeanDefinitionParser("component-scan", new ComponentScanBeanDefinitionParser());
    // 标签 load-time-weaver 的自定义命名处理类
    registerBeanDefinitionParser("load-time-weaver", new LoadTimeWeaverBeanDefinitionParser());
    registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
    registerBeanDefinitionParser("mbean-export", new MBeanExportBeanDefinitionParser());
    registerBeanDefinitionParser("mbean-server", new MBeanServerBeanDefinitionParser());
}
```

继续跟进 LoadTimeWeaverBeanDefinitionParser，作为 BeanDefinitionParser 接口的实现类，他的核心逻辑是从 parse 函数开始的，而经过父类的封装，LoadTimeWeaverBeanDefinitionParser 类的核心实现被转移到了 doParse 函数中，如下：

``` java
/**
 * LoadTimeWeaverBeanDefinitionParser.java
 * 自定义标签解析方法
 */
protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {
    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);

    if (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) {
        if (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) {
            RootBeanDefinition def = new RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);
            parserContext.registerBeanComponent(
                new BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));
        }

        if (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) {
            new SpringConfiguredBeanDefinitionParser().parse(element, parserContext);
        }
    }
}
```

上面函数的核心作用其实就是注册一个对于 ApectJ 处理的类 org.Springframework.context.weaving.AspectJWeavingEnabler，它的注册流程总结起来如下：

1.是否开启 AspectJ。

之前虽然反复提到了在配置文件中加入了 `<context:load-time-weaver/>` 便相当于加入了 AspectJ 开关。但是，并不是配置了这个标签就意味着开启了 AspectJ 功能，这个标签中还有一个属性 aspectj-weaving，这个属性有 3 个备选值，on、off 和 autodetect，默认为 autodetect，也就是说，如果我们只是使用了 `<context:load-time-weaver/>`，那么 Spring 会帮助我们检测是否可以使用 AspectJ 功能，而检测的依据便是文件 `META-INF/aop.xml` 是否存在，看看在 Spring 中的实现方式：

``` java
/**
 * LoadTimeWeaverBeanDefinitionParser.java
 * 是否开启 AspectJ
 */
protected boolean isAspectJWeavingEnabled(String value, ParserContext parserContext) {
    if ("on".equals(value)) {
        return true;
    }
    else if ("off".equals(value)) {
        return false;
    }
    else {
        // Determine default...
        　// 自动检测
        ClassLoader cl = parserContext.getReaderContext().getBeanClassLoader();
        return (cl != null && cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != null);
    }
}
```

2.将 org.Springframework.context.weaving.AspectJWeavingEnabler 封装在 BeanDefinition 中注册。

当通过 AspectJ 功能验证后便可以进行 AspectJWeavingEnabler 的注册了，注册的方式很简单，无非是将类路径注册在新初始化的 RootBeanDefinition 中，在 RootBeanDefinition 的获取时会转换成对应的 class。尽管在 init 方法中注册了 AspectJWeavingEnabler，但是对于标签本身 Spring 也会以 bean 的形式保存，也就是当 Spring 解析到 `<context:load-time-weaver/>` 标签的时候也会产生一个 bean。

在 LoadTimeWeaverBeanDefinitionParser 类中有这样的函数：

``` java
/**
 * LoadTimeWeaverBeanDefinitionParser.java
 * 确定与提供的 Element 对应的 bean 类名
 */
@Override
protected String getBeanClassName(Element element) {
    if (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) {
        return element.getAttribute(WEAVER_CLASS_ATTRIBUTE);
    }
    return DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;
}

/**
 * LoadTimeWeaverBeanDefinitionParser.java
 * 解析提供的 BeanDefinition 的 ID
 */
@Override
protected String resolveId(Element element, AbstractBeanDefinition definition, ParserContext parserContext) {
    return ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;
}
```

> WEAVER_CLASS_ATTRIBUTE = "weaver-class"
>
> DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME = "org.Springframework.context.weaving.DefaultContextLoadTimeWeaver"
>
> ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME = "loadTimeWeaver"

单凭以上的信息我们至少可以推断，当 Spring 在读取到自定义标签 `<context:load-time-weaver/>` 后会产生一个 bean，而这个 bean 的 id 为 loadTimeWeaver，class 为 org.Springframework.context.weaving.DefaultContextLoadTimeWeaver，也就是完成了 DefaultContextLoadTimeWeaver 类的注册。

完成了以上的注册功能后，并不意味这在 Spring 中就可以使用 AspectJ 了，因为我们还有一个很重要的步骤忽略了，就是 LoadTimeWeaverAwareProcessor 的注册。在 AbstractApplicationContext 中的 prepareBeanFactory 函数中有这样一段代码：

``` java
// 添加了对 AspectJ 的支持
// Detect a LoadTimeWeaver and prepare for weaving, if found.
if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
    beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
    // Set a temporary ClassLoader for type matching.
    beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
}
```

在 AbstractApplicationContext 中的 prepareBeanFactory 函数是在容器初始化时候调用的，也就是说只有注册了 LoadTimeWeaverAwareProcessor 才会激活整个 AspectJ 的功能。

## 3.2 织入

当我们完成了所有的 AspectJ 的准备工作后便可以进行织入分析了，首先还是从 LoadTimeWeaverAwareProcessor 开始。

LoadTimeWeaverAwareProcessor 实现 BeanPostProcessor 方法，那么对于 BeanPostProcessor 接口来讲，postProcessBeforeInitialization 与 postProcessAfterInitialization 有着其特殊意义，也就是说在所有 bean 的初始化之前与之后都会分别调用对应的方法，那么在 LoadTimeWeaverAwareProcessor 中的 postProcessBeforeInitialization 函数中完成了什么样的逻辑呢？

``` java
/**
 * LoadTimeWeaverAwareProcessor.java
 * 将此 BeanPostProcessor 应用到给定的新 bean 实例中
 */
public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    if (bean instanceof LoadTimeWeaverAware) {
        LoadTimeWeaver ltw = this.loadTimeWeaver;
        if (ltw == null) {
            Assert.state(this.beanFactory != null,
                         "BeanFactory required if no LoadTimeWeaver explicitly specified");
            ltw = this.beanFactory.getBean(
                ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);
        }
        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);
    }
    return bean;
}
```

在 LoadTimeWeaverAwareProcessor 中的 postProcessBeforeInitialization 函数中，因为最开始的 if 判断注定这个后处理器只对 LoadTimeWeaverAware 类型的 bean 起作用，而纵观所有的 bean，实现 LoadTimeWeaver 接口的类只有 AspectJWeavingEnabler。

当在 Spring 中调用 AspectJWeavingEnabler 时，this.loadTimeWeaver 尚未被初始化，那么，会直接调用 beanFactory.getBean 方法获取对应的 DefaultContextLoadTimeWeaver 类型的 bean，并将其设置为 AspectJWeavingEnabler 类型 bean 的 loadTimeWeaver 属性中。当然 AspectJWeavingEnabler 同样实现了 BeanClassLoaderAware 以及Ordered 接口，实现 BeanClassLoaderAware 接口保证了在 bean 初始化的时候调用 AbstractAutowireCapableBeanFactory 的 invokeAwareMethods 的时候将 beanClassLoader 赋值给当前类。而实现 Ordered 接口则保证在实例化 bean 时当前 bean 会被最先初始化。

而 DefaultContextLoadTimeWeaver 类又同时实现了 LoadTimeWeaver、BeanClassLoaderAware 以及 DisposableBean。其中 DisposableBean 接口保证在 bean 销毁时会调用 destroy 方法进行 bean 的清理，而 BeanClassLoaderAware 接口则保证在 bean 的初始化调用 AbstractAutowireCapableBeanFactory 的 invokeAwareMethods 时调用 setBeanClassLoader 方法。

``` java
/**
 * LoadTimeWeaverAwareProcessor.java
 * 将 bean 类加载器提供给 bean 实例的回调
 */
public void setBeanClassLoader(ClassLoader classLoader) {
    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);
    if (serverSpecificLoadTimeWeaver != null) {
        if (logger.isDebugEnabled()) {
            logger.debug("Determined server-specific load-time weaver: " +
                         serverSpecificLoadTimeWeaver.getClass().getName());
        }
        this.loadTimeWeaver = serverSpecificLoadTimeWeaver;
    }
    else if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {
        logger.debug("Found Spring's JVM agent for instrumentation");
        // 检查当前虚拟机中的 Instrumentation 实例是否可用
        this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);
    }
    else {
        try {
            this.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader);
            if (logger.isDebugEnabled()) {
                logger.debug("Using reflective load-time weaver for class loader: " +
                             this.loadTimeWeaver.getInstrumentableClassLoader().getClass().getName());
            }
        }
        catch (IllegalStateException ex) {
            throw new IllegalStateException(ex.getMessage() + " Specify a custom LoadTimeWeaver or start your " +
                                            "Java virtual machine with Spring's agent: -javaagent:org.springframework.instrument.jar");
        }
    }
}
```

上面的函数中有一句很容易被忽略但是很关键的代码：

``` java
this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader);
```

这句代码不仅仅是实例化了一个 InstrumentationLoadTimeWeaver 类型的实例，而且在实例化过程中还做了一些额外的操作。

在实例化的过程中会对当前的 this.instrumentation 属性进行初始化，而初始化的代码如下： `this.instrumentation=getInstrumentation()`，也就是说在 InstrumentationLoadTimeWeaver 实例化后其属性 Instrumentation 已经被初始化为代表着当前虚拟机的实例了。

经过以上程序的处理后，在 Spring 中的 bean 之间的关系如下：

- AspectJWeavingEnabler 类型的 bean 中的 loadTimeWeaver 属性被初始化为 DefaultContextLoadTimeWeaver 类型的 bean；
- DefaultContextLoadTimeWeaver 类型的 bean 中的 loadTimeWeaver 属性被初始化为 InstrumentationLoadTimeWeaver。

因为 AspectJWeavingEnabler 类同样实现了 BeanFactoryPostProcessor，所以当所有 bean 解析结束后会调用其 postProcessBeanFactory 方法。

``` java
/**
 * AspectJWeavingEnabler.java
 * 在标准初始化之后修改应用程序上下文的内部 bean 工厂
 * 所有 bean 定义都将被加载，但尚未实例化任何 bean
 * 这甚至允许覆盖或添加属性，甚至是急切初始化的 bean
 */
public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
    enableAspectJWeaving(this.loadTimeWeaver, this.beanClassLoader);
}


/**
 * AspectJWeavingEnabler.java
 * 使用给定的 LoadTimeWeaver 启用 AspectJ 编织
 */
public static void enableAspectJWeaving(
    @Nullable LoadTimeWeaver weaverToUse, @Nullable ClassLoader beanClassLoader) {

    if (weaverToUse == null) {
        // 此时已经被初始化为 DefaultContextLoadTimeWeaver
        if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) {
            weaverToUse = new InstrumentationLoadTimeWeaver(beanClassLoader);
        }
        else {
            throw new IllegalStateException("No LoadTimeWeaver available");
        }
    }
    
    // 使用 DefaultContextLoadTimeWeaver 类型的 bean 中的 loadTimeWeaver 属性注册转换器
    weaverToUse.addTransformer(
        new AspectJClassBypassingClassFileTransformer(new ClassPreProcessorAgentAdapter()));
}

/**
 * AspectJWeavingEnabler.java 的内部类
 */
private static class AspectJClassBypassingClassFileTransformer implements ClassFileTransformer {

    private final ClassFileTransformer delegate;

    public AspectJClassBypassingClassFileTransformer(ClassFileTransformer delegate) {
        this.delegate = delegate;
    }

    @Override
    public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
                            ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException {

        if (className.startsWith("org.aspectj") || className.startsWith("org/aspectj")) {
            return classfileBuffer;
        }
        // 委托给 AspectJ 代理继续处理
        return this.delegate.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);
    }
}
```

AspectJClassBypassingClassFileTransformer 的作用仅仅是告诉 AspectJ以org.aspectj 开头的或者 org/aspectj 开头的类不进行处理。
