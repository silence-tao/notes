# 2021年9月力扣每日1题

## 20210901 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 165. 比较版本号

原题链接：[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)

> 给你两个版本号 version1 和 version2 ，请你比较它们。
>
> 版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
>
> 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。
>
> 返回规则如下：
>
> 如果 version1 > version2 返回 1，
> 如果 version1 < version2 返回 -1，
> 除此之外返回 0。
>
> 提示：
>
> 1 <= version1.length, version2.length <= 500
> version1 和 version2 仅包含数字和 '.'
> version1 和 version2 都是 有效版本号
> version1 和 version2 的所有修订号都可以存储在 32 位整数 中

### 1.直接法

``` java
class Solution {
    public int compareVersion(String version1, String version2) {
        // 先将两个版本号分割成字符串数组
        String[] arr1 = version1.split("\\.");
        String[] arr2 = version2.split("\\.");

        int len1 = arr1.length, len2 = arr2.length;
        // 然后按位比较每一位的大小
        for (int i = 0; i < Math.max(len1, len2); i++) {
            // 将每一位修订号转成整型
            // 如果超出数组范围则转成0
            int ver1 = i < len1 ? Integer.parseInt(arr1[i]) : 0;
            int ver2 = i < len2 ? Integer.parseInt(arr2[i]) : 0;

            // 比较两个修订号是否相等
            if (ver1 != ver2) {
                // 不相等ver1 > ver2返回1
                // 否则返回-1
                return ver1 > ver2 ? 1 : -1;
            }
        }

        // 到了这里说明所有的修订号都相等
        // 即两个版本号相等，返回0
        return 0;
    }
}
```

## 20210902 <font color=#009975>E</font> <font color=#009975>S</font>

### 剑指 Offer 22. 链表中倒数第k个节点

原题链接：[剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
>
> 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

### 1.双指针

``` java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        int idx = 1;
        ListNode first = head;
        // 想让第一个指针跳到第k个节点
        while (idx++ < k) {
            first = first.next;
        }

        // 然后再让第一个指针从头开始
        ListNode second = head;
        // 两个指针同时前进
        // 当第一个指针到达最后一个节点时
        // 第二个指针刚好到倒数第k个节点的位置
        while (first.next != null) {
            first = first.next;
            second = second.next;
        }

        return second;
    }
}
```

## 20210903 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 面试题 17.14. 最小K个数

原题链接：[面试题 17.14. 最小K个数](https://leetcode-cn.com/problems/smallest-k-lcci/)

> 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
>
> **提示：**
>
> - `0 <= len(arr) <= 100000`
> - `0 <= k <= min(100000, len(arr))`

### 1.排序

``` java
class Solution {
    public int[] smallestK(int[] arr, int k) {
        Arrays.sort(arr);

        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = arr[i];
        }

        return res;
    }
}
```

## 20210904 <font color=#009975>E</font> <font color=#009975>S</font>

### 剑指 Offer 10- I. 斐波那契数列

原题链接：[剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> **提示：**
>
> - `0 <= n <= 100`

### 1.动态规划

``` java
class Solution {
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }

        int INF = 1000000007;

        // 斐波那契数列其实只需要前两个数的状态
        // 所以这里用first表示F(N - 2)
        // second表示F(N - 1)
        int first = 0, second = 1;
        for (int i = 2; i <= n; i++) {
            // t表示F(N)
            int t = (first + second) % INF;

            // 为下一轮更新F(N - 2)
            // 即现在的F(N - 1)
            first = second;
            // 为下一轮更新F(N - 1)
            // 即现在的F(N)
            second = t;
        }

        // 所以当循环结束时
        // second
        return second;
    }
}
```

## 20210905 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 470. 用 Rand7() 实现 Rand10()

原题链接：[470. 用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

> 已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。
>
> 不要使用系统的 Math.random() 方法。
>
> **提示:**
>
> 1. `rand7` 已定义。
> 2. 传入参数: `n` 表示 `rand10` 的调用次数。

### 1.拒绝采样

[参考题解](https://leetcode-cn.com/problems/implement-rand10-using-rand7/solution/yong-rand7-shi-xian-rand10-by-leetcode-s-qbmd/)

``` java
/**
 * The rand7() API is already defined in the parent class SolBase.
 * public int rand7();
 * @return a random integer in the range 1 to 7
 */
class Solution extends SolBase {
    public int rand10() {
        int a, b, num;
        do {
            a = rand7();
            b = rand7();

            num = a + (b - 1) * 7;
        } while (num > 40);

        return 1 + (num - 1) % 10;
    }
}
```

## 20210906 <font color=#009975>E</font> <font color=#009975>S</font>

### 704. 二分查找

原题链接：[704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
>
> **提示：**
>
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

### 1.二分法

``` java
class Solution {
    public int search(int[] nums, int target) {
        int length = nums.length;

        // 在区间[left, right]内搜索target
        int left = 0, right = length - 1;
        while (left < right) {
        	// 将整个区间分为[left, mid]和[mid + 1, right]
            // 其中区间[left, mid]小于target
            // 区间[mid + 1, right]大于等于target
            int mid = (left + right) >> 1;
            if (nums[mid] < target) {
                // 当nums[mid] < target时
                // 缩小左边的区间
                left = mid + 1;
            } else {
                // 否则缩小右边的区间
                right = mid;
            }
        }
        
        // 判断nums[left]是否等于target
        // 等于target返回left，否则返回-1
        return nums[left] == target ? left : -1;
    }
}
```

## 20210907 <font color=#009975>E</font> <font color=#009975>S</font>

### 1221. 分割平衡字符串

原题链接：[1221. 分割平衡字符串](https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/)

> 在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。
>
> 给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。
>
> 注意：分割得到的每个字符串都必须是平衡字符串。
>
> 返回可以通过分割得到的平衡字符串的 最大数量 。
>
> **提示：**
>
> - `1 <= s.length <= 1000`
> - `s[i] = 'L' 或 'R'`
> - `s` 是一个 **平衡** 字符串

### 1.直接法

``` java
class Solution {
    public int balancedStringSplit(String s) {
        int length = s.length();

        // n表示当前L/R出现的次数
        // n作为L/R其中之一的出现次数，可以与另一个字符出现的次数相抵消
        // 所以当n为0时，就分割到一个平衡字符串
        int n = 0, res = 0;
        // first表示当前第一个出现的字符是L/R
        char first = 'L';
        // 遍历字符串
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            // 初始时n == 0，此时要确定此轮第一个出现的字符是L/R
            if (n == 0) {
                // 确定第一个出现的字符放入到first中
                first = c;
                // 当前字符L/R出现次数n加1
                n++;

                continue ;
            }

            // 如果当前字符等于第一个出现的字符first
            if (first == c) {
                // 那么次数n加1
                n++;
            } else {
                // 否则就抵消一次，次数n减1
                n--;
            }

            // 当n为0时，就分割到一个平衡字符串
            if (n == 0) {
                // 平衡字符串数量
                res++;
            }
        }

        return res;
    }
}
```

## 20210908 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 502. IPO

原题链接：[502. IPO](https://leetcode-cn.com/problems/ipo/)

> 假设 力扣（LeetCode）即将开始 IPO 。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。
>
> 给你 n 个项目。对于每个项目 i ，它都有一个纯利润 profits[i] ，和启动该项目需要的最小资本 capital[i] 。
>
> 最初，你的资本为 w 。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。
>
> 总而言之，从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。
>
> 答案保证在 32 位有符号整数范围内。
>
> 提示：
>
> 1 <= k <= 105
> 0 <= w <= 109
> n == profits.length
> n == capital.length
> 1 <= n <= 105
> 0 <= profits[i] <= 104
> 0 <= capital[i] <= 109

### 1.利用堆的贪心算法

[参考链接](https://leetcode-cn.com/problems/ipo/solution/ipo-by-leetcode-solution-89zm/)

``` java
class Solution {
    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
        int n = profits.length;
        int curr = 0;
        int[][] arr = new int[n][2];

        for (int i = 0; i < n; ++i) {
            arr[i][0] = capital[i];
            arr[i][1] = profits[i];
        }
        Arrays.sort(arr, (a, b) -> a[0] - b[0]);

        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> y - x);
        for (int i = 0; i < k; ++i) {
            while (curr < n && arr[curr][0] <= w) {
                pq.add(arr[curr][1]);
                curr++;
            }
            if (!pq.isEmpty()) {
                w += pq.poll();
            } else {
                break;
            }
        }

        return w;
    }
}
```

## 20210909 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 68. 文本左右对齐

原题链接：[68. 文本左右对齐](https://leetcode-cn.com/problems/text-justification/)

> 给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。
>
> 你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。
>
> 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。
>
> 文本的最后一行应为左对齐，且单词之间不插入额外的空格。
>
> 说明:
>
> 单词是指由非空格字符组成的字符序列。
> 每个单词的长度大于 0，小于等于 maxWidth。
> 输入单词数组 words 至少包含一个单词。

### 1.模拟

``` java
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> ans = new ArrayList<String>();
        int right = 0, n = words.length;
        while (true) {
            int left = right; // 当前行的第一个单词在 words 的位置
            int sumLen = 0; // 统计这一行单词长度之和
            // 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格
            while (right < n && sumLen + words[right].length() + right - left <= maxWidth) {
                sumLen += words[right++].length();
            }

            // 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格
            if (right == n) {
                StringBuffer sb = join(words, left, n, " ");
                sb.append(blank(maxWidth - sb.length()));
                ans.add(sb.toString());
                return ans;
            }

            int numWords = right - left;
            int numSpaces = maxWidth - sumLen;

            // 当前行只有一个单词：该单词左对齐，在行末填充剩余空格
            if (numWords == 1) {
                StringBuffer sb = new StringBuffer(words[left]);
                sb.append(blank(numSpaces));
                ans.add(sb.toString());
                continue;
            }

            // 当前行不只一个单词
            int avgSpaces = numSpaces / (numWords - 1);
            int extraSpaces = numSpaces % (numWords - 1);
            StringBuffer sb = new StringBuffer();
            sb.append(join(words, left, left + extraSpaces + 1, blank(avgSpaces + 1))); // 拼接额外加一个空格的单词
            sb.append(blank(avgSpaces));
            sb.append(join(words, left + extraSpaces + 1, right, blank(avgSpaces))); // 拼接其余单词
            ans.add(sb.toString());
        }
    }

    // blank 返回长度为 n 的由空格组成的字符串
    public String blank(int n) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < n; ++i) {
            sb.append(' ');
        }
        return sb.toString();
    }

    // join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串
    public StringBuffer join(String[] words, int left, int right, String sep) {
        StringBuffer sb = new StringBuffer(words[left]);
        for (int i = left + 1; i < right; ++i) {
            sb.append(sep);
            sb.append(words[i]);
        }
        return sb;
    }
}
```

## 20210910 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 1894. 找到需要补充粉笔的学生编号

原题链接：[1894. 找到需要补充粉笔的学生编号](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/)

> 一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。
>
> 给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。
>
> 请你返回需要 补充 粉笔的学生 编号 。
>
> **提示：**
>
> - `chalk.length == n`
> - `1 <= n <= 105`
> - `1 <= chalk[i] <= 105`
> - `1 <= k <= 109`

### 1.直接法

``` java
class Solution {
    public int chalkReplacer(int[] chalk, int k) {
        int length = chalk.length;

        // 先将所以学生需要的粉笔数累加起来
        // 注意累加结果可能会超出int范围
        // 所以这里sum用long型
        long sum = 0;
        for (int i = 0; i < length; i++) {
            sum += chalk[i];
        }

        // 然后对k取余
        // 因为是循环回答问题
        // 所以可以用取余的方式过滤掉多余的轮次
        k %= sum;

        // 剩下的k肯定小于sum
        int res = 0;
        // 从头遍历数组chalk，表示从第一个学生开始回答问题
        for (int i = 0; i < length; i++) {
            // 如果当前k小于chalk[i]
            if (k < chalk[i]) {
                // 表示当前学生i需要补充粉笔
                res = i;

                break ;
            }

            // 否则减去当前学生需要的粉笔数
            k -= chalk[i];
        }

        /
        return res;
    }
}
```

## 20210911 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 600. 不含连续1的非负整数

原题链接：[600. 不含连续1的非负整数](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/)

> 给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 **连续的1** 的个数。
>
> **说明:** 1 <= n <= 109

### 1.动态规划

[参考链接](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/bu-han-lian-xu-1de-fei-fu-zheng-shu-by-l-9l86/)

``` java
class Solution {
    public int findIntegers(int n) {
        int[] dp = new int[31];
        dp[0] = dp[1] = 1;
        for (int i = 2; i < 31; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        int pre = 0, res = 0;
        for (int i = 29; i >= 0; --i) {
            int val = 1 << i;
            if ((n & val) != 0) {
                n -= val;
                res += dp[i + 1];
                if (pre == 1) {
                    break;
                }
                pre = 1;
            } else {
                pre = 0;
            }

            if (i == 0) {
                ++res;
            }
        }

        return res;
    }
}
```

## 20210912 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 678. 有效的括号字符串

原题链接：[678. 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/)

> 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
>
> 任何左括号 ( 必须有相应的右括号 )。
> 任何右括号 ) 必须有相应的左括号 ( 。
> 左括号 ( 必须在对应的右括号之前 )。
> * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
> 一个空字符串也被视为有效字符串。
>
> **注意:**
>
> 1. 字符串大小将在 [1，100] 范围内。

### 1.贪心

[参考题解](https://leetcode-cn.com/problems/valid-parenthesis-string/solution/you-xiao-de-gua-hao-zi-fu-chuan-by-leetc-osi3/)

``` java
class Solution {
    public boolean checkValidString(String s) {
        int length = s.length();

        // min表示未匹配到的括号数的最小值
        // max表示未匹配到的括号数的最大值
        int min = 0, max = 0;
        for (int i = 0; i < length; i++) {
            char c = s.charAt(i);
            if (c == '(') {
                // 当前字符为'('时，最小值和最大值都加1
                min++;
                max++;
            } else if (c == ')') {
                // 当前字符为')'时，最小值和最大值都减1

                // 其中min从min - 1和0中取最大值
                // 是因为如果有'*'存在的话
                // 没有被匹配上的'('还可以与'*'匹配
                min = Math.max(min - 1, 0);
                max--;
                // max < 0表示没有能与')'匹配的字符了
                if (max < 0) {
                    // 所以这里返回false
                    return false;
                }
            } else {
                // 当前字符为'*'时
                // min从min - 1和0中取最大值
                // 表示匹配到了一个'('
                min = Math.max(min - 1, 0);
                // max加又为后面的')'增加了一次匹配
                max++;
            }
        }

        // 当min == 0时表示所有左右括号都满足匹配了
        return min == 0;
    }
}
```

## 20210913 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 447. 回旋镖的数量

原题链接：[447. 回旋镖的数量](https://leetcode-cn.com/problems/number-of-boomerangs/)

> 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。
>
> 返回平面上所有回旋镖的数量。
>
> 提示：
>
> n == points.length
> 1 <= n <= 500
> points[i].length == 2
> -104 <= xi, yi <= 104
> 所有点都 互不相同

### 1.枚举 + 哈希

[参考链接](https://leetcode-cn.com/problems/number-of-boomerangs/solution/hui-xuan-biao-de-shu-liang-by-leetcode-s-lft5/)

``` java
class Solution {
    public int numberOfBoomerangs(int[][] points) {
        int ans = 0;
        for (int[] p : points) {
            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();
            for (int[] q : points) {
                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);
                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);
            }
            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {
                int m = entry.getValue();
                ans += m * (m - 1);
            }
        }
        return ans;
    }
}
```

## 20210914 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 524. 通过删除字母匹配到字典里最长单词

原题链接：[524. 通过删除字母匹配到字典里最长单词](https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/)

> 给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。
>
> 如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。
>
> 提示：
>
> 1 <= s.length <= 1000
> 1 <= dictionary.length <= 1000
> 1 <= dictionary[i].length <= 1000
> s 和 dictionary[i] 仅由小写英文字母组成

### 1.双指针

``` java
class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        String res = "";
        // 挨个遍历字符串数组 dictionary
        for (String str : dictionary) {
            int i = 0, j = 0;
            // 然后和字符串数组s的每个字符比较
            // 看看字符串str里面的所有字符是不是在s中都有
            // 利用双指针能保证字符出现的顺序一致的
            while (i < str.length() && j < s.length()) {
                if (str.charAt(i) == s.charAt(j)) {
                    i++;
                }

                j++;
            }

            // i == str.length()表示字符串str里面的所有字符在s中都有
            if (i == str.length()) {
                // 然后和res比较长度
                // res的长度小于str或者相等且字典序小
                // 则更新结果
                if (res.length() < str.length() || (res.length() == str.length() && str.compareTo(res) < 0)) {
                    res = str;
                }
            }
        }

        return res;
    }
}
```

## 20210915 <font color=#ed7336>M</font> <font color=#009975>S</font>

### 162. 寻找峰值

原题链接：[162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

> 峰值元素是指其值严格大于左右相邻值的元素。
>
> 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
>
> 你可以假设 nums[-1] = nums[n] = -∞ 。
>
> 你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
>
> 提示：
>
> 1 <= nums.length <= 1000
> -231 <= nums[i] <= 231 - 1
> 对于所有有效的 i 都有 nums[i] != nums[i + 1]

### 1.直接法

``` java
class Solution {
    public int findPeakElement(int[] nums) {
        int len = nums.length;
        
        int res = 0;
        // 其实就是要找一个大于左右相邻值的元素
        // 遍历数组每个元素和左右相邻元素比较一下即可
        for (int i = 0; i < len; i++) {
            // 处理第一个元素和最后
            int left = i == 0 ? Integer.MIN_VALUE : nums[i - 1];
            int right = i == len - 1 ? Integer.MIN_VALUE : nums[i + 1];

            if (left < nums[i] && nums[i] > right) {
                res = i;

                break ;
            }
        }

        return res;
    }
}
```

## 20210916 <font color=#ec4c47>H</font> <font color=#ec4c47>U</font>

### 212. 单词搜索 II

原题链接：[212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

> 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。
>
> 单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。
>
> 提示：
>
> m == board.length
> n == board[i].length
> 1 <= m, n <= 12
> board[i][j] 是一个小写英文字母
> 1 <= words.length <= 3 * 104
> 1 <= words[i].length <= 10
> words[i] 由小写英文字母组成
> words 中的所有字符串互不相同

### 1.回溯 + 字典树

[原题链接](https://leetcode-cn.com/problems/word-search-ii/solution/dan-ci-sou-suo-ii-by-leetcode-solution-7494/)

``` java
class Solution {
    int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    public List<String> findWords(char[][] board, String[] words) {
        Trie trie = new Trie();
        for (String word : words) {
            trie.insert(word);
        }

        Set<String> ans = new HashSet<String>();
        for (int i = 0; i < board.length; ++i) {
            for (int j = 0; j < board[0].length; ++j) {
                dfs(board, trie, i, j, ans);
            }
        }

        return new ArrayList<String>(ans);
    }

    public void dfs(char[][] board, Trie now, int i1, int j1, Set<String> ans) {
        if (!now.children.containsKey(board[i1][j1])) {
            return;
        }
        char ch = board[i1][j1];
        now = now.children.get(ch);
        if (!"".equals(now.word)) {
            ans.add(now.word);
        }

        board[i1][j1] = '#';
        for (int[] dir : dirs) {
            int i2 = i1 + dir[0], j2 = j1 + dir[1];
            if (i2 >= 0 && i2 < board.length && j2 >= 0 && j2 < board[0].length) {
                dfs(board, now, i2, j2, ans);
            }
        }
        board[i1][j1] = ch;
    }
}

class Trie {
    String word;
    Map<Character, Trie> children;
    boolean isWord;

    public Trie() {
        this.word = "";
        this.children = new HashMap<Character, Trie>();
    }

    public void insert(String word) {
        Trie cur = this;
        for (int i = 0; i < word.length(); ++i) {
            char c = word.charAt(i);
            if (!cur.children.containsKey(c)) {
                cur.children.put(c, new Trie());
            }
            cur = cur.children.get(c);
        }
        cur.word = word;
    }
}
```

## 20210917 <font color=#ed7336>M</font> <font color=#ec4c47>U</font>

### 36. 有效的数独

原题链接：[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

> 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
>
> 数字 1-9 在每一行只能出现一次。
> 数字 1-9 在每一列只能出现一次。
> 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
> 数独部分空格内已填入了数字，空白格用 '.' 表示。
>
> 注意：
>
> 一个有效的数独（部分已被填充）不一定是可解的。
> 只需要根据以上规则，验证已经填入的数字是否有效即可。
>
> **提示：**
>
> - `board.length == 9`
> - `board[i].length == 9`
> - `board[i][j]` 是一位数字或者 `'.'`

### 1.直接法

[参考链接](https://leetcode-cn.com/problems/valid-sudoku/solution/you-xiao-de-shu-du-by-leetcode-solution-50m6/)

``` java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        int[][] rows = new int[9][9];
        int[][] columns = new int[9][9];
        int[][][] subboxes = new int[3][3][9];
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                char c = board[i][j];
                if (c != '.') {
                    int index = c - '0' - 1;
                    rows[i][index]++;
                    columns[j][index]++;
                    subboxes[i / 3][j / 3][index]++;
                    if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
}
```

