# MySQL当中的锁

## 1.InnoDB的加锁逻辑

**事务隔离级别为读已提交 `RC` 时**

1. 当 `WHERE` 条件列为主键时，将对对应的聚簇索引记录加 `X` 锁；
2. 当 `WHERE` 条件列为唯一索引时，将对对应索引值的记录和关联的聚簇索引记录加 `X` 锁；
3. 当 `WHERE` 条件列为非唯一索引时，将对对应索引值的多条记录和关联的多条聚簇索引记录加 `X` 锁；
4. 当 `WHERE` 条件列为没有索引时，由于查询列上没有索引，因此只能走聚簇索引，进行全表扫描，这使得聚簇索引上所有的记录都被加上了 `X` 锁（锁住的是聚簇索引记录）；在通过主键列查询时，若以没有索引的列对应记录的列值以外的值作查询，则可以请求到 `X ` 锁（MySQL 有一些改进，在 MySQL Server 过滤条件，发现不满足后，会调用 `unlock_row` 方法，把不满足条件的记录放锁）。

**事务隔离级别为可重复读 `RR` 时**

1. 当 `WHERE` 条件列为主键时，将对对应的聚簇索引记录加 `X` 锁；
2. 当 `WHERE` 条件列为唯一索引时，将对对应索引值的记录和关联的聚簇索引记录加 `X` 锁；
3. 当 `WHERE` 条件列为非唯一索引时，将对对应索引值的多条记录和关联的多条聚簇索引记录加 `X` 锁；此外，为了防止发生幻读，将对对应索引值记录附近的间隙加间隙锁，会阻塞其它事务对索引值记录附近的间隙的插入与删除操作；
4. 当 `WHERE` 条件列为没有索引时，由于查询列上没有索引，因此只能走聚簇索引，进行全表扫描，这使得聚簇索引上所有的记录都被加上了 `X` 锁（锁住的是聚簇索引记录）；在通过主键列查询时，若以没有索引的列对应记录的列值以外的值作查询，则可以请求到 `X ` 锁（MySQL 有一些改进，在 MySQL Server 过滤条件，发现不满足后，会调用 `unlock_row` 方法，把不满足条件的记录放锁）；此外，为了防止发生幻读，将对对应索引值记录附近的间隙加间隙锁，会阻塞其它事务对索引值记录附近的间隙的插入与删除操作。

> **可重复读 `RR`** 隔离级别在 `WHERE` 条件列为「非唯一索引和没有索引」时，比**读已提交 `RC` **隔离级别多了在索引值记录附近间隙上加的「间隙锁」，这也正是**可重复读 `RR`** 隔离级别不会出现幻读的原因。

**事务隔离级别为可序列化 `Serializable` 时**

可序列化 `Serializable` 作为最高隔离级别，在执行「插入、更新、删除」这样的**当前读**操作时，与可重复读 `RR` 隔离级别一致。只是在执行没有加锁「查询」的**快照读**操作时，可序列化 `Serializable` 隔离级别将对记录加上共享锁。因此，可序列化 `Serializable` 隔离级别下，不存在「MVCC」式的快照读。



