# 2021年8月力扣每日1题

## 20210801 <font color=#009975>E</font> <font color=#009975>S</font>

### 1337. 矩阵中战斗力最弱的 K 行

原题链接：[1337. 矩阵中战斗力最弱的 K 行](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/)

> 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
>
> 请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
>
> 如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
>
> 军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

### 1.排序

``` java
class Solution {

    // 用Row类表示每一行的信息
    // 包括行号和军人数量
    public static class Row {
        
        // 第几行
        int idx;

        // 军人数量
        int soldiers;

        Row(int idx, int soldiers) {
            this.idx = idx;
            this.soldiers = soldiers;
        }
    }

    public int[] kWeakestRows(int[][] mat, int k) {
        int m = mat.length, n = mat[0].length;

        // 统计每一行的军人数量并构建Row对象放入rows集合中
        List<Row> rows = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            int soldiers = 0;
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1) {
                    soldiers++;
                }
            }

            rows.add(new Row(i, soldiers));
        }

        // 排序：soldiers相同按idx从小到大排序
        // soldiers不相同按soldiers从小到大排序
        Collections.sort(rows, (a, b) -> {
            if (a.soldiers == b.soldiers) {
                return a.idx - b.idx;
            } else {
                return a.soldiers - b.soldiers;
            }
        });

        // 收集前k个结果并返回
        int[] res = new int[k];
        for (int i = 0; i < k; i++) {
            res[i] = rows.get(i).idx;
        }

        return res;
    }
}
```

## 20210802 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 743. 网络延迟时间

原题链接：[743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

> 给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
>
> 现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

### 1.Dijkstra

[参考题解](https://leetcode-cn.com/problems/network-delay-time/solution/wang-luo-yan-chi-shi-jian-by-leetcode-so-6phc/)

``` java
class Solution {
    public int networkDelayTime(int[][] times, int n, int k) {
        // 表示最大值
        final int INF = Integer.MAX_VALUE / 2;

        // 二维数组g表示源节点到目标节点的距离
        // 无法到达置为INF
        int[][] g = new int[n][n];
        // 初始化二维数组g
        for (int i = 0; i < n; ++i) {
            Arrays.fill(g[i], INF);
        }

        // 将源节点到目标节点的距离填充到二维数组中
        for (int[] t : times) {
            int x = t[0] - 1, y = t[1] - 1;
            g[x][y] = t[2];
        }

        // 用数组dist表示节点k到图中各个节点的最短距离
        int[] dist = new int[n];
        // 初始化数组dist
        Arrays.fill(dist, INF);
        // 表示k到k节点的距离为0
        dist[k - 1] = 0;
        // 标记访问过的节点
        boolean[] used = new boolean[n];

        // 利用Dijkstra算法计算单源最短路径
        for (int i = 0; i < n; ++i) {
            // 1.找到图中k节点能够到达的节点中路径最短的一个节点
            int x = -1;
            for (int y = 0; y < n; ++y) {
                if (!used[y] && (x == -1 || dist[y] < dist[x])) {
                    x = y;
                }
            }

            // 2.将这个节点标记为已访问
            used[x] = true;

            // 3.把x能到达的节点更新一遍
            for (int y = 0; y < n; ++y) {
                dist[y] = Math.min(dist[y], dist[x] + g[x][y]);
            }
        }

        // k节点到达图中各个节点最短路径的最大值
        // 就是能使所有节点都收到信号的时间
        int ans = Arrays.stream(dist).max().getAsInt();
        
        // 如果这个值为INF表示有节点无法通过节点k到达
        return ans == INF ? -1 : ans;
    }
}
```

## 20210803 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 581. 最短无序连续子数组

原题链接：[581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

> 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
>
> 请你找出符合题意的 最短 子数组，并输出它的长度。

### 1.双指针 + 排序

[参考题解](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-e1le/)

``` java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int length = nums.length;
        // 先将数组nums复制一份放到数组clone中
		int[] clone = new int[length];
		for (int i = 0; i < length; i++) {
			clone[i] = nums[i];
		}

        // 然后对数组clone进行排序
		Arrays.sort(clone);

        // 利用双指针比较数组nums和clone不同的地方
		int i = 0, j = length - 1;
		while (i <= j && nums[i] == clone[i]) {
			i++;
		}

		while (i <= j && nums[j] == clone[j]) {
			j--;
		}
			
        // 区间[i, j]就是最短子数组
		return j - i + 1;
    }
}
```

## 20210804 <font color=#ed7336>M</font> <font color=#ed7336>R</font>

### 611. 有效三角形的个数

原题链接：[611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

> 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

### 1.排序 + 二分法

[参考题解](https://leetcode-cn.com/problems/valid-triangle-number/solution/you-xiao-san-jiao-xing-de-ge-shu-by-leet-t2td/)

``` java
class Solution {
    public int triangleNumber(int[] nums) {
        int length = nums.length;

        // 要保证三元组能组成三角形，那么必须保证两边之和大于第三边
        // 这里先对数组nums升序排序
        Arrays.sort(nums);

        // 排序后的nums满足：nums[i] < nums[j] < nums[k] (i < j < k)
        // 必然有nums[i] + nums[k] > nums[j]和nums[j] + nums[k] > nums[i]
        // 那么只需要保证nums[i] + nums[j] > nums[k]即可使三元组组成三角形
        int sum = 0;
        for (int i = 0; i < length; i++) {
            for (int j = i + 1; j < length; j++) {
                // 通过二分法找到能使nums[i] + nums[j] > nums[k]成立的k的区间
                // 这个区间所有的元素都能和nums[i]与nums[j]组成三角形
                int left = j + 1, right = length - 1, k = j;
                while (left <= right) {
                    int mid = left + right >> 1;
                    if (nums[i] + nums[j] > nums[mid]) {
                        left = mid + 1;
                        k = mid;
                    } else {
                        right = mid - 1;
                    }
                }

                // (j, k]就是满足条件的区间
                sum += k - j;
            }
        }

        return sum;
    }
}
```

